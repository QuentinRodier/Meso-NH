!     ######spl
      MODULE MODI_READ_DIACHRO
!     ########################
!
INTERFACE
!
SUBROUTINE READ_DIACHRO(HFILEDIA,HLUOUTDIA,HGROUP)
CHARACTER(LEN=*) :: HFILEDIA,HLUOUTDIA
CHARACTER(LEN=*) :: HGROUP
END SUBROUTINE READ_DIACHRO
!
END INTERFACE
END MODULE MODI_READ_DIACHRO
!     ##################################################
      SUBROUTINE READ_DIACHRO(HFILEDIA,HLUOUTDIA,HGROUP)
!     ##################################################
!
!!****  *READ_DIACHRO* - Lecture d'un enregistrement dans un fichier
!!                       diachronique

!!    PURPOSE
!!    -------
!!      Permet la lecture d'un enregistrement de nom HGROUP
!!      (En realite, il s'agit de plusieurs enregistrements 
!!       identifies par un nom=HGROUP+1suffixe)
!      
!
!!**  METHOD
!!    ------
!!      En fonction du nom passe dans HGROUP , on lit un 1er enregistrement
!!      qui fournit le type d'informations a traiter. Puis ce type donne
!!      acces a un 2eme enregistrement contenant les dimensions de
!!      toutes les matrices qui seront lues dans les articles suivants
!!      et qui sont donc allouees dynamiquement a ce moment.
!!     
!!
!!    EXTERNAL
!!    --------
!!      None
!!
!!    IMPLICIT ARGUMENTS
!!    ------------------
!!      Module
!!
!!    REFERENCE
!!    ---------
!!
!!
!!    AUTHOR
!!    ------
!!      J. Duron    * Laboratoire d'Aerologie *
!!
!!
!!    MODIFICATIONS
!!    -------------
!!      Original       05/02/96
!!      Updated   PM 
!-------------------------------------------------------------------------------
!
!*       0.    DECLARATIONS
!              ------------
!
USE MODD_TYPE_AND_LH
USE MODD_RESOLVCAR
USE MODD_DIM1
USE MODD_ALLOC_FORDIACHRO
USE MODI_ALLOC_FORDIACHRO
USE MODI_FMREAD

IMPLICIT NONE
!
!*       0.1   Dummy arguments
!              ---------------

CHARACTER(LEN=*)              :: HFILEDIA,HLUOUTDIA
CHARACTER(LEN=*)              :: HGROUP

!
!*       0.1   Local variables
!              ---------------

!
CHARACTER(LEN=16) :: YRECFM, YTEM
CHARACTER(LEN=LEN(HFILEDIA)+4) :: YFILEDIA
! Aout 99 longueur YCOMMENT passee de 20 a 100
CHARACTER(LEN=100) :: YCOMMENT
CHARACTER(LEN=3)  :: YJ
INTEGER   ::   ILENG, ILENCH, ILENTITRE, ILENUNITE, ILENCOMMENT, IRESP
INTEGER   ::   ILUOUTDIA,INPRARDIA,IFTYPEDIA,IVERBDIA,ININARDIA
INTEGER   ::   II, IJ, IK, IT, IN, IP, INUM, J, JJ
INTEGER   ::   INTRAJT, IKTRAJX, IKTRAJY, IKTRAJZ
INTEGER   ::   ITTRAJX, ITTRAJY, ITTRAJZ
INTEGER   ::   INTRAJX, INTRAJY, INTRAJZ
INTEGER   ::   IIMASK, IJMASK, IKMASK, ITMASK, INMASK, IPMASK
INTEGER   ::   ICOMPX, ICOMPY, ICOMPZ
INTEGER   ::   ILENGP, IUSCORE, III
INTEGER,DIMENSION(:),ALLOCATABLE :: ITABCHAR
CHARACTER(LEN=20) :: CFORMAT
!------------------------------------------------------------------------------
!
ILENCH = LEN(YCOMMENT)
if (nverbia > 0)then
print *,' BEGIN READ_DIACHRO ******************'
endif

CALL FMLOOK(HLUOUTDIA,HLUOUTDIA,ILUOUTDIA,IRESP)
!WRITE(ILUOUTDIA,*)' READ_DIACHRO IRESP ',IRESP
IF(IRESP== -54)THEN
  CALL FMATTR(HLUOUTDIA,HLUOUTDIA,ILUOUTDIA,IRESP)
  OPEN(UNIT=ILUOUTDIA,FILE=HLUOUTDIA)
  IFTYPEDIA = 0; IVERBDIA = 5
ENDIF
YFILEDIA=ADJUSTL(ADJUSTR(HFILEDIA)//'.lfi')
CALL FMLOOK(YFILEDIA,HLUOUTDIA,INUM,IRESP)
!WRITE(ILUOUTDIA,*)' READ_DIACHRO IRESP ',IRESP
IF(IRESP ==  -54)THEN
! Modif demandee par Nicole Asencio. 28/9/98
  IFTYPEDIA=2
  CALL FMOPEN(HFILEDIA,'OLD',HLUOUTDIA,INPRARDIA,IFTYPEDIA,IVERBDIA, &
  ININARDIA,IRESP)
END IF

!
! 1er enregistrement TYPE
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TYPE')
ILENG = LEN(CTYPE)
ALLOCATE(ITABCHAR(ILENG))
CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,NGRID,ILENCH,YCOMMENT,IRESP)
IF(IRESP == -47)THEN
  DEALLOCATE(ITABCHAR)
  print *,' ERREUR D''ORTHOGRAPHE OU DE SYNTAXE DANS VOTRE DIRECTIVE '
  print *,' VERIFIEZ ET RENTREZ LA A NOUVEAU '
  LPBREAD=.TRUE.
  RETURN
ENDIF
DO J = 1,ILENG
  CTYPE(J:J) = CHAR(ITABCHAR(J))
ENDDO
!WRITE(ILUOUTDIA,*)' 1er ENREGISTREMENT LU OK',CTYPE
DEALLOCATE(ITABCHAR)
!
if (nverbia > 0)then
print *,' TYPE ',CTYPE
endif

! 2eme  enregistrement DIMENSIONS des MATRICES et LONGUEUR des TABLEAUX de CARACTERES et FLAGS de COMPRESSION sur les DIFFERENTS AXES
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.DIM')
SELECT CASE(CTYPE)

  CASE('CART','MASK','SPXY')

    ILENG = 34
    ALLOCATE(ITABCHAR(ILENG))

    CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,ITABCHAR, &
    NGRID,ILENCH,YCOMMENT,IRESP)
    ILENTITRE=ITABCHAR(1); ILENUNITE=ITABCHAR(2)
    ILENCOMMENT=ITABCHAR(3); II=ITABCHAR(4)
    IJ=ITABCHAR(5); IK=ITABCHAR(6)
    IT=ITABCHAR(7); IN=ITABCHAR(8)
    IP=ITABCHAR(9); NIL=ITABCHAR(10)
    NJL=ITABCHAR(11); NKL=ITABCHAR(12)
    NIH=ITABCHAR(13); NJH=ITABCHAR(14)
    NKH=ITABCHAR(15); ICOMPX=ITABCHAR(16)
    ICOMPY=ITABCHAR(17); ICOMPZ=ITABCHAR(18)
    INTRAJT=ITABCHAR(19); IKTRAJX=ITABCHAR(20)
    IKTRAJY=ITABCHAR(21); IKTRAJZ=ITABCHAR(22)
    ITTRAJX=ITABCHAR(23); ITTRAJY=ITABCHAR(24)
    ITTRAJZ=ITABCHAR(25); INTRAJX=ITABCHAR(26)
    INTRAJY=ITABCHAR(27); INTRAJZ=ITABCHAR(28)
    IIMASK=ITABCHAR(29); IJMASK=ITABCHAR(30)
    IKMASK=ITABCHAR(31); ITMASK=ITABCHAR(32)
    INMASK=ITABCHAR(33); IPMASK=ITABCHAR(34)
    LICP=.FALSE.; LJCP=.FALSE.; LKCP=.FALSE.
    IF(ICOMPX==1)THEN
      LICP=.TRUE.
    ENDIF
    IF(ICOMPY==1)THEN
      LJCP=.TRUE.
    ENDIF
    IF(ICOMPZ==1)THEN
      LKCP=.TRUE.
    ENDIF
if (nverbia > 0)then
print *,' DIM ',ILENG
!print *, ITABCHAR
endif
!   WRITE(ILUOUTDIA,*)' ILENTITRE,ILENUNITE,ILENCOMMENT  LUES',ILENTITRE,ILENUNITE,ILENCOMMENT
    DEALLOCATE(ITABCHAR)

  CASE DEFAULT

    ILENG = 25
    ALLOCATE(ITABCHAR(ILENG))

    CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,ITABCHAR, &
    NGRID,ILENCH,YCOMMENT,IRESP)

    ILENTITRE=ITABCHAR(1); ILENUNITE=ITABCHAR(2)
    ILENCOMMENT=ITABCHAR(3); II=ITABCHAR(4)
    IJ=ITABCHAR(5); IK=ITABCHAR(6)
    IT=ITABCHAR(7); IN=ITABCHAR(8)
    IP=ITABCHAR(9)
    INTRAJT=ITABCHAR(10); IKTRAJX=ITABCHAR(11)
    IKTRAJY=ITABCHAR(12); IKTRAJZ=ITABCHAR(13)
    ITTRAJX=ITABCHAR(14); ITTRAJY=ITABCHAR(15)
    ITTRAJZ=ITABCHAR(16); INTRAJX=ITABCHAR(17)
    INTRAJY=ITABCHAR(18); INTRAJZ=ITABCHAR(19)
    IIMASK=ITABCHAR(20); IJMASK=ITABCHAR(21)
    IKMASK=ITABCHAR(22); ITMASK=ITABCHAR(23)
    INMASK=ITABCHAR(24); IPMASK=ITABCHAR(25)

!   CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,ILENTITRE,ILENUNITE, &
!   ILENCOMMENT,II,IJ,IK,IT,IN,IP,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia > 0)then
print'(A5,I3)',' DIM ',ILENG
write(CFORMAT,FMT='(A1,I2,A7)') "(",ILENG,"(I4,X))"
print CFORMAT, ITABCHAR
endif
    DEALLOCATE(ITABCHAR)
END SELECT
!WRITE(ILUOUTDIA,*)' 2eme ENREGISTREMENT LU OK'
!
! Allocation des tableaux pour la lecture
!
if (nverbia > 0)then
  print *,' READ_DIACHRO AVANT ALLOC'
  print'(A19,6I4)',' II,IJ,IK,IT,IN,IP ',II,IJ,IK,IT,IN,IP
  print'(A41,5I4)',' INTRAJT,IKTRAJX,IKTRAJY,IKTRAJZ,ITTRAJX ',INTRAJT,IKTRAJX,IKTRAJY,IKTRAJZ,ITTRAJX
  print'(A49,6I4)',' ITTRAJX,ITTRAJY,ITTRAJZ,INTRAJX,INTRAJY,INTRAJZ ',ITTRAJX,ITTRAJY,ITTRAJZ,INTRAJX,INTRAJY,INTRAJZ
  print'(A42,6I4)',' IIMASK,IJMASK,IKMASK,ITMASK,INMASK,IPMASK ',IIMASK,IJMASK,IKMASK,ITMASK,INMASK,IPMASK
endif 
CALL ALLOC_FORDIACHRO(II,IJ,IK,IT,IN,IP,2,INTRAJT,IKTRAJX,IKTRAJY,  &
 IKTRAJZ,ITTRAJX,ITTRAJY,ITTRAJZ,INTRAJX,INTRAJY,INTRAJZ,IIMASK,    &
 IJMASK,IKMASK,ITMASK,INMASK,IPMASK)
if (nverbia > 0)then
  print *,' READ_DIACHRO APRES ALLOC'
  print'(A19,6I4)',' II,IJ,IK,IT,IN,IP ',II,IJ,IK,IT,IN,IP
  print'(A41,5I4)',' INTRAJT,IKTRAJX,IKTRAJY,IKTRAJZ,ITTRAJX ',INTRAJT,IKTRAJX,IKTRAJY,IKTRAJZ,ITTRAJX
  print'(A49,6I4)',' ITTRAJX,ITTRAJY,ITTRAJZ,INTRAJX,INTRAJY,INTRAJZ ',ITTRAJX,ITTRAJY,ITTRAJZ,INTRAJX,INTRAJY,INTRAJZ
  print'(A42,6I4)',' IIMASK,IJMASK,IKMASK,ITMASK,INMASK,IPMASK ',IIMASK,IJMASK,IKMASK,ITMASK,INMASK,IPMASK
endif 
!
! 3eme enregistrement TITRE
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TITRE')
if (nverbia > 0)then
  print'(A14,I3,X,I3)',' ILENTITRE IP ',ILENTITRE,IP
endif
ILENG = ILENTITRE*IP
ALLOCATE(ITABCHAR(ILENG))
CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia > 0)then
  print'(A14,I3,X,I3)' ,' ILENTITRE IP ',ILENTITRE,IP
endif
DO JJ = 1,IP
DO J = 1,ILENTITRE
  CTITRE(JJ)(J:J)=CHAR(ITABCHAR(ILENTITRE*(JJ-1)+J))
ENDDO
!WRITE(ILUOUTDIA,*)CTITRE(JJ)
if (nverbia > 0)then
print *,' TITRE '
print *,CTITRE(JJ)
endif
ENDDO
!WRITE(ILUOUTDIA,*)' 3eme ENREGISTREMENT LU OK'
DEALLOCATE(ITABCHAR)
!
! 4eme enregistrement UNITE
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.UNITE')
ILENG = ILENUNITE*IP
ALLOCATE(ITABCHAR(ILENG))
CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,NGRID,ILENCH,YCOMMENT,IRESP)
DO JJ = 1,IP
!! Fev 2002
  CUNITE(JJ)=' '
  if (nverbia > 0)then
  print *,' **read_diachro CUNITE AP MISE A BLANC ILENUNITE JJ ',ILENUNITE,JJ, CUNITE(JJ)
  endif
!! Fev 2002
DO J = 1,ILENUNITE
  CUNITE(JJ)(J:J)=CHAR(ITABCHAR(ILENUNITE*(JJ-1)+J))
ENDDO
!WRITE(ILUOUTDIA,*)CUNITE(JJ)
if (nverbia > 0)then
print *,' UNITE'
print *,CUNITE(JJ)
endif
ENDDO
!WRITE(ILUOUTDIA,*)' 4eme ENREGISTREMENT LU  OK'
DEALLOCATE(ITABCHAR)
!
! 5eme enregistrement COMMENT
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.COMMENT')
ILENG = ILENCOMMENT*IP
ALLOCATE(ITABCHAR(ILENG))
CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,NGRID,ILENCH,YCOMMENT,IRESP)
DO JJ = 1,IP
DO J = 1,ILENCOMMENT
  CCOMMENT(JJ)(J:J)=CHAR(ITABCHAR(ILENCOMMENT*(JJ-1)+J))
ENDDO
!WRITE(ILUOUTDIA,*)CCOMMENT(JJ)
if (nverbia > 0)then
print *,' COMMENT'
print *,CCOMMENT(JJ)
endif
ENDDO
!WRITE(ILUOUTDIA,*)' 5eme ENREGISTREMENT LU OK'
DEALLOCATE(ITABCHAR)
!
! 6eme enregistrement VAR
!
! Dans la mesure ou cette matrice risque d'etre tres volumineuse, on a ecrit 
! et donc on lit un enregistrement par processus
DO J = 1,IP
YJ = '   '
IF(J < 10)WRITE(YJ,'(I1)')J 
IF(J >= 10 .AND. J < 100)WRITE(YJ,'(I2)')J
YJ = ADJUSTL(YJ)
IF(J >= 100 .AND. J < 1000)WRITE(YJ,'(I3)')J
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.PROC'//YJ)
ILENG = II*IJ*IK*IT*IN
!print *,' PVAR '
CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
XVAR(:,:,:,:,:,J),NGRIDIA(J),ILENCH,YCOMMENT,IRESP)
!print *,' YJ ILENG YRECFM NGRIDIA',YJ,ILENG,YRECFM,NGRIDIA(J)
!WRITE(ILUOUTDIA,*)' 6eme ENREGISTREMENT LU OK'
if (nverbia > 0)then
  print *,' J de VAR(J) ',J
endif
ENDDO
! PROVI MOdif dim  d'un spectre pour voir si pb
!NIMAX=0 ; NJMAX=0 ; NIL=0; NJL=0; NIH=0; NJH=0
!
! 7eme enregistrement TRAJT
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJT')
ILENG = IT*INTRAJT
CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
XTRAJT,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia == -5)then
print *,' XTRAJT ',XTRAJT
endif
if (nverbia > 0)then
print *,' XTRAJT '
!print *,XTRAJT
endif
!
! Dans certains cas
!
!
! 8eme enregistrement TRAJX
!
IF(IKTRAJX /= 0 .AND. ITTRAJX /= 0 .AND. INTRAJX /= 0 )THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJX')
  ILENG = IKTRAJX*ITTRAJX*INTRAJX
  CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  XTRAJX,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia > 0)then
print *,' XTRAJX'
!print *,XTRAJX
endif
ENDIF
!
!                        ou
!
if (nverbia > 0)then
  print'(A42,6I4)',' IIMASK,IJMASK,IKMASK,ITMASK,INMASK,IPMASK ',&
  IIMASK,IJMASK,IKMASK,ITMASK,INMASK,IPMASK
endif
IF(IIMASK /= 0 .AND. IJMASK /= 0 .AND. IKMASK /= 0 .AND. &
   ITMASK /= 0 .AND. INMASK /= 0 .AND. IPMASK /= 0)THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.MASK')
  ILENG = IIMASK*IJMASK*IKMASK*ITMASK*INMASK*IPMASK
  CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  XMASK,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia > 0)then
  IF(IRESP /= 0)THEN
    print'(A19,A20,I1)',' YRECFM IRESP MASK ',YRECFM,IRESP
  ENDIF
endif
! Modif demandee par Nicole pour les budgets en Juin 99 mais compatible avec
! les anciennes ecritures
! (Ecriture du masque 1 seule fois pour tous les groupes et par sequence temp.
! avec le nom : 'MASK_nnnn.MASK' (nnnn=suffixe numerique id. a celui du
! nom des bilans pour avoir la bonne correspondance temporelle))
! Donc si en lecture on ne trouve pas l'enr. de nom YRECFM ci-dessus, 
! on recherche celui de nom 'MASK_nnnn.MASK'
!
  IF(IRESP == -47)THEN
    YTEM=YRECFM
    ILENGP=LEN_TRIM(HGROUP)
    IUSCORE=INDEX(HGROUP,'___')
    IF(IUSCORE == 0)THEN
      IUSCORE=INDEX(HGROUP,'__')
      IF(IUSCORE == 0)THEN
        IUSCORE=INDEX(HGROUP,'_')
        IUSCORE=IUSCORE+1
      ELSE
        IUSCORE=IUSCORE+2
      ENDIF
    ELSE
      IUSCORE=IUSCORE+3
    ENDIF
    YRECFM(1:LEN(YRECFM))=' '
    YRECFM='MASK_'
    YRECFM=ADJUSTL(ADJUSTR(YRECFM)//HGROUP(IUSCORE:ILENGP))
    YRECFM=ADJUSTL(ADJUSTR(YRECFM)//'.MASK')
    print *,' Absence ',YTEM(1:LEN_TRIM(YTEM)),' Recherche ',YRECFM(1:LEN_TRIM(YRECFM))
    CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
    XMASK,NGRID,ILENCH,YCOMMENT,IRESP)
    IF(IRESP /= 0)THEN
      print *,'PB ou ABSENCE ENR. de nom',YRECFM,' ou ',YTEM
      print *,'Impossibilite de tracer des MASQUES'
    ENDIF
  ENDIF
  
if (nverbia > 0)then
do iii=1,INMASK
print *,' XMASK',size(XMASK,1),size(XMASK,2),' N',III
!print 10,XMASK(:,:,:,:,iii,:)
10 FORMAT(40I2)
enddo
endif

ENDIF
!
! 9eme enregistrement TRAJY
!
IF(IKTRAJY /= 0 .AND. ITTRAJY /= 0 .AND. INTRAJY /= 0 )THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJY')
  ILENG = IKTRAJY*ITTRAJY*INTRAJY
  CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  XTRAJY,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia > 0)then
print *,' XTRAJY'
!print *,XTRAJY
endif
ENDIF
!
! 10eme enregistrement TRAJZ
!
IF(IKTRAJZ /= 0 .AND. ITTRAJZ /= 0 .AND. INTRAJZ /= 0 )THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJZ')
  ILENG = IKTRAJZ*ITTRAJZ*INTRAJZ
  CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  XTRAJZ,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia > 0)then
print *,' XTRAJZ'
!print *,XTRAJZ
endif
ENDIF
!
! 11eme enregistrement  XDATIME
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.DATIM')
ILENG=16*IT
CALL FMREAD(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
XDATIME,NGRID,ILENCH,YCOMMENT,IRESP)
if (nverbia > 0)then
print *,' XDATIME '
!print *,XDATIME
endif
if (nverbia == -5)then
print *,' XDATIME ',XDATIME
!print *,XDATIME
endif

if (nverbia > 0)then
print *,' END READ_DIACHRO **************'
endif
!
!-----------------------------------------------------------------------------
!
!*       2.       EXITS
!                 -----
! 
RETURN
END SUBROUTINE READ_DIACHRO
