!     ######spl
      SUBROUTINE TRAXY(PTEMX,PTEMY,KLOOP,HTITX,HTITY,PTIMED,PTIMEF)
!     #############################################################
!
!!****  *TRAXY* - 
!!
!!    PURPOSE
!!    -------
!
!!**  METHOD
!!    ------
!!     
!!    EXTERNAL
!!    --------
!!
!!
!!    IMPLICIT ARGUMENTS
!!    ------------------
!! modif juin 2010 : ajout de LVARNPHUSER=T et LFACTAXEX=T
!!
USE MODD_NMGRID
USE MODN_PARA
USE MODN_NCAR
USE MODD_COORD  
USE MODD_FILES_DIACHRO
USE MODD_TYPE_AND_LH
USE MODD_GRID1  
!USE MODD_GRID
USE MODD_CONF   
USE MODD_DIM1  
USE MODD_SUPER  
USE MODD_TIT
USE MODD_NMGRID
USE MODD_TITLE
USE MODD_RESOLVCAR
USE MODD_ALLOC_FORDIACHRO
USE MODD_PARAMETERS
USE MODD_CTL_AXES_AND_STYL
USE MODI_SET_DIM
!
IMPLICIT NONE
!
INTERFACE
      SUBROUTINE IMAGE_FORDIACHRO(PTAB,KLREF,PTABINT,KNHI,KNDOT,HTEXTE)
      CHARACTER(LEN=*)   :: HTEXTE
      REAL                :: PTABINT
      REAL,DIMENSION(:,:) :: PTAB
      INTEGER :: KNI, KNDOT, KLREF
      END SUBROUTINE IMAGE_FORDIACHRO
END INTERFACE
!
!*      0.1    Dummy arguments 
!
INTEGER    :: KLOOP
REAL,DIMENSION(:)  :: PTEMX, PTEMY
REAL               :: PTIMED, PTIMEF
CHARACTER(LEN=*) :: HTITX, HTITY
!
!*      0.2    Local variables 
!
!
INTEGER           :: ICOMPT=0
INTEGER,SAVE      :: ISUPERDIA, ILENW, ILR
INTEGER,SAVE      :: J, IC, ID, ITOT, JMCUR
INTEGER           :: JD, JE, JF, JI, J2, JJE, JA, JM
INTEGER           :: ISUIT
INTEGER           :: INUM, IRESP, IER, IERR
INTEGER           :: ISTYL
INTEGER,DIMENSION(:),ALLOCATABLE,SAVE   :: ICOMPTSZ, IBRECOUV, IST
INTEGER,DIMENSION(:,:),ALLOCATABLE,SAVE :: IRECOUV, IWORK
!
REAL,SAVE         :: ZMINX, ZMAXX, ZMINY, ZMAXY, ZZMINY, ZZMAXY
REAL,SAVE         :: ZVL, ZVR, ZVB, ZVT, ZWL, ZWR, ZWB,ZWT
REAL         :: ZWLL,ZWRR,ZWBB,ZWTT
INTEGER,SAVE      :: IDD
REAL,SAVE         :: ZZVT, ZZT
REAL,DIMENSION(:,:),ALLOCATABLE,SAVE :: ZTEMX2D, ZTEMY2D
REAL,DIMENSION(:,:),ALLOCATABLE,SAVE :: ZTEM2D, ZWORK2D
REAL,DIMENSION(:),ALLOCATABLE,SAVE   :: ZTIMD, ZTIMF, ZWORK1D
REAL,DIMENSION(:),ALLOCATABLE        :: ZWT1, ZWT2
REAL,SAVE         :: ZW, ZE36, ZLWSC
REAL              :: ZXPOSTITT1, ZXYPOSTITT1
REAL              :: ZXPOSTITT2, ZXYPOSTITT2
REAL              :: ZXPOSTITT3, ZXYPOSTITT3
REAL              :: ZXPOSTITB1, ZXYPOSTITB1
REAL              :: ZXPOSTITB2, ZXYPOSTITB2
REAL              :: ZXPOSTITB3, ZXYPOSTITB3
REAL              :: ZCONSTIM
!INTEGER           :: ICLIP
!REAL,DIMENSION(4) :: ZCL
!
CHARACTER(LEN=80) :: YTEM, YCAR
CHARACTER(LEN=40),SAVE :: YTITY
CHARACTER(LEN=40),DIMENSION(:),ALLOCATABLE,SAVE :: YTITGAL
CHARACTER(LEN=1)  :: YC1
CHARACTER(LEN=2)  :: YC2, YTEXT
CHARACTER(LEN=3)  :: YC3
!
LOGICAL,SAVE :: GOK
LOGICAL      :: GCOLINE
!
!-------------------------------------------------------------------------------
ZZVT=0.; ZZT=0.
GOK=.FALSE.
ZE36=1.E36
ICOMPT=ICOMPT+1
IF(NVERBIA > 0)THEN
print *,'TRAXY ICOMPT ',ICOMPT
print *,'TRAXY LCONT, LRELIEF',LCONT, LRELIEF
ENDIF
!print *,' PTEMX ',PTEMX
!print *,' PTEMY ',PTEMY

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IF(LPRINT)THEN
  CALL FMLOOK('FICVAL','FICVAL',INUM,IRESP)
  IF(IRESP /= 0)THEN
    CALL FMATTR('FICVAL','FICVAL',INUM,IRESP)
    OPEN(UNIT=INUM,FILE='FICVAL',FORM='FORMATTED')
    PRINT '('' LPRINT=T --> Les valeurs seront mises dans le fichier FICVAL '')'
  ENDIF
  WRITE(INUM,'(''TRAXY  '',''G:'',A16,'' P:'',A25,'' TD:'',F8.0,''s'','' TF:'', &
& F8.0,''s'')')CGROUP,CTITGAL(1:25),PTIMED,PTIMEF
  WRITE(INUM,'(''TITX:'',A25,'' TITY:'',A25,'' NBVAL:'',I8)')HTITX,HTITY,SIZE(PTEMX)
  IF(LPLUS .OR.LMINUS)THEN
    WRITE(INUM,'(A70)')CTITB3
  ELSE
    WRITE(INUM,'(A40)')CTITGAL
  ENDIF
! JUin 2001 Ecriture des dates (Demande G.Jaubert ) si LPRDAT=T
  IF(LPRDAT)THEN
    IF(.NOT.ALLOCATED(XPRDAT))THEN
      print *,'**TRAXY XPRDAT NON ALLOUE.Dates non ecrites ds FICVAL .Prevenir J.Duron'
    ELSE
      if(nverbia >0)then
       print *,' ** traxy AV toute ecriture et avec LPRDAT=T'
      endif
      WRITE(INUM,'(1X,75(1H*))')
      WRITE(INUM,'(1X,''    Dates courante   *     modele      *   experience    *      segment'')')
      WRITE(INUM,'(1X,'' J   An  M  J  Sec.  * An  M  J  Sec.  * An  M  J  Sec.  * An  M  J  Sec.'')')
      WRITE(INUM,'(1X,75(1H*))')
      if(nverbia >0)then
       print *,' ** traxy AP ecriture entete dates et avec LPRDAT=T'
      endif
      DO J=1,SIZE(XPRDAT,2)
      if(nverbia >0)then
       print *,' **  ecriture dates et avec LPRDAT=T j SIZE(XPRDAT,2) ',J,SIZE(XPRDAT,2)
      endif
        WRITE(INUM,'(1X,I3,1X,3(I4,I3,I3,I6,'' *''),I4,I3,I3,I6)')J,INT(XPRDAT(:,J))
      ENDDO
      if(nverbia >0)then
       print *,' ** traxy AP ecriture dates et avec LPRDAT=T'
      endif
    ENDIF
  ENDIF
! JUin 2001 Ecriture des dates 
!!Avril 2002 + lat et lon
  IF(LCV .AND. .NOT.LCARTESIAN)THEN
    WRITE(INUM,'(1X,78(1H*))')
  WRITE(INUM,'(16X,''X'',19X,''Y'',16X,''LAT'',16X,''LON'')')
  WRITE(INUM,'(1X,78(1H*))')
  DO J=1,SIZE(PTEMX)
    WRITE(INUM,'(I5,4X,E15.8,4X,E15.8,3X,E15.7,3X,E15.7)')J,PTEMX(J),PTEMY(J),&
    XLATCV(J),XLONCV(J)
  ENDDO
  ELSE
  WRITE(INUM,'(1X,45(1H*))')
  WRITE(INUM,'(16X,''X'',19X,''Y'')')
  WRITE(INUM,'(1X,45(1H*))')
  DO J=1,SIZE(PTEMX)
    WRITE(INUM,'(I5,4X,E15.8,4X,E15.8)')J,PTEMX(J),PTEMY(J)
  ENDDO
  ENDIF
      if(nverbia >0)then
       print *,' ** traxy AP ecriture coordonnees et avec LPRDAT=T ou F'
      endif
ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IF(ICOMPT == 1)THEN

  IF((CGROUPS(NSUPERDIA) == 'ZSBIS' .OR. CGROUPS(NSUPERDIA) == 'ZS') .AND. &
    NSUPERDIA > 1 .AND. .NOT.(LCH.AND.LCV))THEN
    NSUPERDIA=NSUPERDIA-1
    ISUPERDIA=NSUPERDIA
    LRELIEF=.TRUE.
  ELSE
    ISUPERDIA=NSUPERDIA
    LRELIEF=.FALSE.
  ENDIF
! IF(LMINUS .OR. LPLUS)ISUPERDIA=ISUPERDIA-1
  IF(LMINUS .OR. LPLUS)ISUPERDIA=1
! Cas LCH+LCV -> PH sur CV
  IF(NHISTORY(KLOOP) == 3)THEN
    DO J=1,MAX(1,KLOOP-1)
      IF(NHISTORY(J) == 1)THEN
	ISUPERDIA=1
      ENDIF
    ENDDO
  ENDIF
  if(nverbia > 0)then
  print *,' TRAXY ISUPERDIA ',ISUPERDIA
  endif
  ALLOCATE(ZTEMX2D(SIZE(PTEMX),ISUPERDIA))
  ALLOCATE(ZTEMY2D(SIZE(PTEMY),ISUPERDIA))
  ALLOCATE(ICOMPTSZ(ISUPERDIA))
  ALLOCATE(IBRECOUV(ISUPERDIA))
  ALLOCATE(IST(ISUPERDIA))
  ALLOCATE(IRECOUV(NBRECOUV*2,ISUPERDIA))
  ALLOCATE(ZTIMD(ISUPERDIA))
  ALLOCATE(ZTIMF(ISUPERDIA))
  ALLOCATE(YTITGAL(ISUPERDIA))
  ZTEMX2D(:,ICOMPT)=PTEMX
  ZTEMY2D(:,ICOMPT)=PTEMY
  ICOMPTSZ(ICOMPT)=SIZE(PTEMX)
  IBRECOUV(ICOMPT)=NBRECOUV
  IST(ICOMPT)=NLOOPN
  DO J=1,NBRECOUV
    IRECOUV(J*2-1,ICOMPT)=NRECOUV(J*2-1)
    IRECOUV(J*2,ICOMPT)=NRECOUV(J*2)
  ENDDO
  IF(NBRECOUV == 1 .AND. PTIMED == PTIMEF)THEN
    IRECOUV(1,ICOMPT)=1
    IRECOUV(2,ICOMPT)=SIZE(PTEMX)
  ENDIF
  ZTIMD(ICOMPT)=PTIMED
  ZTIMF(ICOMPT)=PTIMEF
  YTITGAL(ICOMPT)=CTITGAL
  YTITGAL(ICOMPT)=ADJUSTL(YTITGAL(ICOMPT))
  YTITY=HTITY
  YTITY=ADJUSTL(YTITY)

ELSE 

  ILENW=SIZE(PTEMX)

  IF(ILENW < MAXVAL(ICOMPTSZ(1:ICOMPT-1)))THEN
    ZTEMX2D(:,ICOMPT)=PTEMX
    ZTEMY2D(:,ICOMPT)=PTEMY
  ELSE
    ALLOCATE(ZTEM2D(SIZE(PTEMX),ISUPERDIA))
    ALLOCATE(ZWORK2D(SIZE(PTEMX),ISUPERDIA))
    DO J=1,ICOMPT-1
      ZTEM2D(1:ICOMPTSZ(J),J)=ZTEMX2D(1:ICOMPTSZ(J),J)
      ZWORK2D(1:ICOMPTSZ(J),J)=ZTEMY2D(1:ICOMPTSZ(J),J)
    ENDDO
    ZTEM2D(:,ICOMPT)=PTEMX
    ZWORK2D(:,ICOMPT)=PTEMY
    DEALLOCATE(ZTEMX2D,ZTEMY2D)
    ALLOCATE(ZTEMX2D(SIZE(ZTEM2D,1),SIZE(ZTEM2D,2)))
    ALLOCATE(ZTEMY2D(SIZE(ZWORK2D,1),SIZE(ZWORK2D,2)))
    ZTEMX2D(:,:)= ZTEM2D(:,:)
    ZTEMY2D(:,:)= ZWORK2D(:,:)
    DEALLOCATE(ZTEM2D,ZWORK2D)
  ENDIF

  ICOMPTSZ(ICOMPT)=SIZE(PTEMX)
  ZTIMD(ICOMPT)=PTIMED
  ZTIMF(ICOMPT)=PTIMEF
  YTITGAL(ICOMPT)=CTITGAL
  YTITGAL(ICOMPT)=ADJUSTL(YTITGAL(ICOMPT))
  HTITY=ADJUSTL(HTITY)
  IF(HTITY /= YTITY)THEN
     YTITGAL(ICOMPT)=ADJUSTL(ADJUSTR(YTITGAL(ICOMPT))//' '//HTITY) 
  ENDIF
  IBRECOUV(ICOMPT)=NBRECOUV
  IST(ICOMPT)=NLOOPN
  ILR=NBRECOUV*2

  IF(ILR <= MAXVAL(IBRECOUV(1:ICOMPT-1))*2)THEN
    DO J=1,ILR
      IRECOUV(J,ICOMPT)=NRECOUV(J)
    ENDDO
    IF(NBRECOUV == 1 .AND. PTIMED == PTIMEF)THEN
      IRECOUV(1,ICOMPT)=1
      IRECOUV(2,ICOMPT)=SIZE(PTEMX)
    ENDIF
  ELSE
    ALLOCATE(IWORK(ILR,ISUPERDIA))
    DO J=1,ICOMPT-1
      IWORK(1:IBRECOUV(J)*2,J)=IRECOUV(1:IBRECOUV(J)*2,J)
    ENDDO
    IWORK(1:ILR,ICOMPT)=NRECOUV(1:ILR)
    IF(NBRECOUV == 1 .AND. PTIMED == PTIMEF)THEN
      IWORK(1,ICOMPT)=1
      IWORK(2,ICOMPT)=SIZE(PTEMX)
    ENDIF
    DEALLOCATE(IRECOUV)
    ALLOCATE(IRECOUV(ILR,ISUPERDIA))
    IRECOUV(:,:)=IWORK(:,:)
    DEALLOCATE(IWORK)
  ENDIF

ENDIF

!----------------------------------------------------------------------------

IF(ICOMPT < ISUPERDIA)THEN

  RETURN

ELSE
! print *,' ICOMPT ISUPERDIA ',ICOMPT,ISUPERDIA
! print *,' IBRECOUV, IRECOUV ',IBRECOUV,IRECOUV
  ITOT=0
  DO J=1,ICOMPT
    ITOT=ITOT+ICOMPTSZ(J)
  ENDDO
! print *,' ITOT ',ITOT
  ALLOCATE(ZWORK1D(ITOT))
  ID=0
  DO J=1,ICOMPT
    IC=ICOMPTSZ(J)
    IF(LXT .OR. LYT .OR. LZT)THEN
      ZCONSTIM=0
      IF(MOD(J,8) == 1)THEN
        ZCONSTIM=XFT_ADTIM1
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.1 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM1 a zero'
        ENDIF
      ELSEIF(MOD(J,8) == 2)THEN
        ZCONSTIM=XFT_ADTIM2
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.2 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM2 a zero'
        ENDIF
      ELSEIF(MOD(J,8) == 3)THEN
        ZCONSTIM=XFT_ADTIM3
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.3 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM3 a zero'
        ENDIF
      ELSEIF(MOD(J,8) == 4)THEN
        ZCONSTIM=XFT_ADTIM4
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.4 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM4 a zero'
        ENDIF
      ELSEIF(MOD(J,8) == 5)THEN
        ZCONSTIM=XFT_ADTIM5
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.5 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM5 a zero'
        ENDIF
      ELSEIF(MOD(J,8) == 6)THEN
        ZCONSTIM=XFT_ADTIM6
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.6 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM6 a zero'
        ENDIF
      ELSEIF(MOD(J,8) == 7)THEN
        ZCONSTIM=XFT_ADTIM7
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.7 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM7 a zero'
        ENDIF
      ELSEIF(MOD(J,8) == 0)THEN
        ZCONSTIM=XFT_ADTIM8
        IF(ZCONSTIM /= 0.)THEN
          print *,' ****ATTENTION Ajout pour la courbe N.8 d''une constante de temps de : ',&
          ZCONSTIM,'sec.'
          print *,' S''il s''agit d''une erreur, remettez XFT_ADTIM8 a zero'
        ENDIF
      ENDIF
      ZTEMX2D(1:IC,J)=ZTEMX2D(1:IC,J)+ZCONSTIM
    ENDIF
    ZWORK1D(ID+1:ID+IC)=ZTEMX2D(1:IC,J)
    ID=IC+ID
  ENDDO
! Mai 2000
  IF(LSPVALT)THEN
    WHERE (ZWORK1D == XSPVALT)
      ZWORK1D = ZE36
    ENDWHERE
    DO J=1,SIZE(ZWORK1D)
      IF(ZWORK1D(J) /= ZE36)THEN
	ZMINX=ZWORK1D(J)
	ZMAXX=ZWORK1D(J)
	EXIT
      ENDIF
    ENDDO
    DO J=1,SIZE(ZWORK1D)
      IF(ZWORK1D(J) /= ZE36)THEN
	ZMINX=MIN(ZMINX,ZWORK1D(J))
	ZMAXX=MAX(ZMAXX,ZWORK1D(J))
      ENDIF
    ENDDO
    print *,' ZMINX,ZMAXX trouves, (eventuelles valeurs speciales non comprises ',ZMINX,ZMAXX

  ELSE
    ZMINX=MINVAL(ZWORK1D)
    ZMAXX=MAXVAL(ZWORK1D)
    print *,' ZMINX,ZMAXX trouves, (eventuelles valeurs speciales comprises ',ZMINX,ZMAXX
  ENDIF
! CALL VALMNMX(ZMINX,ZMAXX)
!print *,' ap VALMNMX ',ZMINX,ZMAXX
  IF(ZMAXX - ZMINX == 0)THEN
    ZMAXX=ZMAXX+1.
    ZMINX=ZMINX-1.
  ENDIF
  print *,' ZMINX,ZMAXX utilisees ',ZMINX,ZMAXX

  ID=0
  DO J=1,ICOMPT
    IC=ICOMPTSZ(J)
    ZWORK1D(ID+1:ID+IC)=ZTEMY2D(1:IC,J)
    ID=IC+ID
  ENDDO
! Mai 2000
  IF(LSPVALT)THEN
    WHERE (ZWORK1D == XSPVALT)
      ZWORK1D = ZE36
    ENDWHERE
    DO J=1,SIZE(ZWORK1D)
      IF(ZWORK1D(J) /= ZE36)THEN
	ZMINY=ZWORK1D(J)
	ZMAXY=ZWORK1D(J)
	EXIT
      ENDIF
    ENDDO
    DO J=1,SIZE(ZWORK1D)
      IF(ZWORK1D(J) /= ZE36)THEN
	ZMINY=MIN(ZMINY,ZWORK1D(J))
	ZMAXY=MAX(ZMAXY,ZWORK1D(J))
      ENDIF
    ENDDO
    print *,' ZMINY,ZMAXY trouves, (eventuelles valeurs speciales non comprises ',ZMINY,ZMAXY
  ELSE
    ZMINY=MINVAL(ZWORK1D)
    ZMAXY=MAXVAL(ZWORK1D)
    print *,' TRAXY : Bornes en Y trouvees : ',ZMINY,ZMAXY
    print *,'        (Eventuelles valeurs speciales : XSPVALT(ou XSPVAL pour trace instantane) ou 1.E36 comprises <--> relief)'
    print *,'        (Actuellement les valeurs XSPVALT(ou XSPVAL pour trace instantane)  sont tracees, pas les valeurs 1.E36)'
    print *,'        Pour les supprimer, affecter sa valeur a XSPVALT (ou XSPVAL) etfournir LSPVALT=T '
  ENDIF
  ZZMINY=1.E35
  ZZMAXY=-1.E35
  JA=0
  DO J=1,SIZE(ZWORK1D,1)
!   IF(ZWORK1D(J) /= 999. .AND. ZWORK1D(J) /= 1.E36)THEN
! Mai 2000
    IF(LSPVALT)THEN
      IF(ZWORK1D(J) /= XSPVALT .AND. ZWORK1D(J) /= 1.E36)THEN
        ZZMINY=MIN(ZZMINY,ZWORK1D(J))
        ZZMAXY=MAX(ZZMAXY,ZWORK1D(J))
      ELSE
        JA=JA+1
      ENDIF
    ELSE
      IF(ZWORK1D(J) /= XSPVAL .AND. ZWORK1D(J) /= 1.E36)THEN
        ZZMINY=MIN(ZZMINY,ZWORK1D(J))
        ZZMAXY=MAX(ZZMAXY,ZWORK1D(J))
      ELSE
        JA=JA+1
      ENDIF
    ENDIF
  ENDDO
  IF(ZZMINY /= 1.E35 .AND. ZZMAXY /= -1.E35 .AND. JA>0)THEN
    print *,'         Bornes en Y trouvees : ',ZZMINY,ZZMAXY
    print *,'        (Abstraction faite des valeurs speciales)'
  ENDIF
! CALL VALMNMX(ZMINY,ZMAXY)
  IF(ZMAXY - ZMINY == 0)THEN
    ZMAXY=ZMAXY+1.
    ZMINY=ZMINY-1.
  ENDIF
  DEALLOCATE(ZWORK1D)
! print *,' TRAXY ZMINX,ZMAXX,ZMINY,ZMAXY ',ZMINX,ZMAXX,ZMINY,ZMAXY
ENDIF
!IF(.NOT.LCONT .AND. .NOT.LRELIEF)THEN
IF(XVARMAX-XVARMIN >0)THEN
  print *,'         Bornes en Y fournies : ',XVARMIN,XVARMAX
  print *,' Si elles ne conviennent pas, donnez de nouvelles valeurs dans XVARMIN et XVARMAX '
  print *,' (Retour au calcul automatique des bornes avec XVARMIN=0 et XVARMAX=0)'
  ZMINY=XVARMIN; ZMAXY=XVARMAX
ELSE
  print *,' Vous pouvez fournir des bornes en Y dans XVARMIN et XVARMAX' 
  print *,' (Retour au calcul automatique des bornes avec XVARMIN=0 et XVARMAX=0)'
ENDIF
!ENDIF


! IF(LRELIEF .OR. LCONT)THEN
IF((LCONT .OR. LRELIEF .OR.(LRELIEF .AND. LCONT))  .AND. LXYDIA)THEN
  if(nverbia > 0)then
  print *,'passage ici NIMAX ',nimax,' LCARTESIAN ',LCARTESIAN
  print *,'passage ici NIINF,NJINF,NISUP,NJSUP ',NIINF,NJINF,NISUP,NJSUP
  endif
  IF(NIMAX == 0)THEN
    IF (NBFILES == 1)THEN
      print *,' Impossibilite de tracer les continents; pas d''entete dans le fichier'
      IF(LVPTXYUSER)THEN
        CALL SET(XVPTXYL,XVPTXYR,XVPTXYB,XVPTXYT,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
      ELSE
        CALL SET(.13,.9,.1,.9,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
      ENDIF
    ELSE
      DO J=1,NBFILES
        IF(NUMFILES(J)==NUMFILECUR)THEN
          JMCUR=J
	  if(nverbia > 0)then
	  print *,' traxy J JMCUR ',J,JMCUR
	  endif
	  EXIT
        ENDIF
      ENDDO
      DO J=1,NBFILES
        IF(NUMFILES(J)==NUMFILECUR)THEN
          CYCLE
        ELSE
          JM=J
	  if(nverbia > 0 )THEN
	  print *,' traxy JM,CFILEDIAS(JM) ',JM,CFILEDIAS(JM)
	  ENDIF
          CALL READ_FILEHEAD(JM,CFILEDIAS(JM),CLUOUTDIAS(JM))
          IF(NIMAX /= 0)THEN
            IF(NIINF == 0 .AND. NJINF == 0 .AND. NISUP == 0 .AND. &
            NJSUP == 0)THEN
              CALL SET_DIM(CFILEDIAS(JM),CLUOUTDIAS(JM),NIINF,NISUP, &
              NJINF,NJSUP,NIMAX,NJMAX,NKMAX)
              print *,' NIINF,NJINF,NISUP,NJSUP non definis --> '
              print *,' On prend la totalite du domaine horizontal sans les points de garde'
              NIINF=NIINF+JPHEXT
              NISUP=NISUP-JPHEXT
              NJINF=NJINF+JPHEXT
              NJSUP=NJSUP-JPHEXT
              IF(NVERBIA > 0)THEN
              print *,NIINF,NJINF,NISUP,NJSUP
              ENDIF
            ENDIF
            CALL COMPCOORD_FORDIACHRO(0)
            NMGRID=1
            CALL BCGRD_FORDIACHRO(2)
            IF(LRELIEF)THEN
              ALLOCATE(ZTEM2D(1:NISUP-NIINF+1,1:NJSUP-NJINF+1))
              ZTEM2D(:,:)=XXZS(NIINF:NISUP,NJINF:NJSUP,1)
              YTEXT='  '
              LCHXY=.TRUE.
              CTYPHOR='K'
              GCOLINE=LCOLINE
              LCOLINE=.FALSE.
              CALL IMAGE_FORDIACHRO(ZTEM2D,1,XDIAINT,NHI,NDOT,YTEXT)
              CALL SFLUSH
              LCOLINE=GCOLINE
! CALL GSTXCI(1)
! CALL GSPLCI(1)
              IF(LDOMAIN)THEN
                CALL GSLWSC(XLWDOMAIN)
                CALL FRSTPT(XXX(NDOMAINL,NMGRID),XXY(NDOMAINB,NMGRID))
                CALL VECTOR(XXX(NDOMAINR,NMGRID),XXY(NDOMAINB,NMGRID))
                CALL VECTOR(XXX(NDOMAINR,NMGRID),XXY(NDOMAINT,NMGRID))
                CALL VECTOR(XXX(NDOMAINL,NMGRID),XXY(NDOMAINT,NMGRID))
                CALL VECTOR(XXX(NDOMAINL,NMGRID),XXY(NDOMAINB,NMGRID))
              ENDIF
              DEALLOCATE(ZTEM2D)
              LRELIEF=.FALSE.
              if(nverbia > 0)THEN
                print *,' TRAXY NSUPERDIA AP TRACE RELIEF ',NSUPERDIA
              endif
              CGROUPS(NSUPERDIA+1)(1:LEN(CGROUPS(NSUPERDIA+1)))=' '
            ENDIF
	    if(nverbia > 0 )THEN
	      print *,' traxy JMCUR,CFILEDIAS(JMCUR) ',JMCUR,CFILEDIAS(JMCUR)
	    endif
            CALL READ_FILEHEAD(JMCUR,CFILEDIAS(JMCUR),CLUOUTDIAS(JMCUR))
            GOK=.TRUE.
            EXIT
          ELSE
            CYCLE
          ENDIF
        ENDIF
      ENDDO
      IF(.NOT.GOK)THEN
      IF(NIMAX == 0)THEN
      print *,' Impossibilite de tracer les continents; pas d''entete dans le fichier'
      IF(LVPTXYUSER)THEN
        CALL SET(XVPTXYL,XVPTXYR,XVPTXYB,XVPTXYT,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
      ELSE
        CALL SET(.13,.9,.1,.9,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
      ENDIF
      ENDIF
    ENDIF
    ENDIF
  ELSE
    if(nverbia > 0)then
      print *,' ** traxy Cas ou NIMAX =/= 0'
    endif
    IF(NIINF == 0 .AND. NJINF == 0 .AND. NISUP == 0 .AND. &
      NJSUP == 0)THEN
      DO J=1,NBFILES
        IF(NUMFILES(J)==NUMFILECUR)THEN
          JMCUR=J
	  if(nverbia > 0)then
	  print *,' traxy J JMCUR ',J,JMCUR
	  endif
	  EXIT
        ENDIF
      ENDDO
              CALL SET_DIM(CFILEDIAS(JMCUR),CLUOUTDIAS(JMCUR),NIINF,NISUP, &
              NJINF,NJSUP,NIMAX,NJMAX,NKMAX)
              print *,' NIINF,NJINF,NISUP,NJSUP non definis --> '
              print *,' On prend la totalite du domaine horizontal sans les points de garde'
              NIINF=NIINF+JPHEXT
              NISUP=NISUP-JPHEXT
              NJINF=NJINF+JPHEXT
              NJSUP=NJSUP-JPHEXT
              IF(NVERBIA > 0)THEN
              print *,NIINF,NJINF,NISUP,NJSUP
              ENDIF
            CALL COMPCOORD_FORDIACHRO(0)
            ENDIF
            NMGRID=1
    CALL BCGRD_FORDIACHRO(2)
    GOK=.TRUE.
            IF(LRELIEF)THEN
              ALLOCATE(ZTEM2D(1:NISUP-NIINF+1,1:NJSUP-NJINF+1))
              ZTEM2D(:,:)=XXZS(NIINF:NISUP,NJINF:NJSUP,1)
              YTEXT='  '
              LCHXY=.TRUE.
              GCOLINE=LCOLINE
              LCOLINE=.FALSE.
              CTYPHOR='K'
              CALL IMAGE_FORDIACHRO(ZTEM2D,1,XDIAINT,NHI,NDOT,YTEXT)
              CALL SFLUSH
              LCOLINE=GCOLINE
! CALL GSTXCI(1)
! CALL GSPLCI(1)
              IF(LDOMAIN)THEN
                CALL GSLWSC(XLWDOMAIN)
                CALL FRSTPT(XXX(NDOMAINL,NMGRID),XXY(NDOMAINB,NMGRID))
                CALL VECTOR(XXX(NDOMAINR,NMGRID),XXY(NDOMAINB,NMGRID))
                CALL VECTOR(XXX(NDOMAINR,NMGRID),XXY(NDOMAINT,NMGRID))
                CALL VECTOR(XXX(NDOMAINL,NMGRID),XXY(NDOMAINT,NMGRID))
                CALL VECTOR(XXX(NDOMAINL,NMGRID),XXY(NDOMAINB,NMGRID))
              ENDIF
              DEALLOCATE(ZTEM2D)
              LRELIEF=.FALSE.
              if(nverbia > 0)THEN
                print *,' TRAXY NSUPERDIA AP TRACE RELIEF ',NSUPERDIA
              endif
              CGROUPS(NSUPERDIA+1)(1:LEN(CGROUPS(NSUPERDIA+1)))=' '
            ENDIF
  ENDIF
ELSE
! Pour ajuster le titre en haut au dessus de la + gde fenetre en cas de
! superposition CV et PH=CV+K
  CALL GETSET(ZVL,ZVR,ZVB,ZVT,ZWL,ZWR,ZWB,ZWT,ID)
  ZZVT=ZVT
  IF(KLOOP > 1 .AND. NHISTORY(KLOOP) == 3)THEN
    DO J=1,MAX(1,KLOOP-1)
      IF(NHISTORY(J) == 1)THEN
        IF(LVPTXYUSER)THEN
	  CALL SET(ZVL,ZVR,XVPTXYB,XVPTXYT,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
	ELSE
	  CALL SET(ZVL,ZVR,ZVB,ZVT,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
	ENDIF
        if(nverbia > 0)then
	print *,' **traxy fentere recuperee ZVL,ZVR,ZVB,ZVT ',ZVL,ZVR,ZVB,ZVT
	endif
	EXIT 
      ENDIF
      IF(LVPTXYUSER)THEN
        CALL SET(XVPTXYL,XVPTXYR,XVPTXYB,XVPTXYT,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
      ELSE
        CALL SET(.13,.9,.1,.9,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
      ENDIF
    ENDDO
  ELSE
    IF(LVPTXYUSER)THEN
      CALL SET(XVPTXYL,XVPTXYR,XVPTXYB,XVPTXYT,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
    ELSE
      IF(LXYWINCUR)THEN
!!!PROVI
      ELSE
      CALL SET(.13,.9,.1,.9,ZMINX,ZMAXX,ZMINY,ZMAXY,1)
      ENDIF
!!!PROVI
    ENDIF
  ENDIF
ENDIF

CALL GETSET(ZVL,ZVR,ZVB,ZVT,ZWL,ZWR,ZWB,ZWT,ID)
XCURVPTL=ZVL;XCURVPTR=ZVR;XCURVPTB=ZVB;XCURVPTT=ZVT

CALL FORMATXY(ZWL,ZWR,ZWB,ZWT)
IF(LCOLINE)CALL TABCOL_FORDIACHRO
CALL AGSETF('SET.',4.)
CALL AGSETF('BAC.',4.)
CALL AGSETF('FRA.',2.)

CALL GSCLIP(1)


DO J = 1,ISUPERDIA
!DO J = 1,NSUPERDIA

  ALLOCATE(ZWT1(ICOMPTSZ(J)),ZWT2(ICOMPTSZ(J)))
  ZWT1(:)=ZTEMX2D(:,J)
  ZWT2(:)=ZTEMY2D(:,J)
! Mai 2000
  IF(LSPVALT)THEN
    WHERE(ZWT1 == XSPVALT)
      ZWT1=ZE36
    ENDWHERE
    WHERE(ZWT2 == XSPVALT)
      ZWT2=ZE36
    ENDWHERE
  ENDIF

  CALL GSLN(1)
  CALL GSLWSC(1.)
  CALL GSTXCI(1)
  CALL GSPLCI(1)
  CALL GSCLIP(0)

!!!!!!JD Avril 2009
              IF(LXYNVARTOP)THEN
!!!!!!JD Avril 2009
! G.TANGUY Juin 2010
    IF(LVARNPHUSER)THEN
      IF(J == 1)THEN
        IF(CVARNPH1 == 'WHITE' .OR. CVARNPH1 == 'white')THEN
          YTITGAL(1)(1:LEN_TRIM(YTITGAL(1)))=' '
        ELSEIF(CVARNPH1 /= ' ')THEN
          YTITGAL(1)(1:LEN_TRIM(YTITGAL(1)))=' '
          YTITGAL(1)=ADJUSTL(CVARNPH1)
          YTITGAL(1)=ADJUSTL(YTITGAL(1))
        ENDIF
      ELSEIF(J == 2)THEN
        IF(CVARNPH2 == 'WHITE' .OR. CVARNPH2 == 'white')THEN
          YTITGAL(2)(1:LEN_TRIM(YTITGAL(2)))=' '
          print *,' NSUPER=2 YTITGAL(2) ',YTITGAL(2)
        ELSEIF(CVARNPH2 /= ' ')THEN
          YTITGAL(2)(1:LEN_TRIM(YTITGAL(2)))=' '
          YTITGAL(2)=CVARNPH2
          YTITGAL(2)=ADJUSTL(YTITGAL(2))
        ENDIF
      ELSEIF(J == 3)THEN
        IF(CVARNPH3 == 'WHITE' .OR. CVARNPH3 == 'white')THEN
          YTITGAL(3)(1:LEN_TRIM(YTITGAL(3)))=' '
        ELSEIF(CVARNPH3 /= ' ')THEN
          YTITGAL(3)(1:LEN_TRIM(YTITGAL(3)))=' '
          YTITGAL(3)=CVARNPH3
          YTITGAL(3)=ADJUSTL(YTITGAL(3))
        ENDIF
      ELSEIF(J == 4)THEN
        IF(CVARNPH4 == 'WHITE' .OR. CVARNPH4 == 'white')THEN
          YTITGAL(4)(1:LEN_TRIM(YTITGAL(4)))=' '
        ELSEIF(CVARNPH4 /= ' ')THEN
          YTITGAL(4)(1:LEN_TRIM(YTITGAL(4)))=' '
          YTITGAL(4)=CVARNPH4
          YTITGAL(4)=ADJUSTL(YTITGAL(4))
        ENDIF
      ELSEIF(J == 5)THEN
        IF(CVARNPH5 == 'WHITE' .OR. CVARNPH5 == 'white')THEN
          YTITGAL(5)(1:LEN_TRIM(YTITGAL(5)))=' '
        ELSEIF(CVARNPH5 /= ' ')THEN
          YTITGAL(5)(1:LEN_TRIM(YTITGAL(5)))=' '
          YTITGAL(5)=CVARNPH5
          YTITGAL(5)=ADJUSTL(YTITGAL(5))
        ENDIF
      ELSEIF(J == 6)THEN
        IF(CVARNPH6 == 'WHITE' .OR. CVARNPH6 == 'white')THEN
          YTITGAL(6)(1:LEN_TRIM(YTITGAL(6)))=' '
        ELSEIF(CVARNPH6 /= ' ')THEN
          YTITGAL(6)(1:LEN_TRIM(YTITGAL(6)))=' '
          YTITGAL(6)=CVARNPH6
          YTITGAL(6)=ADJUSTL(YTITGAL(6))
        ENDIF
      ELSEIF(J == 7)THEN
        IF(CVARNPH7 == 'WHITE' .OR. CVARNPH7 == 'white')THEN
          YTITGAL(7)(1:LEN_TRIM(YTITGAL(7)))=' '
        ELSEIF(CVARNPV7 /= ' ')THEN
          YTITGAL(7)(1:LEN_TRIM(YTITGAL(7)))=' '
          YTITGAL(7)=CVARNPH7
          YTITGAL(7)=ADJUSTL(YTITGAL(7))
        ENDIF
      ELSEIF(J == 8)THEN
        IF(CVARNPH8 == 'WHITE' .OR. CVARNPH8 == 'white')THEN
          YTITGAL(8)(1:LEN_TRIM(YTITGAL(8)))=' '
        ELSEIF(CVARNPV8 /= ' ')THEN
          YTITGAL(8)(1:LEN_TRIM(YTITGAL(8)))=' '
          YTITGAL(8)=CVARNPH8
          YTITGAL(8)=ADJUSTL(YTITGAL(8))
        ENDIF
      ENDIF
    ENDIF
! fin G.TANGUY juin 2010    
  SELECT CASE(CTYPE)

    CASE ('CART','MASK','SPXY')
      IF(LMINUS .OR. LPLUS)THEN
      ELSE
        IF(NHISTORY(KLOOP) == 3)THEN
	  DO JA=1,MAX(1,KLOOP-1)
	    IF(NHISTORY(J) == 1)THEN
! Pour placer le titre au dessus de la + gde fenetre
	      IF(ZZVT /= ZVT)THEN
		ZZT=(ZZVT-ZVT)*(ZWT-ZWB)/(ZVT-ZVB)
                CALL PLCHHQ(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+ZZT+(ZWT+ZZT-ZWB)/38.,YTITGAL(J)(1:LEN_TRIM(YTITGAL(J))),.008,0.,-1.)
	      ELSE
                CALL PLCHHQ(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+(ZWT-ZWB)/38.,YTITGAL(J)(1:LEN_TRIM(YTITGAL(J))),.008,0.,-1.)
	      ENDIF
	      EXIT
	    ENDIF
            CALL PLCHHQ(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+(ZWT-ZWB)/38.,YTITGAL(J)(1:LEN_TRIM(YTITGAL(J))),.008,0.,-1.)
	  ENDDO
	ELSE
          CALL PLCHHQ(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+(ZWT-ZWB)/38.,YTITGAL(J)(1:LEN_TRIM(YTITGAL(J))),.008,0.,-1.)
	ENDIF
      ENDIF
    CASE DEFAULT
  SELECT CASE(IST(J))
    CASE(1:9)
      WRITE(YC1,'(I1)')IST(J)
      CALL PLCHHQ(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+(ZWT-ZWB)/38.,YC1,.008,0.,-1.)
    CASE(10:99)
      WRITE(YC2,'(I2)')IST(J)
      CALL PLCHHQ(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+(ZWT-ZWB)/38.,YC2,.008,0.,-1.)
    CASE(100:999)
      WRITE(YC3,'(I3)')IST(J)
      CALL PLCHHQ(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+(ZWT-ZWB)/38.,YC3,.008,0.,-1.)
    CASE DEFAULT
      print *,' Numero de station IMPREVU ou INVALIDE : ',IST(J)
  END SELECT

  END SELECT
!!!!!!JD Avril 2009
      ENDIF
!!!!!!JD Avril 2009

  IF(LCOLINE)THEN
    CALL GSPLCI(J+1)
    CALL GSTXCI(J+1)
  ELSE
    CALL GSPLCI(1)
    CALL GSTXCI(1)

    SELECT CASE(J)
      CASE(1:4)
        CALL GSLWSC(1.)
      CASE(5:8)
        CALL GSLWSC(2.)
      CASE(9:12)
        CALL GSLWSC(3.)
    END SELECT
    IF(LPHSTYUSER)THEN
    CALL AGSETR('DAS/SE.',1.)
      IF(KLOOP == 1 .OR. J == 1)THEN
        ISTYL=NPHSTY1
      ELSEIF(KLOOP == 2 .OR. J == 2)THEN
        ISTYL=NPHSTY2
      ELSEIF(KLOOP == 3 .OR. J == 3)THEN
        ISTYL=NPHSTY3
      ELSEIF(KLOOP == 4 .OR. J == 4)THEN
        ISTYL=NPHSTY4
      ELSEIF(KLOOP == 5 .OR. J == 5)THEN
        ISTYL=NPHSTY5
      ELSEIF(KLOOP == 6 .OR. J == 6)THEN
        ISTYL=NPHSTY6
      ELSEIF(KLOOP == 7 .OR. J == 7)THEN
        ISTYL=NPHSTY7
      ELSEIF(KLOOP == 8 .OR. J == 8)THEN
        ISTYL=NPHSTY8
      ENDIF
IF(ISTYL == 1)CALL AGSETR('DAS/PA/1.',65535.)
IF(ISTYL == 2)CALL AGSETR('DAS/PA/1.',30583.)
IF(ISTYL == 3)CALL AGSETR('DAS/PA/1.',21845.)
IF(ISTYL == 4)CALL AGSETR('DAS/PA/1.',10023.)
IF(ISTYL == 5)CALL AGSETR('DAS/PA/1.',16191.)
IF(ISTYL == 6)CALL AGSETR('DAS/PA/1.',990.)
IF(ISTYL == 7)CALL AGSETR('DAS/PA/1.',3855.)
IF(ISTYL == 8)CALL AGSETR('DAS/PA/1.',24415.)
IF(ISTYL == 9)CALL AGSETR('DAS/PA/1.',13107.)
IF(ISTYL == 10)CALL AGSETR('DAS/PA/1.',63903.)
    ELSE
    CALL GSLN(MOD(J,4))
    IF(MOD(J,4) == 0)CALL GSLN(4)
    ENDIF

  ENDIF

!!!!!!JD Avril 2009
      IF(LXYSTYLTOP)THEN
!!!!!!JD Avril 2009
  CALL FRSTPT(ZWL+(J-1)*(ZWR-ZWL)/6.,ZWT+ZZT+(ZWT+ZZT-ZWB)/70.)
  CALL VECTOR(ZWL+(J-1)*(ZWR-ZWL)/6.+(ZWR-ZWL)/20.,ZWT+ZZT+(ZWT+ZZT-ZWB)/70.)
  CALL SFLUSH
!!!!!!JD Avril 2009
      ENDIF
!!!!!!JD Avril 2009

  CALL GSCLIP(1)

  DO JI=1,IBRECOUV(J)

    JD=IRECOUV(JI*2-1,J)
    JF=IRECOUV(JI*2,J)

    IF(PTIMED /= PTIMEF)THEN

!             print *,' JD JF AVANT ',JD,JF

      SELECT CASE(CTYPE)
        CASE('DRST','RSPL','RAPL')
          J2=IST(J)  
        CASE DEFAULT
	  J2=1
      END SELECT

      IF(.NOT. LTINCRDIA(J,J2))THEN

	DO JE=1,NBTIMEDIA(J,J2)
		IF(NTIMEDIA(JE,J,J2) >= JD)THEN
		  JD=JE
		  EXIT
		ENDIF
	ENDDO

	DO JE=1,NBTIMEDIA(J,J2)
          IF(NTIMEDIA(JE,J,J2) == JF)THEN
	    JF=JE
	    EXIT
          ELSE IF(NTIMEDIA(JE,J,J2) > JF)THEN
            JF=JE-1
	    EXIT
          ENDIF
	ENDDO

        JF=MIN(JF,NBTIMEDIA(J,J2))
!       print *,' JD JF APRES ',JD,JF

      ELSE

	JJE=0
	DO JE=NTIMEDIA(1,J,J2),NTIMEDIA(2,J,J2),NTIMEDIA(3,J,J2)
          JJE=JJE+1
          IF(JE >= JD)THEN
	    JD=JJE
	    EXIT
          ENDIF
	ENDDO

	JJE=0
	DO JE=NTIMEDIA(1,J,J2),NTIMEDIA(2,J,J2),NTIMEDIA(3,J,J2)
          JJE=JJE+1
          IF(JE == JF)THEN
	    JF=JJE
	    EXIT
          ELSE IF(JE > JF)THEN
            JF=MIN(JF,JJE-1)
            EXIT
          ENDIF
	ENDDO

	JJE=0
	DO JE=NTIMEDIA(1,J,J2),NTIMEDIA(2,J,J2),NTIMEDIA(3,J,J2)
          JJE=JJE+1
        ENDDO
        JF=MIN(JF,JJE)
      ENDIF

    ENDIF
    CALL GQLWSC(IER,ZW)
    IF(LXYDIA .AND. LCONT)THEN
      CALL GSLWSC(3.)
    ELSE IF(LXT .OR. LYT .OR. LXYDIA)THEN
      CALL GSLWSC(2.)
    ELSE
      CALL GSLWSC(2.)
      IF(KLOOP == 1 .OR. J == 1)THEN
        CALL GSLWSC(XLWPH1)
      ELSEIF(KLOOP == 2 .OR. J == 2)THEN
        CALL GSLWSC(XLWPH2)
      ELSEIF(KLOOP == 3 .OR. J == 3)THEN
        CALL GSLWSC(XLWPH3)
      ELSEIF(KLOOP == 4 .OR. J == 4)THEN
        CALL GSLWSC(XLWPH4)
      ELSEIF(KLOOP == 5 .OR. J == 5)THEN
        CALL GSLWSC(XLWPH5)
      ELSEIF(KLOOP == 6 .OR. J == 6)THEN
        CALL GSLWSC(XLWPH6)
      ELSEIF(KLOOP == 7 .OR. J == 7)THEN
        CALL GSLWSC(XLWPH7)
      ELSEIF(KLOOP == 8 .OR. J == 8)THEN
        CALL GSLWSC(XLWPH8)
      ENDIF
    ENDIF
    CALL GQLWSC(IERR,ZLWSC)
    if(nverbia > 0)then
    print *,' ** traxy KLOOP XLWPH ',KLOOP,ZLWSC
    endif
!   IF(CTYPE == 'RSPL')THEN
!   CALL GQCLIP(IER,ICLIP,ZCL)
!   IF(ICLIP == 0)THEN
!     CALL GSCLIP(1)
!   ENDIF
!   ENDIF
    CALL EZXY(ZWT1(JD:JF),ZWT2(JD:JF),JF-JD+1,0)
    CALL SFLUSH
!   IF(CTYPE == 'RSPL')THEN
!     CALL GSCLIP(ICLIP)
!   ENDIF
    CALL GSLWSC(ZW)

  ENDDO
  DEALLOCATE(ZWT1,ZWT2)

ENDDO   ! Fin Do J=1,NSUPERDIA
!!! Avril 2009  JD
  IF(.NOT.LNOLABELX .AND. .NOT.LNOLABELY)THEN
    IF(LAXEXUSER)THEN
      CALL SET(ZVL,ZVR,ZVB,ZVT,XAXEXUSERD,XAXEXUSERF,ZWB,ZWT,ID)
    ENDIF
  ENDIF
!!! Avril 2009  JD

CALL GSLWSC(1.)
CALL GSPLCI(1)
CALL GSTXCI(1)
CALL GSLN(1)
!G.TANGUY juin 2010
  CALL GETSET(ZVL,ZVR,ZVB,ZVT,ZWLL,ZWRR,ZWBB,ZWTT,IDD)
  IF(LFACTAXEX)THEN
    IF(LFACTAXEY)THEN
      CALL SET(ZVL,ZVR,ZVB,ZVT,ZWLL*XFACTAXEX,ZWRR*XFACTAXEX,&
	       ZWBB*XFACTAXEY,ZWTT*XFACTAXEY,IDD)
    ELSE
      CALL SET(ZVL,ZVR,ZVB,ZVT,ZWLL*XFACTAXEX,ZWRR*XFACTAXEX,&
	       ZWBB,ZWTT,IDD)
    ENDIF
  ELSEIF(LFACTAXEY)THEN
      CALL SET(ZVL,ZVR,ZVB,ZVT,ZWLL,ZWRR,&
	       ZWBB*XFACTAXEY,ZWTT*XFACTAXEY,IDD)
  ENDIF
!fin G.TANGUY juin 2010  
!!!PROVI
!go to 10
IF(.NOT.LXYWINCUR)THEN
IF(.NOT.GOK)THEN
  IF(NHISTORY(KLOOP) == 3)THEN
    DO JA=1,MAX(1,KLOOP-1)
    IF(NHISTORY(J) == 1)THEN
!Avril 2002
      IF(LNOLABELX .AND.LNOLABELY)THEN
       CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,0,0,5,0.,0.)
      ELSEIF(LNOLABELX .AND. .NOT.LNOLABELY)THEN
       CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,0,1,5,0.,0.)
      ELSEIF(.NOT.LNOLABELX .AND. LNOLABELY)THEN
       CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,-1,0,5,0.,0.)
      ELSE
       CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,-1,1,5,0.,0.)
      ENDIF
!Avril 2002
      EXIT
    ELSE
!Avril 2002
      IF(LNOLABELX .AND.LNOLABELY)THEN
        CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,0,0,5,0.,0.)
      ELSEIF(LNOLABELX .AND. .NOT.LNOLABELY)THEN
        CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,0,1,5,0.,0.)
      ELSEIF(.NOT.LNOLABELX .AND. LNOLABELY)THEN
        CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,1,0,5,0.,0.)
      ELSE
        CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,1,1,5,0.,0.)
      ENDIF
!Avril 2002
    ENDIF
    ENDDO
  ELSE
!Avril 2002
    IF(LNOLABELX .AND.LNOLABELY)THEN
      CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,0,0,5,0.,0.)
    ELSEIF(LNOLABELX .AND. .NOT.LNOLABELY)THEN
      CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,0,1,5,0.,0.)
    ELSEIF(.NOT.LNOLABELX .AND. LNOLABELY)THEN
      CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,1,0,5,0.,0.)
    ELSE
      CALL GRIDAL(NXYITVXMJ,NXYITVXMN,NXYITVYMJ,NXYITVYMN,1,1,5,0.,0.)
    ENDIF
!Avril 2002
  ENDIF
! CALL GRIDAL(5,1,5,1,1,1,5,0.,0.)
ENDIF
ENDIF
!G.TANGUY juin 2010

IF(LFACTAXEX .OR. LFACTAXEY)THEN
  CALL SET(ZVL,ZVR,ZVB,ZVT,ZWLL,ZWRR,ZWBB,ZWTT,IDD)
ENDIF
! fin G.TANGUY juin 2010
!10 continue
!!!PROVI
! Titres
!
SELECT CASE(CTYPE)
  CASE('CART','MASK','SPXY')
    YCAR(1:LEN(YCAR))=' '
  CASE('SSOL')
  CASE DEFAULT
    YCAR(1:LEN(YCAR))=' '
    YCAR(1:4)=CTYPE
!   YCAR(5:7)=' N.'
!   WRITE(YCAR(8:10),'(I3)')IST(1)
!   ISUIT=11
!   DO J=2,ICOMPT
!     DO JE=1,J-1
!       IF(IST(J) == IST(JE))THEN
!        EXIT
!       ELSE
!  WRITE(YCAR(ISUIT:ISUIT+4),'(I5)')IST(J)
!       ISUIT=ISUIT+5
!       ENDIF
!     ENDDO
!   ENDDO
END SELECT

CALL SET(0.,1.,0.,1.,0.,1.,0.,1.,1)
IF(LFACTIMP)THEN
  CALL FACTIMP
ENDIF
! Titres en X
YTEM(1:LEN(YTEM))=' '
CALL RESOLV_TIT('CTITXL',YTEM)
IF(YTEM /= ' ' .AND. YTEM /= 'DEFAULT')THEN
  CALL RESOLV_TIT('CTITXL',YTEM)
  CALL PLCHHQ(ZVL,ZVB-MIN(ZVB/2.,.05),YTEM,.008,0.,-1.)
! CALL PLCHHQ(ZVL,ZVB/2.,YTEM,.008,0.,-1.)
ENDIF
YTEM(1:LEN(YTEM))=' '
CALL RESOLV_TIT('CTITXM',YTEM)
IF(YTEM /= ' ' .AND. YTEM /= 'DEFAULT')THEN
  CALL RESOLV_TIT('CTITXM',YTEM)
  CALL PLCHHQ((ZVL+ZVR)/2.,ZVB-MIN(ZVB/2.,.05),YTEM(1:LEN_TRIM(YTEM)),.008,0.,0.)
! CALL PLCHHQ((ZVL+ZVR)/2.,ZVB/2.,YTEM(1:LEN_TRIM(YTEM)),.008,0.,0.)
ENDIF
YTEM(1:LEN(YTEM))=' '
IF(.NOT.GOK)THEN
YTEM=ADJUSTL(HTITX)
ENDIF
CALL RESOLV_TIT('CTITXR',YTEM)
IF(YTEM /= ' ' .AND. YTEM /= 'DEFAULT')THEN
  CALL RESOLV_TIT('CTITXR',YTEM)
  IF(NHISTORY(KLOOP) == 3)THEN
    DO J=1,MAX(1,KLOOP-1)
      IF(NHISTORY(J) == 1)THEN
	EXIT
      ENDIF
      CALL PLCHHQ(ZVR-ZVB/2.,ZVB-MIN(ZVB/2.,.05),YTEM,.008,0.,-1.)
    ENDDO
  ELSE
    CALL PLCHHQ(ZVR-ZVB/2.,ZVB-MIN(ZVB/2.,.05),YTEM,.008,0.,-1.)
  ENDIF
! CALL PLCHHQ(ZVR-ZVB/2.,ZVB/2.,YTEM,.008,0.,-1.)
ENDIF
! Titres en Y
YTEM(1:LEN(YTEM))=' '
IF(.NOT.GOK)THEN
YTEM=ADJUSTL(HTITY)
ENDIF
CALL RESOLV_TITY('CTITYT',ZVL,ZVR,ZVB,ZVT,YTEM)
YTEM(1:LEN(YTEM))=' '
CALL RESOLV_TITY('CTITYM',ZVL,ZVR,ZVB,ZVT,YTEM)
YTEM(1:LEN(YTEM))=' '
CALL RESOLV_TITY('CTITYB',ZVL,ZVR,ZVB,ZVT,YTEM)

! TitresTOP
YTEM(1:LEN(YTEM))=' '
CALL RESOLV_TIT('CTITT3',YTEM)
ZXPOSTITT3=.002
ZXYPOSTITT3=.93
IF(XPOSTITT3 /= 0.)THEN
  ZXPOSTITT3=XPOSTITT3
ENDIF
IF(XYPOSTITT3 /= 0.)THEN
ZXYPOSTITT3=XYPOSTITT3
ENDIF

IF(CTITT3 /= ' ')THEN
  IF(XSZTITT3 /= 0.)THEN
    CALL PLCHHQ(ZXPOSTITT3,ZXYPOSTITT3,YTEM,XSZTITT3,0.,-1.)
!   CALL PLCHHQ(0.002,0.93,YTEM,XSZTITT3,0.,-1.)
  ELSE
    CALL PLCHHQ(ZXPOSTITT3,ZXYPOSTITT3,YTEM,.008,0.,-1.)
!   CALL PLCHHQ(0.002,0.93,YTEM,.008,0.,-1.)
  ENDIF
ENDIF
YTEM(1:LEN(YTEM))=' '
CALL RESOLV_TIT('CTITT2',YTEM)
ZXPOSTITT2=.002
ZXYPOSTITT2=.95
IF(XPOSTITT2 /= 0.)THEN
  ZXPOSTITT2=XPOSTITT2
ENDIF
IF(XYPOSTITT2 /= 0.)THEN
ZXYPOSTITT2=XYPOSTITT2
ENDIF
IF(CTITT2 /= ' ')THEN
  IF(XSZTITT2 /= 0.)THEN
    CALL PLCHHQ(ZXPOSTITT2,ZXYPOSTITT2,YTEM,XSZTITT2,0.,-1.)
!   CALL PLCHHQ(0.002,0.95,YTEM,XSZTITT2,0.,-1.)
  ELSE
    CALL PLCHHQ(ZXPOSTITT2,ZXYPOSTITT2,YTEM,.008,0.,-1.)
!   CALL PLCHHQ(0.002,0.95,YTEM,.008,0.,-1.)
  ENDIF
ENDIF
YTEM(1:LEN(YTEM))=' '
YTEM=ADJUSTL(YCAR)
CALL RESOLV_TIT('CTITT1',YTEM)
ZXPOSTITT1=.002
ZXYPOSTITT1=.98
IF(XPOSTITT1 /= 0.)THEN
  ZXPOSTITT1=XPOSTITT1
ENDIF
IF(XYPOSTITT1 /= 0.)THEN
ZXYPOSTITT1=XYPOSTITT1
ENDIF
!IF(CTITT1 /= ' ')THEN
! 230498
IF(YTEM /= ' ' .AND. CTITT1 /= 'DEFAULT')THEN
  IF(XSZTITT1 /= 0.)THEN
    CALL PLCHHQ(ZXPOSTITT1,ZXYPOSTITT1,YTEM,XSZTITT1,0.,-1.)
!   CALL PLCHHQ(0.002,0.98,YTEM,XSZTITT1,0.,-1.)
  ELSE
    CALL PLCHHQ(ZXPOSTITT1,ZXYPOSTITT1,YTEM,.012,0.,-1.)
!   CALL PLCHHQ(0.002,0.98,YTEM,.012,0.,-1.)
  ENDIF
ELSE
  IF(YTEM ==' ')THEN

  IF(LCV .AND. LCH)THEN
  ELSE IF(LCH)THEN
  IF(NIINF /= 0 .AND. NJINF /=0 .AND. NJSUP /= 0 .AND. NISUP /= 0)THEN
    YTEM(1:LEN(YTEM))=' '
    WRITE(YTEM,'(''NIINF='',I4,2X,''NISUP='',I4,2X,''NJINF='',I4,2X,''NJSUP='',I4)')NIINF,NISUP,NJINF,NJSUP
    YTEM=ADJUSTL(YTEM)
    IF(XSZTITT1 /= 0.)THEN
      CALL PLCHHQ(ZXPOSTITT1,ZXYPOSTITT1,YTEM,XSZTITT1,0.,-1.)
!     CALL PLCHHQ(0.002,0.98,YTEM,XSZTITT1,0.,-1.)
    ELSE
      CALL PLCHHQ(ZXPOSTITT1,ZXYPOSTITT1,YTEM,.012,0.,-1.)
!     CALL PLCHHQ(0.002,0.98,YTEM,.012,0.,-1.)
    ENDIF
  ENDIF
  ENDIF

  ENDIF
ENDIF
! TitresBOTTOM
! Titre N3 BOTTOM
YTEM(1:LEN(YTEM))=' '
IF(PTIMED == PTIMEF)THEN
 WRITE(YTEM,'(''Time'',F10.0)')PTIMED
ELSE
 WRITE(YTEM,'(''Time'',F10.0,'' - '',F10.0)')PTIMED,PTIMEF
ENDIF
CALL RESOLV_TIT('CTITB3',YTEM)
ZXPOSTITB3=.002
ZXYPOSTITB3=.05
IF(XPOSTITB3 /= 0.)THEN
  ZXPOSTITB3=XPOSTITB3
ENDIF
IF(XYPOSTITB3 /= 0.)THEN
ZXYPOSTITB3=XYPOSTITB3
ENDIF
!IF(CTITB3 /= ' ')THEN
IF(YTEM /= ' ')THEN
  IF(NHISTORY(KLOOP) == 3)THEN
    DO J=1,MAX(1,KLOOP-1)
      IF(NHISTORY(J) == 1)THEN
	EXIT
      ENDIF
      IF(XSZTITB3 /= 0.)THEN
        CALL PLCHHQ(ZXPOSTITB3,ZXYPOSTITB3,YTEM,XSZTITB3,0.,-1.)
      ELSE
        CALL PLCHHQ(ZXPOSTITB3,ZXYPOSTITB3,YTEM,.008,0.,-1.)
      ENDIF
    ENDDO
  ELSE
    IF(XSZTITB3 /= 0.)THEN
      CALL PLCHHQ(ZXPOSTITB3,ZXYPOSTITB3,YTEM,XSZTITB3,0.,-1.)
!   CALL PLCHHQ(0.002,0.05,YTEM,XSZTITB3,0.,-1.)
    ELSE
      CALL PLCHHQ(ZXPOSTITB3,ZXYPOSTITB3,YTEM,.008,0.,-1.)
!   CALL PLCHHQ(0.002,0.05,YTEM,.008,0.,-1.)
    ENDIF
  ENDIF
ENDIF
! Titre N2 BOTTOM
YTEM(1:LEN(YTEM))=' '
IF(LCH)THEN
  YTEM=ADJUSTL(CLEGEND2)
ENDIF
CALL RESOLV_TIT('CTITB2',YTEM)
ZXPOSTITB2=.002
ZXYPOSTITB2=.025
IF(XPOSTITB2 /= 0.)THEN
  ZXPOSTITB2=XPOSTITB2
ENDIF
IF(XYPOSTITB2 /= 0.)THEN
  ZXYPOSTITB2=XYPOSTITB2
ENDIF
IF(YTEM/= ' ')THEN
  IF(XSZTITB2 /= 0.)THEN
    CALL PLCHHQ(ZXPOSTITB2,ZXYPOSTITB2,YTEM,XSZTITB2,0.,-1.)
!   CALL PLCHHQ(0.002,0.025,YTEM,XSZTITB2,0.,-1.)
  ELSE
    CALL PLCHHQ(ZXPOSTITB2,ZXYPOSTITB2,YTEM,.007,0.,-1.)
!   CALL PLCHHQ(0.002,0.025,YTEM,.007,0.,-1.)
  ENDIF
ENDIF
! Titre N1 BOTTOM
YTEM(1:LEN(YTEM))=' '
IF(LCH)THEN
  YTEM=ADJUSTL(CLEGEND)
ENDIF
CALL RESOLV_TIT('CTITB1',YTEM)
ZXPOSTITB1=.002
ZXYPOSTITB1=.005
IF(XPOSTITB1 /= 0.)THEN
  ZXPOSTITB1=XPOSTITB1
ENDIF
IF(XYPOSTITB1 /= 0.)THEN
  ZXYPOSTITB1=XYPOSTITB1
ENDIF
IF(YTEM /= ' ')THEN
  IF(XSZTITB1 /= 0.)THEN
    CALL PLCHHQ(ZXPOSTITB1,ZXYPOSTITB1,YTEM,XSZTITB1,0.,-1.)
!   CALL PLCHHQ(0.002,0.005,YTEM,XSZTITB1,0.,-1.)
  ELSE
    CALL PLCHHQ(ZXPOSTITB1,ZXYPOSTITB1,YTEM,.007,0.,-1.)
!   CALL PLCHHQ(0.002,0.005,YTEM,.007,0.,-1.)
  ENDIF
ENDIF

DEALLOCATE(ZTEMX2D,ZTEMY2D,ICOMPTSZ,IBRECOUV,IST,IRECOUV,ZTIMD,ZTIMF,YTITGAL)
ICOMPT=0
if(nverbia > 0)then
print *,' Sortie TRAXY'
endif
RETURN
!
!----------------------------------------------------------------------------
!
!*       4.     EXIT
!               ----
!
END SUBROUTINE  TRAXY
