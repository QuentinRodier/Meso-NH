!     ######spl
      MODULE MODI_WRITE_DIACHRO
!     #########################
!
INTERFACE
!
SUBROUTINE WRITE_DIACHRO(HFILEDIA,HLUOUTDIA,HGROUP,HTYPE,KGRID, &
                   PDATIME,PVAR,PTRAJT,HTITRE,HUNITE,HCOMMENT,  &
                   OICP, OJCP, OKCP, KIL, KIH, KJL, KJH, KKL, KKH, &
			       PTRAJX,PTRAJY,PTRAJZ,PMASK)
CHARACTER(LEN=*)              :: HFILEDIA,HLUOUTDIA
CHARACTER(LEN=*)              :: HGROUP, HTYPE
CHARACTER(LEN=*),DIMENSION(:) :: HTITRE, HUNITE, HCOMMENT

INTEGER,DIMENSION(:)  :: KGRID
INTEGER,OPTIONAL      :: KIL, KIH
INTEGER,OPTIONAL      :: KJL, KJH
INTEGER,OPTIONAL      :: KKL, KKH
LOGICAL,OPTIONAL      :: OICP, OJCP, OKCP
REAL,DIMENSION(:,:,:,:,:,:),OPTIONAL  :: PMASK
REAL,DIMENSION(:,:)             :: PDATIME
REAL,DIMENSION(:,:,:,:,:,:)     :: PVAR
REAL,DIMENSION(:,:)             :: PTRAJT
REAL,DIMENSION(:,:,:),OPTIONAL  :: PTRAJX
REAL,DIMENSION(:,:,:),OPTIONAL  :: PTRAJY
REAL,DIMENSION(:,:,:),OPTIONAL  :: PTRAJZ

END SUBROUTINE WRITE_DIACHRO
!
END INTERFACE
!
END MODULE MODI_WRITE_DIACHRO
!     ##################################################################
      SUBROUTINE WRITE_DIACHRO(HFILEDIA,HLUOUTDIA,HGROUP,HTYPE,  &
      KGRID,PDATIME,PVAR,PTRAJT, &
      HTITRE,HUNITE,HCOMMENT,OICP,OJCP,OKCP,KIL,KIH,KJL,KJH,KKL,KKH, &
      PTRAJX,PTRAJY,PTRAJZ,PMASK)
!     ##################################################################
!
!!****  *WRITE_DIACHRO* - Ecriture d'un enregistrement dans un fichier
!!                        diachronique (de nom de base HGROUP)
!!
!!    PURPOSE
!!    -------
!      
!
!!**  METHOD
!!    ------
!!      En fait pour un groupe donne HGROUP, on ecrit systematiquement
!       plusieurs enregistrements :
!       - 1: HGROUP.TYPE          (type d'informations a enregistrer)
!       - 2: HGROUP.DIM           (dimensions de toutes les matrices a 
!                                  enregistrer)
!       - 3: HGROUP.TITRE         (Nom des processus)
!       - 4: HGROUP.UNITE         (Unites pour chaque processus)
!       - 5: HGROUP.COMMENT       (Champ commentaire pour chaque processus)
!       - 6: HGROUP.TRAJT         (Temps)
!       - 7: HGROUP.PROCx         (Champ traite . 1 enr./ 1 processus)
!       - 8: HGROUP.DATIM         (Les differentes dates du modele)
!       et pour certains types d'informations on enregistre egalement
!       des coordonnees (HGROUP.TRAJX, HGROUP.TRAJY, HGROUP.TRAJZ)
!!
!!    EXTERNAL
!!    --------
!!      None
!!
!!    IMPLICIT ARGUMENTS
!!    ------------------
!!      Module
!!
!!    REFERENCE
!!    ---------
!!
!!
!!    AUTHOR
!!    ------
!!      J. Duron    * Laboratoire d'Aerologie *
!!
!!
!!    MODIFICATIONS
!!    -------------
!!      Original       08/01/96
!!      Updated   PM 
!-------------------------------------------------------------------------------
!
!*       0.    DECLARATIONS
!              ------------
!
USE MODI_MENU_DIACHRO
!USE MODD_BUDGET
USE MODI_FMWRIT 

IMPLICIT NONE
!
!*       0.1   Dummy arguments
!              ---------------

CHARACTER(LEN=*)              :: HFILEDIA,HLUOUTDIA
CHARACTER(LEN=*)              :: HGROUP, HTYPE
CHARACTER(LEN=*),DIMENSION(:) :: HTITRE, HUNITE, HCOMMENT

INTEGER,DIMENSION(:)  :: KGRID
INTEGER,OPTIONAL      :: KIL, KIH
INTEGER,OPTIONAL      :: KJL, KJH
INTEGER,OPTIONAL      :: KKL, KKH
LOGICAL,OPTIONAL      :: OICP, OJCP, OKCP
REAL,DIMENSION(:,:,:,:,:,:),OPTIONAL  :: PMASK
REAL,DIMENSION(:,:,:,:,:,:)     :: PVAR
REAL,DIMENSION(:,:)             :: PDATIME
REAL,DIMENSION(:,:)             :: PTRAJT
REAL,DIMENSION(:,:,:),OPTIONAL  :: PTRAJX
REAL,DIMENSION(:,:,:),OPTIONAL  :: PTRAJY
REAL,DIMENSION(:,:,:),OPTIONAL  :: PTRAJZ

!
!*       0.1   Local variables
!              ---------------

!
CHARACTER(LEN=16) :: YRECFM
CHARACTER(LEN=LEN(HFILEDIA)+4) :: YFILEDIA
CHARACTER(LEN=20) :: YCOMMENT
CHARACTER(LEN=2)  :: YJ
INTEGER   ::   ILENG, ILENCH, ILENTITRE, ILENUNITE, ILENCOMMENT, ILE, IRESP
INTEGER   ::   ILUOUTDIA, IRESPDIA,INPRARDIA,IFTYPEDIA,IVERBDIA,ININARDIA
INTEGER   ::   II, IJ, IK, IT, IN, IP, INUM, J, JJ, JM
INTEGER   ::   INTRAJT, IKTRAJX, IKTRAJY, IKTRAJZ
INTEGER   ::   ITTRAJX, ITTRAJY, ITTRAJZ
INTEGER   ::   INTRAJX, INTRAJY, INTRAJZ
INTEGER   ::   IIMASK, IJMASK, IKMASK, ITMASK, INMASK, IPMASK
INTEGER   ::   ICOMPX, ICOMPY, ICOMPZ
INTEGER,DIMENSION(:),ALLOCATABLE :: ITABCHAR
!------------------------------------------------------------------------------
!
YCOMMENT=' '
ILENCH = LEN(YCOMMENT)

II = SIZE(PVAR,1) ; IT = SIZE(PVAR,4)
IJ = SIZE(PVAR,2) ; IN = SIZE(PVAR,5)
IK = SIZE(PVAR,3) ; IP = SIZE(PVAR,6)

INTRAJT=SIZE(PTRAJT,2)

IKTRAJX=0; IKTRAJY=0; IKTRAJZ=0
ITTRAJX=0; ITTRAJY=0; ITTRAJZ=0
INTRAJX=0; INTRAJY=0; INTRAJZ=0
IF(PRESENT(PTRAJX))THEN
  IKTRAJX=SIZE(PTRAJX,1)
  ITTRAJX=SIZE(PTRAJX,2)
  INTRAJX=SIZE(PTRAJX,3)
ENDIF
IF(PRESENT(PTRAJY))THEN
  IKTRAJY=SIZE(PTRAJY,1)
  ITTRAJY=SIZE(PTRAJY,2)
  INTRAJY=SIZE(PTRAJY,3)
ENDIF
IF(PRESENT(PTRAJZ))THEN
  IKTRAJZ=SIZE(PTRAJZ,1)
  ITTRAJZ=SIZE(PTRAJZ,2)
  INTRAJZ=SIZE(PTRAJZ,3)
ENDIF

IIMASK=0; IJMASK=0; IKMASK=0; ITMASK=0; INMASK=0; IPMASK=0
IF(PRESENT(PMASK))THEN
  IIMASK=SIZE(PMASK,1)
  IJMASK=SIZE(PMASK,2)
  IKMASK=SIZE(PMASK,3)
  ITMASK=SIZE(PMASK,4)
  INMASK=SIZE(PMASK,5)
  IPMASK=SIZE(PMASK,6)
ENDIF

ILENTITRE = LEN(HTITRE)
ILENUNITE = LEN(HUNITE)
ILENCOMMENT = LEN(HCOMMENT)

ICOMPX=0; ICOMPY=0; ICOMPZ=0
IF(PRESENT(OICP))THEN
IF(OICP)THEN
  ICOMPX=1
ENDIF
IF(OJCP)THEN
  ICOMPY=1
ENDIF
IF(OKCP)THEN
  ICOMPZ=1
ENDIF
ENDIF
CALL FMLOOK(HLUOUTDIA,HLUOUTDIA,ILUOUTDIA,IRESP)
WRITE(ILUOUTDIA,*)' WRITE_DIACHRO IRESP ',IRESP
IF(IRESP == -54)THEN
  CALL FMATTR(HLUOUTDIA,HLUOUTDIA,ILUOUTDIA,IRESPDIA)
  OPEN(UNIT=ILUOUTDIA,FILE=HLUOUTDIA)
  IFTYPEDIA = 0; IVERBDIA = 5
ENDIF
YFILEDIA=ADJUSTL(ADJUSTR(HFILEDIA)//'.lfi')
CALL FMLOOK(YFILEDIA,HLUOUTDIA,INUM,IRESPDIA)
WRITE(ILUOUTDIA,*)' WRITE_DIACHRO IRESPDIA ',IRESPDIA
IF(IRESPDIA == -54)THEN
! Modif demandee par Nicole Asencio. 28/9/98
  IFTYPEDIA=2
  CALL FMOPEN(HFILEDIA,'NEW',HLUOUTDIA,INPRARDIA,IFTYPEDIA,IVERBDIA, &
  ININARDIA,IRESPDIA)
END IF

!
! 1er enregistrement TYPE
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TYPE')
ILENG = LEN(HTYPE)
ALLOCATE(ITABCHAR(ILENG))
DO J = 1,ILENG
  ITABCHAR(J) = ICHAR(HTYPE(J:J))
ENDDO
!print *,SIZE(ITABCHAR),'  ITABCHAR ',ITABCHAR,' KGRID ',KGRID,HLUOUTDIA,HFILEDIA
CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
WRITE(ILUOUTDIA,*)' 1er ENREGISTREMENT OK'
DEALLOCATE(ITABCHAR)
!
! 2eme  enregistrement DIMENSIONS des MATRICES et LONGUEUR des TABLEAUX de CARACTERES et FLAGS de COMPRESSION sur les DIFFERENTS AXES
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.DIM')
SELECT CASE(HTYPE)
  CASE('CART','MASK','SPXY')
    ILENG = 34
    ALLOCATE(ITABCHAR(ILENG))
    ITABCHAR(1)=ILENTITRE; ITABCHAR(2)=ILENUNITE
    ITABCHAR(3)=ILENCOMMENT; ITABCHAR(4)=II
    ITABCHAR(5)=IJ; ITABCHAR(6)=IK
    ITABCHAR(7)=IT; ITABCHAR(8)=IN
    ITABCHAR(9)=IP; ITABCHAR(10)=KIL
    ITABCHAR(11)=KJL; ITABCHAR(12)=KKL
    ITABCHAR(13)=KIH; ITABCHAR(14)=KJH
    ITABCHAR(15)=KKH; ITABCHAR(16)=ICOMPX
    ITABCHAR(17)=ICOMPY; ITABCHAR(18)=ICOMPZ
    IF(HTYPE == 'MASK')THEN
!     ITABCHAR(10)=1; ITABCHAR(11)=1
!     ITABCHAR(13)=1; ITABCHAR(14)=1
      ITABCHAR(16)=1; ITABCHAR(17)=1
    ENDIF
    ITABCHAR(19)=INTRAJT; ITABCHAR(20)=IKTRAJX
    ITABCHAR(21)=IKTRAJY; ITABCHAR(22)=IKTRAJZ
    ITABCHAR(23)=ITTRAJX; ITABCHAR(24)=ITTRAJY
    ITABCHAR(25)=ITTRAJZ; ITABCHAR(26)=INTRAJX
    ITABCHAR(27)=INTRAJY; ITABCHAR(28)=INTRAJZ
    ITABCHAR(29)=IIMASK; ITABCHAR(30)=IJMASK
    ITABCHAR(31)=IKMASK; ITABCHAR(32)=ITMASK
    ITABCHAR(33)=INMASK; ITABCHAR(34)=IPMASK
    CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,ITABCHAR, &
    KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
    WRITE(ILUOUTDIA,*)' ILENTITRE,ILENUNITE,ILENCOMMENT ',ILENTITRE,ILENUNITE,ILENCOMMENT
    DEALLOCATE(ITABCHAR)
  CASE DEFAULT
    ILENG = 25 
    ALLOCATE(ITABCHAR(ILENG))
    ITABCHAR(1)=ILENTITRE; ITABCHAR(2)=ILENUNITE
    ITABCHAR(3)=ILENCOMMENT; ITABCHAR(4)=II
    ITABCHAR(5)=IJ; ITABCHAR(6)=IK
    ITABCHAR(7)=IT; ITABCHAR(8)=IN
    ITABCHAR(9)=IP
    ITABCHAR(10)=INTRAJT; ITABCHAR(11)=IKTRAJX
    ITABCHAR(12)=IKTRAJY; ITABCHAR(13)=IKTRAJZ
    ITABCHAR(14)=ITTRAJX; ITABCHAR(15)=ITTRAJY
    ITABCHAR(16)=ITTRAJZ; ITABCHAR(17)=INTRAJX
    ITABCHAR(18)=INTRAJY; ITABCHAR(19)=INTRAJZ
    ITABCHAR(20)=IIMASK; ITABCHAR(21)=IJMASK
    ITABCHAR(22)=IKMASK; ITABCHAR(23)=ITMASK
    ITABCHAR(24)=INMASK; ITABCHAR(25)=IPMASK
!   CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,ILENTITRE,ILENUNITE, &
!   ILENCOMMENT,II,IJ,IK,IT,IN,IP,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
    CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,ITABCHAR, &
    KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
    DEALLOCATE(ITABCHAR)
END SELECT
WRITE(ILUOUTDIA,*)' 2eme ENREGISTREMENT OK'
!
! 3eme enregistrement TITRE
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TITRE')
ILE = LEN(HTITRE)
ILENG = ILE*IP
ALLOCATE(ITABCHAR(ILENG))
DO JJ = 1,IP
DO J = 1,ILE
  ITABCHAR(ILE*(JJ-1)+J) = ICHAR(HTITRE(JJ)(J:J))
ENDDO
WRITE(ILUOUTDIA,*)HTITRE(JJ)
ENDDO
CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
WRITE(ILUOUTDIA,*)' 3eme ENREGISTREMENT OK'
DEALLOCATE(ITABCHAR)
!
! 4eme enregistrement UNITE
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.UNITE')
ILE = LEN(HUNITE)
ILENG = ILE*IP
ALLOCATE(ITABCHAR(ILENG))
DO JJ = 1,IP
DO J = 1,ILE
  ITABCHAR(ILE*(JJ-1)+J) = ICHAR(HUNITE(JJ)(J:J))
ENDDO
WRITE(ILUOUTDIA,*)HUNITE(JJ)
ENDDO
CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
WRITE(ILUOUTDIA,*)' 4eme ENREGISTREMENT OK'
DEALLOCATE(ITABCHAR)
!
! 5eme enregistrement COMMENT
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.COMMENT')
ILE = LEN(HCOMMENT)
ILENG = ILE*IP
ALLOCATE(ITABCHAR(ILENG))
DO JJ = 1,IP
DO J = 1,ILE
  ITABCHAR(ILE*(JJ-1)+J) = ICHAR(HCOMMENT(JJ)(J:J))
ENDDO
WRITE(ILUOUTDIA,*)HCOMMENT(JJ)
ENDDO
CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
ITABCHAR,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
WRITE(ILUOUTDIA,*)' 5eme ENREGISTREMENT OK'
DEALLOCATE(ITABCHAR)
!
! 6eme enregistrement PVAR
!
! Dans la mesure ou cette matrice risque d'etre tres volumineuse, on ecrira un 
! enregistrement par processus
DO J = 1,IP
YJ = '  '
IF(J < 10)WRITE(YJ,'(I1)')J ; YJ = ADJUSTL(YJ)
IF(J >= 10 .AND. J < 100)WRITE(YJ,'(I2)')J
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.PROC'//YJ)
ILENG = II*IJ*IK*IT*IN
CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
            PVAR(:,:,:,:,:,J),KGRID(J),ILENCH,YCOMMENT,IRESPDIA)
WRITE(ILUOUTDIA,*)' 6eme ENREGISTREMENT OK'
ENDDO
!
! 7eme enregistrement TRAJT
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJT')
ILENG = IT*INTRAJT
CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
PTRAJT,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
!
! Dans certains cas
!
!
! 8eme enregistrement TRAJX
!
IF(PRESENT(PTRAJX))THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJX')
  ILENG = IKTRAJX*ITTRAJX*INTRAJX
  CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  PTRAJX,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
ENDIF
!
!                        ou
!
IF(PRESENT(PMASK))THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.MASK')
  ILENG = IIMASK*IJMASK*IKMASK*ITMASK*INMASK*IPMASK
  CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  PMASK,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
ENDIF
!
! 9eme enregistrement TRAJY
!
IF(PRESENT(PTRAJY))THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJY')
  ILENG = IKTRAJY*ITTRAJY*INTRAJY
  CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  PTRAJY,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
ENDIF
!
! 10eme enregistrement TRAJZ
!
IF(PRESENT(PTRAJZ))THEN
  YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.TRAJZ')
  ILENG = IKTRAJZ*ITTRAJZ*INTRAJZ
  CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
  PTRAJZ,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
ENDIF
!
! 11eme enregistrement PDATIME
!
YRECFM = ADJUSTL(ADJUSTR(HGROUP)//'.DATIM')
ILENG=16*IT
CALL FMWRIT(HFILEDIA,YRECFM,HLUOUTDIA,ILENG,  &
PDATIME,KGRID(1),ILENCH,YCOMMENT,IRESPDIA)
!
CALL MENU_DIACHRO(HFILEDIA,HLUOUTDIA,HGROUP)
!-----------------------------------------------------------------------------
!
!*       2.       EXITS
!                 -----
! 
RETURN
END SUBROUTINE WRITE_DIACHRO
