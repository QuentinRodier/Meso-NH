!MNH_LIC Copyright 2000-2023 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
!     ############################
      MODULE MODD_AIRCRAFT_BALLOON
!     ############################
!
!!****  *MODD_AIRCRAFT_BALLOON* - declaration of balloons
!!
!!    PURPOSE
!!    -------
!       The purpose of this declarative module is to define
!      the different balloons types.
!
!!
!!**  IMPLICIT ARGUMENTS
!!    ------------------
!!      NONE 
!!
!!    REFERENCE
!!    --------- 
!!
!!    AUTHOR
!!    ------
!! P. Jabouille   *Meteo France*
!!
!!    MODIFICATIONS
!!    -------------
!!      Original    15/05/00
!!              Apr,19, 2001 (G.Jaubert) add CVBALL type
!!              March, 2013 : O.Caumont, C.Lac : add vertical profiles
!!              Oct,2016 : G.DELAUTIER LIMA
!  P. Wautelet 08/02/2019: add missing NULL association for pointers
!  P. Wautelet 13/09/2019: budget: simplify and modernize date/time management
!  P. Wautelet    06/2022: reorganize flyers
!-------------------------------------------------------------------------------
!
!*       0.   DECLARATIONS
!             ------------
!
!
use modd_parameters,    only: NNEGUNDEF, XNEGUNDEF, XUNDEF
use modd_sensor,        only: tsensor, tsensortime
use modd_type_date,     only: date_time

USE MODE_DATETIME,      ONLY: TPREFERENCE_DATE

implicit none

save

private :: DATA_ARRAYS_ALLOCATE_FLYER, DATA_ARRAYS_DEALLOCATE_FLYER


INTEGER, PARAMETER :: NCRASH_NO        = 0 ! Not crashed
INTEGER, PARAMETER :: NCRASH_OUT_HORIZ = 1 ! Flyer is outside of horizontal domain
INTEGER, PARAMETER :: NCRASH_OUT_LOW   = 2 ! Flyer crashed on ground (or sea!)
INTEGER, PARAMETER :: NCRASH_OUT_HIGH  = 3 ! Flyer is too high (outside of domain)

INTEGER, PARAMETER :: NFLYER_DEFAULT_RANK = 1

INTEGER, PRIVATE, PARAMETER :: NMODEL_FIX = 1
INTEGER, PRIVATE, PARAMETER :: NMODEL_MOB = 2

LOGICAL :: LFLYER = .FALSE. ! flag to use aircraft/balloons

! ############################################
TYPE, EXTENDS(TSENSOR), ABSTRACT :: TFLYERDATA
! ############################################
  !
  !* general information
  !
  CHARACTER(LEN=3) :: CMODEL = 'FIX' ! type of model used for each balloon/aircraft
                                     ! 'FIX' : NMODEL used during the run
                                     ! 'MOB' : change od model depends of the
                                     !         balloon/aircraft location
  INTEGER          :: NMODEL = 0 ! model number for each balloon/aircraft (may change if CMODEL='MOB')
  TYPE(DATE_TIME)   :: TLAUNCH = TPREFERENCE_DATE ! launch/takeoff date and time
  LOGICAL           :: LCRASH = .FALSE. ! occurence of crash
  INTEGER           :: NCRASH = NCRASH_NO
  LOGICAL           :: LFLY   = .FALSE. ! occurence of flying
  !
  !* storage monitoring
  !
  LOGICAL           :: LSTORE = .FALSE. ! Do we have to store data now
  TYPE(TSENSORTIME) :: TFLYER_TIME      ! Time management for flyer
  !
  INTEGER :: NRANK_CUR = NFLYER_DEFAULT_RANK ! Rank of the process where the flyer is
  !
  !* data records
  !
  INTEGER, DIMENSION(:),  ALLOCATABLE :: NMODELHIST ! List of models where data has been computed
  REAL, DIMENSION(:),     ALLOCATABLE :: XX         ! X(n)
  REAL, DIMENSION(:),     ALLOCATABLE :: XY         ! Y(n)
  REAL, DIMENSION(:),     ALLOCATABLE :: XZ         ! Z(n)
  REAL, DIMENSION(:),     ALLOCATABLE :: XLAT       ! latitude (n)
  REAL, DIMENSION(:),     ALLOCATABLE :: XLON       ! longitude(n)
  REAL, DIMENSION(:),     ALLOCATABLE :: XTKE_DISS  ! tke dissipation rate
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XRTZ       ! tot hydrometeor mixing ratio
  REAL, DIMENSION(:,:,:), ALLOCATABLE :: XRZ        ! water vapour mixing ratio
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XFFZ       ! horizontal wind
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XWZ        ! vertical profile of vertical velocity
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XZZ        ! vertical profile of mass point altitude (above sea)
  REAL, DIMENSION(:),     ALLOCATABLE :: XZS        ! zs(n)
  !
  REAL, DIMENSION(:),     ALLOCATABLE :: XTHW_FLUX  ! thw_flux(n)
  REAL, DIMENSION(:),     ALLOCATABLE :: XRCW_FLUX  ! rcw_flux(n)
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XSVW_FLUX  ! psw_flux(n)

  CONTAINS
    ! Remark: DATA_ARRAYS_(DE)ALLOCATE_FLYER do not point to DATA_ARRAYS_(DE)ALLOCATE to allow other dummy arguments if needed
    PROCEDURE                  :: BUFFER_PACK   => BUFFER_PACK_FLYER
    PROCEDURE                  :: BUFFER_UNPACK => BUFFER_UNPACK_FLYER
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_ALLOCATE_FLYER
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_DEALLOCATE_FLYER
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_PACK_FLYER
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_UNPACK_FLYER
END TYPE TFLYERDATA

! ##########################################
TYPE, EXTENDS( TFLYERDATA ) :: TAIRCRAFTDATA
! ##########################################
  LOGICAL :: LTOOKOFF = .FALSE. ! Set to true once the aircraft takes off
  !
  !* aircraft flight definition
  !
  INTEGER :: NPOS     = 0  ! number of aircraft positions (segment extremities)
  INTEGER :: NPOSCUR  = 1  ! current flight segment number
  REAL, DIMENSION(:), ALLOCATABLE :: XPOSLAT  ! latitude of flight segment extremities  (LEG+1)
  REAL, DIMENSION(:), ALLOCATABLE :: XPOSLON  ! longitude of flight segment extremities (LEG+1)
  REAL, DIMENSION(:), ALLOCATABLE :: XPOSX    ! X of flight segment extremities         (LEG+1)
  REAL, DIMENSION(:), ALLOCATABLE :: XPOSY    ! Y of flight segment extremities         (LEG+1)
  REAL, DIMENSION(:), ALLOCATABLE :: XPOSP    ! pressure of flight segment extremities  (LEG+1)
  REAL, DIMENSION(:), ALLOCATABLE :: XPOSZ    ! altitude of flight segment extremities  (LEG+1)
  REAL, DIMENSION(:), ALLOCATABLE :: XPOSTIME ! time since launch (corresponding to flight segments extremities (LEG+1)
  TYPE(DATE_TIME) :: TLAND =  TPREFERENCE_DATE    ! landing / end of flight date and time
  !
  !* aircraft altitude type definition
  !
  LOGICAL :: LALTDEF = .FALSE.  ! TRUE == altitude given in pressure
  REAL    :: XP_CUR = XNEGUNDEF ! current p (only if LALTDEF = F)

  CONTAINS
    PROCEDURE                  :: DATA_ARRAYS_ALLOCATE   => DATA_ARRAYS_ALLOCATE_AIRCRAFT
    PROCEDURE                  :: DATA_ARRAYS_DEALLOCATE => DATA_ARRAYS_DEALLOCATE_AIRCRAFT
    PROCEDURE                  :: BUFFER_PACK   => BUFFER_PACK_AIRCRAFT
    PROCEDURE                  :: BUFFER_UNPACK => BUFFER_UNPACK_AIRCRAFT
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_ALLOCATE_AIRCRAFT
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_DEALLOCATE_AIRCRAFT
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_PACK_AIRCRAFT
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_UNPACK_AIRCRAFT
END TYPE TAIRCRAFTDATA

! #########################################
TYPE, EXTENDS( TFLYERDATA ) :: TBALLOONDATA
! #########################################
  LOGICAL :: LPOSITION_INIT = .FALSE. ! True if initial position has been computed
  !
  !* balloon dynamical characteristics
  !
  REAL :: XLATLAUNCH = XUNDEF ! latitude of launch
  REAL :: XLONLAUNCH = XUNDEF ! lontitude of launch
  REAL :: XXLAUNCH   = XUNDEF ! X coordinate of launch
  REAL :: XYLAUNCH   = XUNDEF ! Y coordinate of launch
  REAL :: XALTLAUNCH = XNEGUNDEF ! altitude of launch (if 'RADIOS' or 'ISODEN' or 'CVBALL')
  REAL :: XWASCENT   = XNEGUNDEF ! ascent vertical speed, m/s (constant if 'RADIOS' or variable if 'CVBALL')
  REAL :: XRHO       = XNEGUNDEF ! density of launch (if 'ISODEN')
  REAL :: XPRES      = XNEGUNDEF ! pressure of launch (if 'ISODEN' or 'CVBALL')
  REAL :: XDIAMETER  = XNEGUNDEF ! apparent diameter of the balloon (m) (if 'CVBALL')
  REAL :: XAERODRAG  = XNEGUNDEF ! aerodynamic drag coefficient of the balloon (if 'CVBALL')
  REAL :: XINDDRAG   = XNEGUNDEF ! induced drag coefficient (i.e. air shifted by the balloon) (if 'CVBALL')
  REAL :: XVOLUME    = XNEGUNDEF ! volume of the balloon (m3) (if 'CVBALL')
  REAL :: XMASS      = XNEGUNDEF ! mass of the balloon (kg) (if 'CVBALL')

  TYPE(DATE_TIME) :: TPOS_CUR = TPREFERENCE_DATE ! Time corresponding to the current position (XX_CUR, XY_CUR...)

  CONTAINS
    PROCEDURE                  :: DATA_ARRAYS_ALLOCATE   => DATA_ARRAYS_ALLOCATE_BALLOON
    PROCEDURE                  :: DATA_ARRAYS_DEALLOCATE => DATA_ARRAYS_DEALLOCATE_BALLOON
    PROCEDURE                  :: BUFFER_PACK   => BUFFER_PACK_BALLOON
    PROCEDURE                  :: BUFFER_UNPACK => BUFFER_UNPACK_BALLOON
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_ALLOCATE_BALLOON
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_DEALLOCATE_BALLOON
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_PACK_BALLOON
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_UNPACK_BALLOON
END TYPE TBALLOONDATA

INTEGER :: NAIRCRAFTS = 0 ! Total number of aircrafts
INTEGER :: NBALLOONS  = 0 ! Total number of balloons

TYPE TAIRCRAFT_PTR
  TYPE(TAIRCRAFTDATA), POINTER :: TAIRCRAFT => NULL()
END TYPE TAIRCRAFT_PTR

TYPE TBALLOON_PTR
  TYPE(TBALLOONDATA), POINTER :: TBALLOON => NULL()
END TYPE TBALLOON_PTR

TYPE(TAIRCRAFT_PTR), DIMENSION(:), ALLOCATABLE :: TAIRCRAFTS ! characteristics and records of the aircrafts

TYPE(TBALLOON_PTR),  DIMENSION(:), ALLOCATABLE :: TBALLOONS  ! characteristics and records of the balloons

INTEGER, DIMENSION(:), ALLOCATABLE :: NRANKCUR_AIRCRAFT ! Array to store the rank of the process where a given aircraft is present
INTEGER, DIMENSION(:), ALLOCATABLE :: NRANKNXT_AIRCRAFT ! Array to store the rank of the process where a given aircraft is going

INTEGER, DIMENSION(:), ALLOCATABLE :: NRANKCUR_BALLOON  ! Array to store the rank of the process where a given ballon is present
INTEGER, DIMENSION(:), ALLOCATABLE :: NRANKNXT_BALLOON  ! Array to store the rank of the process where a given ballon is going


CONTAINS
! #######################################################
SUBROUTINE DATA_ARRAYS_ALLOCATE_FLYER( TPSENSOR, KSTORE )
! #######################################################

  USE MODD_CONF_n,           ONLY: NRR
  USE MODD_DIM_n,            ONLY: NKMAX
  USE MODD_DYN,              ONLY: XSEGLEN
  USE MODD_DYN_n,            ONLY: DYN_MODEL
  USE MODD_NSV,              ONLY: NSV
  USE MODD_PARAMETERS,       ONLY: JPVEXT, NNEGUNDEF, XUNDEF
  USE MODD_PARAM_n,          ONLY: CCLOUD
  USE MODD_SURF_PAR,         ONLY: XUNDEF_SFX => XUNDEF

  USE MODE_MSG


  CLASS(TFLYERDATA), INTENT(INOUT) :: TPSENSOR
  INTEGER, OPTIONAL, INTENT(IN)    :: KSTORE

  INTEGER :: IKU      ! number of vertical levels
  INTEGER :: ISTORE   ! number of storage instants
  INTEGER :: IVARSIZE ! allocated size per store

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_allocate_flyer', 'flyer: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  IKU = NKMAX + 2 * JPVEXT
  IVARSIZE = 0

  IF ( PRESENT( KSTORE ) ) THEN
    ISTORE = KSTORE
  ELSE
    ISTORE = NINT ( ( XSEGLEN - DYN_MODEL(1)%XTSTEP ) / TPSENSOR%TFLYER_TIME%XTSTEP ) + 1
  END IF

  CALL TPSENSOR%Data_arrays_allocate_sensor( .TRUE., KLEVELS = 1, KSTORE = ISTORE )

  ALLOCATE( TPSENSOR%TFLYER_TIME%TPDATES(ISTORE) )
  ALLOCATE( TPSENSOR%NMODELHIST(ISTORE) )
  ALLOCATE( TPSENSOR%XX   (ISTORE) )
  ALLOCATE( TPSENSOR%XY   (ISTORE) )
  ALLOCATE( TPSENSOR%XZ   (ISTORE) )
  ALLOCATE( TPSENSOR%XLON (ISTORE) )
  ALLOCATE( TPSENSOR%XLAT (ISTORE) )
  IVARSIZE = IVARSIZE + 7

  ALLOCATE( TPSENSOR%XRTZ (IKU, ISTORE) )
  ALLOCATE( TPSENSOR%XRZ  (IKU, ISTORE, NRR) )
  ALLOCATE( TPSENSOR%XFFZ (IKU, ISTORE) )
  IVARSIZE = IVARSIZE + IKU * ( 2 + NRR )

  ALLOCATE( TPSENSOR%XWZ       (IKU, ISTORE) )
  ALLOCATE( TPSENSOR%XZZ       (IKU, ISTORE) )
  ALLOCATE( TPSENSOR%XTKE_DISS(ISTORE) )
  ALLOCATE( TPSENSOR%XZS      (ISTORE) )
  IVARSIZE = IVARSIZE + IKU * 2 + 2

  ALLOCATE( TPSENSOR%XTHW_FLUX(ISTORE) )
  ALLOCATE( TPSENSOR%XRCW_FLUX(ISTORE) )
  ALLOCATE( TPSENSOR%XSVW_FLUX(ISTORE, NSV) )
  IVARSIZE = IVARSIZE + 2 + NSV

  TPSENSOR%NBUFFER_FIXSIZE = TPSENSOR%NBUFFER_FIXSIZE + 9 + 1
  TPSENSOR%NBUFFER_VARSIZE = TPSENSOR%NBUFFER_VARSIZE + IVARSIZE

  TPSENSOR%NMODELHIST = NNEGUNDEF
  TPSENSOR%XX    = XUNDEF
  TPSENSOR%XY    = XUNDEF
  TPSENSOR%XZ    = XUNDEF
  TPSENSOR%XLON  = XUNDEF
  TPSENSOR%XLAT  = XUNDEF
  TPSENSOR%XRTZ  = XUNDEF
  TPSENSOR%XRZ   = XUNDEF
  TPSENSOR%XFFZ  = XUNDEF
  TPSENSOR%XWZ        = XUNDEF
  TPSENSOR%XZZ        = XUNDEF
  TPSENSOR%XTKE_DISS  = XUNDEF
  TPSENSOR%XZS        = XUNDEF

  TPSENSOR%XTHW_FLUX = XUNDEF
  TPSENSOR%XRCW_FLUX = XUNDEF
  TPSENSOR%XSVW_FLUX = XUNDEF

END SUBROUTINE DATA_ARRAYS_ALLOCATE_FLYER

! #################################################
SUBROUTINE DATA_ARRAYS_DEALLOCATE_FLYER( TPSENSOR )
! #################################################

  USE MODE_MSG

  CLASS(TFLYERDATA), INTENT(INOUT) :: TPSENSOR

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_deallocate_flyer', 'flyer: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  CALL TPSENSOR%Data_arrays_deallocate_sensor()

  DEALLOCATE( TPSENSOR%TFLYER_TIME%TPDATES )
  DEALLOCATE( TPSENSOR%NMODELHIST )
  DEALLOCATE( TPSENSOR%XX         )
  DEALLOCATE( TPSENSOR%XY         )
  DEALLOCATE( TPSENSOR%XZ         )
  DEALLOCATE( TPSENSOR%XLON       )
  DEALLOCATE( TPSENSOR%XLAT       )
  DEALLOCATE( TPSENSOR%XRTZ       )
  DEALLOCATE( TPSENSOR%XRZ        )
  DEALLOCATE( TPSENSOR%XFFZ       )
  DEALLOCATE( TPSENSOR%XWZ        )
  DEALLOCATE( TPSENSOR%XZZ        )
  DEALLOCATE( TPSENSOR%XTKE_DISS  )
  DEALLOCATE( TPSENSOR%XZS        )

  DEALLOCATE( TPSENSOR%XTHW_FLUX )
  DEALLOCATE( TPSENSOR%XRCW_FLUX )
  DEALLOCATE( TPSENSOR%XSVW_FLUX )

  SELECT TYPE( TPSENSOR )
    CLASS IS ( TAIRCRAFTDATA )
      DEALLOCATE( TPSENSOR%XPOSLAT  )
      DEALLOCATE( TPSENSOR%XPOSLON  )
      DEALLOCATE( TPSENSOR%XPOSX    )
      DEALLOCATE( TPSENSOR%XPOSY    )
      IF ( TPSENSOR%LALTDEF ) THEN
        DEALLOCATE( TPSENSOR%XPOSP  )
      ELSE
        DEALLOCATE( TPSENSOR%XPOSZ  )
      END IF
      DEALLOCATE( TPSENSOR%XPOSTIME )
  END SELECT

END SUBROUTINE DATA_ARRAYS_DEALLOCATE_FLYER


! ##########################################################
SUBROUTINE DATA_ARRAYS_ALLOCATE_AIRCRAFT( TPSENSOR, KSTORE )
! ##########################################################

  USE MODE_MSG

  CLASS(TAIRCRAFTDATA), INTENT(INOUT) :: TPSENSOR
  INTEGER, OPTIONAL, INTENT(IN)    :: KSTORE

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_allocate_aircraft', 'aircraft: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  CALL DATA_ARRAYS_ALLOCATE_FLYER( TPSENSOR, KSTORE )

  TPSENSOR%NBUFFER_FIXSIZE = TPSENSOR%NBUFFER_FIXSIZE + 6 + TPSENSOR%NPOS * 6

END SUBROUTINE DATA_ARRAYS_ALLOCATE_AIRCRAFT


! ####################################################
SUBROUTINE DATA_ARRAYS_DEALLOCATE_AIRCRAFT( TPSENSOR )
! ####################################################

  USE MODE_MSG

  CLASS(TAIRCRAFTDATA), INTENT(INOUT) :: TPSENSOR

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_deallocate_aircraft', 'aircraft: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  CALL DATA_ARRAYS_DEALLOCATE_FLYER( TPSENSOR )

END SUBROUTINE DATA_ARRAYS_DEALLOCATE_AIRCRAFT


! #########################################################
SUBROUTINE DATA_ARRAYS_ALLOCATE_BALLOON( TPSENSOR, KSTORE )
! #########################################################

  USE MODE_MSG

  CLASS(TBALLOONDATA), INTENT(INOUT) :: TPSENSOR
  INTEGER, OPTIONAL, INTENT(IN)    :: KSTORE

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_allocate_balloon', 'balloon: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  CALL DATA_ARRAYS_ALLOCATE_FLYER( TPSENSOR, KSTORE )

  TPSENSOR%NBUFFER_FIXSIZE = TPSENSOR%NBUFFER_FIXSIZE + 15

END SUBROUTINE DATA_ARRAYS_ALLOCATE_BALLOON


! ###################################################
SUBROUTINE DATA_ARRAYS_DEALLOCATE_BALLOON( TPSENSOR )
! ###################################################

  USE MODE_MSG

  CLASS(TBALLOONDATA), INTENT(INOUT) :: TPSENSOR

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_deallocate_balloon', 'balloon: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  CALL DATA_ARRAYS_DEALLOCATE_FLYER( TPSENSOR )

END SUBROUTINE DATA_ARRAYS_DEALLOCATE_BALLOON


! #####################################################################
SUBROUTINE BUFFER_PACK_FLYER( TPSENSOR, PBUFFER, KPOS, KSTORE_CURRENT )
! #####################################################################

  USE MODD_CONF_n,     ONLY: NRR
  USE MODD_DIM_n,      ONLY: NKMAX
  USE MODD_NSV,        ONLY: NSV
  USE MODD_PARAMETERS, ONLY: JPVEXT
  USE MODD_PARAM_n,    ONLY: CCLOUD

  USE MODE_DATETIME
  USE MODE_MSG

  CLASS(TFLYERDATA),            INTENT(IN)    :: TPSENSOR
  REAL, DIMENSION(:),           INTENT(INOUT) :: PBUFFER        ! Buffer to pack
  INTEGER,                      INTENT(INOUT) :: KPOS           ! Position in the buffer
  INTEGER,            OPTIONAL, INTENT(IN)    :: KSTORE_CURRENT ! Current number of stored instants

  INTEGER :: IKU      ! number of vertical levels
  INTEGER :: ISTORES
  INTEGER :: JI

  IKU = NKMAX + 2 * JPVEXT

  IF ( PRESENT( KSTORE_CURRENT ) ) THEN
    ISTORES = KSTORE_CURRENT
    IF ( ISTORES > TPSENSOR%NSTORE_MAX ) THEN
      CALL PRINT_MSG( NVERB_ERROR, 'GEN', 'Buffer_pack_flyer', 'flyer: ' // TRIM(TPSENSOR%CNAME) &
                      // ': KSTORE_CURRENT>NSTORE_MAX', OLOCAL = .TRUE. )
      ISTORES = TPSENSOR%NSTORE_MAX
    END IF
  ELSE
    ISTORES = TPSENSOR%NSTORE_MAX
  END IF

  CALL TPSENSOR%BUFFER_PACK_SENSOR( PBUFFER, KPOS, ISTORES )

  IF ( TPSENSOR%CMODEL == 'FIX' ) THEN
    PBUFFER(KPOS) = NMODEL_FIX
  ELSE
    PBUFFER(KPOS) = NMODEL_MOB
  END IF
  KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%NMODEL ; KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%TLAUNCH - TPREFERENCE_DATE ; KPOS = KPOS + 1

  IF ( TPSENSOR%LCRASH ) THEN
    PBUFFER(KPOS) = 1.d0
  ELSE
    PBUFFER(KPOS) = 0.d0
  END IF
  KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%NCRASH ; KPOS = KPOS + 1

  IF ( TPSENSOR%LFLY ) THEN
    PBUFFER(KPOS) = 1.d0
  ELSE
    PBUFFER(KPOS) = 0.d0
  END IF
  KPOS = KPOS + 1

  IF ( TPSENSOR%LSTORE ) THEN
    PBUFFER(KPOS) = 1.d0
  ELSE
    PBUFFER(KPOS) = 0.d0
  END IF
  KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%TFLYER_TIME%N_CUR  ;  KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%TFLYER_TIME%XTSTEP ; KPOS = KPOS + 1
  DO JI = 1, ISTORES
    PBUFFER(KPOS) = TPSENSOR%TFLYER_TIME%TPDATES(JI) - TPREFERENCE_DATE ; KPOS = KPOS + 1
  END DO

  PBUFFER(KPOS) = TPSENSOR%NRANK_CUR; KPOS = KPOS + 1

  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%NMODELHIST(1:ISTORES); KPOS = KPOS + ISTORES

  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XX       (1:ISTORES) ; KPOS = KPOS + ISTORES
  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XY       (1:ISTORES) ; KPOS = KPOS + ISTORES
  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XZ       (1:ISTORES) ; KPOS = KPOS + ISTORES
  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XLAT     (1:ISTORES) ; KPOS = KPOS + ISTORES
  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XLON     (1:ISTORES) ; KPOS = KPOS + ISTORES
  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XTKE_DISS(1:ISTORES) ; KPOS = KPOS + ISTORES
  PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XRTZ(1:IKU,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES

  PBUFFER(KPOS:KPOS+IKU*ISTORES*NRR-1) = RESHAPE( TPSENSOR%XRZ(1:IKU,1:ISTORES,1:NRR), [IKU*ISTORES*NRR] )
  KPOS = KPOS + IKU * ISTORES * NRR

  PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XFFZ (1:IKU,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES

  PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XWZ(1:IKU,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
  PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XZZ(1:IKU,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES

  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XZS(1:ISTORES) ; KPOS = KPOS + ISTORES

  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XTHW_FLUX(1:ISTORES) ; KPOS = KPOS + ISTORES
  PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XRCW_FLUX(1:ISTORES) ; KPOS = KPOS + ISTORES

  PBUFFER(KPOS:KPOS+ISTORES*NSV-1) = RESHAPE( TPSENSOR%XSVW_FLUX(1:ISTORES,1:NSV), [ISTORES*NSV] )
  KPOS = KPOS + ISTORES * NSV

END SUBROUTINE BUFFER_PACK_FLYER

! ########################################################################
SUBROUTINE BUFFER_PACK_AIRCRAFT( TPSENSOR, PBUFFER, KPOS, KSTORE_CURRENT )
! ########################################################################

  USE MODE_DATETIME
  USE MODE_MSG

  CLASS(TAIRCRAFTDATA),         INTENT(IN)    :: TPSENSOR
  REAL, DIMENSION(:),           INTENT(INOUT) :: PBUFFER        ! Buffer to pack
  INTEGER,                      INTENT(INOUT) :: KPOS           ! Position in the buffer
  INTEGER,            OPTIONAL, INTENT(IN)    :: KSTORE_CURRENT ! Current number of stored instants

  INTEGER :: IPOSAIR
  INTEGER :: ISTORES

  IF ( PRESENT( KSTORE_CURRENT ) ) THEN
    ISTORES = KSTORE_CURRENT
    IF ( ISTORES > TPSENSOR%NSTORE_MAX ) THEN
      CALL PRINT_MSG( NVERB_ERROR, 'GEN', 'Buffer_pack_flyer', 'flyer: ' // TRIM(TPSENSOR%CNAME) &
                      // ': KSTORE_CURRENT>NSTORE_MAX', OLOCAL = .TRUE. )
      ISTORES = TPSENSOR%NSTORE_MAX
    END IF
  ELSE
    ISTORES = TPSENSOR%NSTORE_MAX
  END IF

  CALL TPSENSOR%BUFFER_PACK_FLYER( PBUFFER, KPOS, ISTORES )

  IF ( TPSENSOR%LTOOKOFF ) THEN
    PBUFFER(KPOS) = 1.d0
  ELSE
    PBUFFER(KPOS) = 0.d0
  END IF
  KPOS = KPOS + 1

  IF ( TPSENSOR%LALTDEF ) THEN
    PBUFFER(KPOS) = 1.d0
  ELSE
    PBUFFER(KPOS) = 0.d0
  END IF
  KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%NPOS    ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%NPOSCUR ; KPOS = KPOS + 1

  IPOSAIR = TPSENSOR%NPOS

  PBUFFER(KPOS:KPOS+IPOSAIR-1) = TPSENSOR%XPOSLAT(1:IPOSAIR) ; KPOS = KPOS + IPOSAIR
  PBUFFER(KPOS:KPOS+IPOSAIR-1) = TPSENSOR%XPOSLON(1:IPOSAIR) ; KPOS = KPOS + IPOSAIR
  PBUFFER(KPOS:KPOS+IPOSAIR-1) = TPSENSOR%XPOSX  (1:IPOSAIR) ; KPOS = KPOS + IPOSAIR
  PBUFFER(KPOS:KPOS+IPOSAIR-1) = TPSENSOR%XPOSY  (1:IPOSAIR) ; KPOS = KPOS + IPOSAIR
  IF ( TPSENSOR%LALTDEF ) THEN
    PBUFFER(KPOS:KPOS+IPOSAIR-1) = TPSENSOR%XPOSP(1:IPOSAIR) ; KPOS = KPOS + IPOSAIR
  ELSE
    PBUFFER(KPOS:KPOS+IPOSAIR-1) = TPSENSOR%XPOSZ(1:IPOSAIR) ; KPOS = KPOS + IPOSAIR
  ENDIF
  PBUFFER(KPOS:KPOS+IPOSAIR-1) = TPSENSOR%XPOSTIME(1:IPOSAIR) ; KPOS = KPOS + IPOSAIR

  PBUFFER(KPOS) = TPSENSOR%TLAND - TPREFERENCE_DATE ; KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%XP_CUR ; KPOS = KPOS + 1

END SUBROUTINE BUFFER_PACK_AIRCRAFT


! #######################################################################
SUBROUTINE BUFFER_PACK_BALLOON( TPSENSOR, PBUFFER, KPOS, KSTORE_CURRENT )
! #######################################################################

  USE MODE_DATETIME
  USE MODE_MSG

  CLASS(TBALLOONDATA),          INTENT(IN)    :: TPSENSOR
  REAL, DIMENSION(:),           INTENT(INOUT) :: PBUFFER        ! Buffer to pack
  INTEGER,                      INTENT(INOUT) :: KPOS           ! Position in the buffer
  INTEGER,            OPTIONAL, INTENT(IN)    :: KSTORE_CURRENT ! Current number of stored instants

  INTEGER :: ISTORES

  IF ( PRESENT( KSTORE_CURRENT ) ) THEN
    ISTORES = KSTORE_CURRENT
    IF ( ISTORES > TPSENSOR%NSTORE_MAX ) THEN
      CALL PRINT_MSG( NVERB_ERROR, 'GEN', 'Buffer_pack_flyer', 'flyer: ' // TRIM(TPSENSOR%CNAME) &
                      // ': KSTORE_CURRENT>NSTORE_MAX', OLOCAL = .TRUE. )
      ISTORES = TPSENSOR%NSTORE_MAX
    END IF
  ELSE
    ISTORES = TPSENSOR%NSTORE_MAX
  END IF

  CALL TPSENSOR%BUFFER_PACK_FLYER( PBUFFER, KPOS, ISTORES )

  IF ( TPSENSOR%LPOSITION_INIT ) THEN
    PBUFFER(KPOS) = 1.d0
  ELSE
    PBUFFER(KPOS) = 0.d0
  END IF
  KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%XLATLAUNCH ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XLONLAUNCH ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XXLAUNCH   ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XYLAUNCH   ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XALTLAUNCH ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XWASCENT   ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XRHO       ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XPRES      ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XDIAMETER  ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XAERODRAG  ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XINDDRAG   ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XVOLUME    ; KPOS = KPOS + 1
  PBUFFER(KPOS) = TPSENSOR%XMASS      ; KPOS = KPOS + 1

  PBUFFER(KPOS) = TPSENSOR%TPOS_CUR - TPREFERENCE_DATE; KPOS = KPOS + 1

END SUBROUTINE BUFFER_PACK_BALLOON


! ###############################################################
SUBROUTINE BUFFER_UNPACK_FLYER( TPSENSOR, PBUFFER, KPOS, KSTORE )
! ###############################################################

  USE MODD_CONF_n,           ONLY: NRR
  USE MODD_DIM_n,            ONLY: NKMAX
  USE MODD_NSV,              ONLY: NSV
  USE MODD_PARAMETERS,       ONLY: JPVEXT
  USE MODD_PARAM_n,          ONLY: CCLOUD

  USE MODE_DATETIME
  USE MODE_MSG

  CLASS(TFLYERDATA),  INTENT(INOUT) :: TPSENSOR
  REAL, DIMENSION(:), INTENT(IN)    :: PBUFFER  ! Buffer to unpack
  INTEGER,            INTENT(INOUT) :: KPOS     ! Position in the buffer
  INTEGER,            INTENT(IN)    :: KSTORE   ! Current number of stored instants

  INTEGER :: IKU      ! number of vertical levels
  INTEGER :: JI

  IKU = NKMAX + 2 * JPVEXT

  CALL TPSENSOR%BUFFER_UNPACK_SENSOR( PBUFFER, KPOS, KSTORE )

  IF ( NINT( PBUFFER(KPOS) ) == NMODEL_FIX ) THEN
    TPSENSOR%CMODEL = 'FIX'
  ELSE
    TPSENSOR%CMODEL = 'MOB'
  END IF
  KPOS = KPOS + 1

  TPSENSOR%NMODEL = NINT( PBUFFER(KPOS) ); KPOS = KPOS + 1

  TPSENSOR%TLAUNCH = TPREFERENCE_DATE + PBUFFER(KPOS); KPOS = KPOS + 1

  IF ( NINT( PBUFFER(KPOS) ) == 0 ) THEN
    TPSENSOR%LCRASH = .FALSE.
  ELSE
    TPSENSOR%LCRASH = .TRUE.
  END IF
  KPOS = KPOS + 1

  TPSENSOR%NCRASH = NINT( PBUFFER(KPOS) ); KPOS = KPOS + 1

  IF ( NINT( PBUFFER(KPOS) ) == 0 ) THEN
    TPSENSOR%LFLY = .FALSE.
  ELSE
    TPSENSOR%LFLY = .TRUE.
  END IF
  KPOS = KPOS + 1

  IF ( NINT( PBUFFER(KPOS) ) == 0 ) THEN
    TPSENSOR%LSTORE = .FALSE.
  ELSE
    TPSENSOR%LSTORE = .TRUE.
  END IF
  KPOS = KPOS + 1

  TPSENSOR%TFLYER_TIME%N_CUR = NINT( PBUFFER(KPOS) ); KPOS = KPOS + 1
  TPSENSOR%TFLYER_TIME%XTSTEP = PBUFFER(KPOS); KPOS = KPOS + 1

  DO JI = 1, KSTORE
    TPSENSOR%TFLYER_TIME%TPDATES(JI) = TPREFERENCE_DATE + PBUFFER(KPOS); KPOS = KPOS + 1
  END DO

  TPSENSOR%NRANK_CUR = NINT( PBUFFER(KPOS) ); KPOS = KPOS + 1

  TPSENSOR%NMODELHIST(1:KSTORE) = NINT( PBUFFER(KPOS:KPOS+KSTORE-1) ) ; KPOS = KPOS + KSTORE

  TPSENSOR%XX(1:KSTORE)        = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
  TPSENSOR%XY(1:KSTORE)        = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
  TPSENSOR%XZ(1:KSTORE)        = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
  TPSENSOR%XLAT(1:KSTORE)      = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
  TPSENSOR%XLON(1:KSTORE)      = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
  TPSENSOR%XTKE_DISS(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
  TPSENSOR%XRTZ(1:IKU,1:KSTORE)   = RESHAPE( PBUFFER(KPOS:KPOS+KSTORE*IKU-1), [IKU,KSTORE] ) ; KPOS = KPOS + KSTORE * IKU

  TPSENSOR%XRZ(1:IKU,1:KSTORE,1:NRR) = RESHAPE( PBUFFER(KPOS:KPOS+(KSTORE*IKU*NRR)-1), [IKU,KSTORE,NRR] )
  KPOS = KPOS + KSTORE * IKU * NRR

  TPSENSOR%XFFZ (1:IKU,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+KSTORE*IKU-1), [IKU,KSTORE] ) ;  KPOS = KPOS + KSTORE * IKU

  TPSENSOR%XWZ(1:IKU,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+KSTORE*IKU-1), [IKU,KSTORE] ) ;  KPOS = KPOS + KSTORE * IKU
  TPSENSOR%XZZ(1:IKU,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+KSTORE*IKU-1), [IKU,KSTORE] ) ;  KPOS = KPOS + KSTORE * IKU

  TPSENSOR%XZS(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE

  TPSENSOR%XTHW_FLUX(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
  TPSENSOR%XRCW_FLUX(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE

  TPSENSOR%XSVW_FLUX(1:KSTORE,1:NSV) = RESHAPE( PBUFFER(KPOS:KPOS+KSTORE*NSV-1), [KSTORE,NSV] )
  KPOS = KPOS + KSTORE * NSV

END SUBROUTINE BUFFER_UNPACK_FLYER

! ##################################################################
SUBROUTINE BUFFER_UNPACK_AIRCRAFT( TPSENSOR, PBUFFER, KPOS, KSTORE )
! ##################################################################

  USE MODE_DATETIME
  USE MODE_MSG

  CLASS(TAIRCRAFTDATA), INTENT(INOUT) :: TPSENSOR
  REAL, DIMENSION(:),   INTENT(IN)    :: PBUFFER  ! Buffer to unpack
  INTEGER,              INTENT(INOUT) :: KPOS     ! Position in the buffer
  INTEGER,              INTENT(IN)    :: KSTORE   ! Current number of stored instants

  INTEGER :: IPOSAIR

  CALL TPSENSOR%BUFFER_UNPACK_FLYER( PBUFFER, KPOS, KSTORE )

  IF ( NINT( PBUFFER(KPOS) ) == 0 ) THEN
    TPSENSOR%LTOOKOFF = .FALSE.
  ELSE
    TPSENSOR%LTOOKOFF = .TRUE.
  END IF
  KPOS = KPOS + 1

  IF ( NINT( PBUFFER(KPOS) ) == 0 ) THEN
    TPSENSOR%LALTDEF = .FALSE.
  ELSE
    TPSENSOR%LALTDEF = .TRUE.
  END IF
  KPOS = KPOS + 1

  TPSENSOR%NPOS    = NINT( PBUFFER(KPOS) ) ; KPOS = KPOS + 1
  TPSENSOR%NPOSCUR = NINT( PBUFFER(KPOS) ) ; KPOS = KPOS + 1

  IPOSAIR = TPSENSOR%NPOS

  ALLOCATE( TPSENSOR%XPOSLAT(IPOSAIR) )
  ALLOCATE( TPSENSOR%XPOSLON(IPOSAIR) )
  ALLOCATE( TPSENSOR%XPOSX(IPOSAIR) )
  ALLOCATE( TPSENSOR%XPOSY(IPOSAIR) )
  IF ( TPSENSOR%LALTDEF ) THEN
    ALLOCATE( TPSENSOR%XPOSP(IPOSAIR) )
  ELSE
    ALLOCATE( TPSENSOR%XPOSZ(IPOSAIR) )
  END IF
  ALLOCATE( TPSENSOR%XPOSTIME(IPOSAIR) )

  TPSENSOR%XPOSLAT (1:IPOSAIR) = PBUFFER(KPOS:KPOS+IPOSAIR-1) ; KPOS = KPOS + IPOSAIR
  TPSENSOR%XPOSLON (1:IPOSAIR) = PBUFFER(KPOS:KPOS+IPOSAIR-1) ; KPOS = KPOS + IPOSAIR
  TPSENSOR%XPOSX   (1:IPOSAIR) = PBUFFER(KPOS:KPOS+IPOSAIR-1) ; KPOS = KPOS + IPOSAIR
  TPSENSOR%XPOSY   (1:IPOSAIR) = PBUFFER(KPOS:KPOS+IPOSAIR-1) ; KPOS = KPOS + IPOSAIR
  IF ( TPSENSOR%LALTDEF ) THEN
    TPSENSOR%XPOSP (1:IPOSAIR) = PBUFFER(KPOS:KPOS+IPOSAIR-1) ; KPOS = KPOS + IPOSAIR
  ELSE
    TPSENSOR%XPOSZ (1:IPOSAIR) = PBUFFER(KPOS:KPOS+IPOSAIR-1) ; KPOS = KPOS + IPOSAIR
  END IF
  TPSENSOR%XPOSTIME(1:IPOSAIR) = PBUFFER(KPOS:KPOS+IPOSAIR-1) ; KPOS = KPOS + IPOSAIR

  TPSENSOR%TLAND = TPREFERENCE_DATE + PBUFFER(KPOS) ; KPOS = KPOS + 1

  TPSENSOR%XP_CUR = PBUFFER(KPOS) ; KPOS = KPOS + 1

END SUBROUTINE BUFFER_UNPACK_AIRCRAFT


! #################################################################
SUBROUTINE BUFFER_UNPACK_BALLOON( TPSENSOR, PBUFFER, KPOS, KSTORE )
! #################################################################

  USE MODE_DATETIME
  USE MODE_MSG

  CLASS(TBALLOONDATA), INTENT(INOUT) :: TPSENSOR
  REAL, DIMENSION(:),  INTENT(IN)    :: PBUFFER  ! Buffer to unpack
  INTEGER,             INTENT(INOUT) :: KPOS     ! Position in the buffer
  INTEGER,             INTENT(IN)    :: KSTORE   ! Current number of stored instants

  CALL TPSENSOR%BUFFER_UNPACK_FLYER( PBUFFER, KPOS, KSTORE )

  IF ( NINT( PBUFFER(KPOS) ) == 0 ) THEN
    TPSENSOR%LPOSITION_INIT = .FALSE.
  ELSE
    TPSENSOR%LPOSITION_INIT = .TRUE.
  END IF
  KPOS = KPOS + 1

  TPSENSOR%XLATLAUNCH = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XLONLAUNCH = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XXLAUNCH   = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XYLAUNCH   = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XALTLAUNCH = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XWASCENT   = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XRHO       = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XPRES      = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XDIAMETER  = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XAERODRAG  = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XINDDRAG   = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XVOLUME    = PBUFFER(KPOS) ; KPOS = KPOS + 1
  TPSENSOR%XMASS      = PBUFFER(KPOS) ; KPOS = KPOS + 1

  TPSENSOR%TPOS_CUR = TPREFERENCE_DATE + PBUFFER(KPOS) ; KPOS = KPOS + 1

END SUBROUTINE BUFFER_UNPACK_BALLOON


END MODULE MODD_AIRCRAFT_BALLOON
