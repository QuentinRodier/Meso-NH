!MNH_LIC Copyright 2002-2023 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
!     ############################
      MODULE MODD_TYPE_STATPROF
!     ############################
!
!!****  *MODD_STATION* - declaration of stations
!!
!!    PURPOSE
!!    -------
!       The purpose of this declarative module is to define
!      the different stations types.
!
!!
!!**  IMPLICIT ARGUMENTS
!!    ------------------
!!      NONE 
!!
!!    REFERENCE
!!    --------- 
!!       
!!    AUTHOR
!!    ------
!!	P. Tulet   *Meteo France*
!!
!!    MODIFICATIONS
!!    -------------
!!      Original    15/01/02
!  P. Wautelet 13/09/2019: budget: simplify and modernize date/time management
!  P. Wautelet    04/2022: restructure stations/profilers for better performance, reduce memory usage and correct some problems/bugs
!-------------------------------------------------------------------------------
!
!*       0.   DECLARATIONS
!             ------------
!
use modd_parameters,  only: NNEGUNDEF, NSENSORNAMELGTMAX, XUNDEF
use modd_sensor,      only: tsensor
use modd_type_date,   only: date_time

implicit none

private

public :: TPROFILERDATA, TSTATIONDATA, TSTATPROFDATA

TYPE, EXTENDS(TSENSOR), ABSTRACT :: TSTATPROFDATA
  ! Type to store data common to stations and profilers
  ! It is used as a basis for the TSTATIONDATA and TPROFILERDATA
  ! and for common procedures for these 2 types

  ! Dimension corresponds to recording instants
  REAL, DIMENSION(:),   ALLOCATABLE :: XT2M    ! 2 m air temperature (C)
  REAL, DIMENSION(:),   ALLOCATABLE :: XQ2M    ! 2 m humidity (kg/kg)
  REAL, DIMENSION(:),   ALLOCATABLE :: XHU2M   ! 2 m relative humidity (%)
  REAL, DIMENSION(:),   ALLOCATABLE :: XZON10M ! 10 m zonal wind (m/s)
  REAL, DIMENSION(:),   ALLOCATABLE :: XMER10M ! 10 m merid. wind (m/s)
  REAL, DIMENSION(:),   ALLOCATABLE :: XRN     ! net radiation (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XH      ! sensible heat flux (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XLE     ! Total latent heat flux (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XLEI    ! Solid latent heat flux (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XGFLUX  ! storage heat flux (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XSWD    ! IR downward radiation (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XSWU    ! IR upward radiation (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XLWD    ! solar downward radiation (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XLWU    ! solar upward radiation (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XSWDIR  ! IR downward direct radiation (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XSWDIFF ! IR downward diffuse radiation (W/m2)
  REAL, DIMENSION(:),   ALLOCATABLE :: XDSTAOD ! Dust Aerosol Optical Depth (m)
  REAL, DIMENSION(:),   ALLOCATABLE :: XSLTAOD ! Salt Aerosol Optical Depth (m)
  REAL, DIMENSION(:),   ALLOCATABLE :: XSFCO2  ! CO2 surface flux (mg/m2/s)

  CONTAINS
    ! Remark: DATA_ARRAYS_(DE)ALLOCATE_STATPROF do not point to DATA_ARRAYS_(DE)ALLOCATE to allow other dummy arguments
    PROCEDURE                  :: BUFFER_PACK   => BUFFER_PACK_STATPROF
    PROCEDURE                  :: BUFFER_UNPACK => BUFFER_UNPACK_STATPROF
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_ALLOCATE_STATPROF
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_DEALLOCATE_STATPROF
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_PACK_STATPROF
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_UNPACK_STATPROF
END TYPE

TYPE, EXTENDS( TSTATPROFDATA ) ::  TSTATIONDATA
  ! Type to store all the data of 1 station
  INTEGER :: NK = NNEGUNDEF ! Model level for altitude comparisons

  REAL :: XZS  = XUNDEF  ! zs(n)
  REAL :: XZMEAS = XUNDEF ! interpolated altitude used for measurements

  CONTAINS
    PROCEDURE                  :: DATA_ARRAYS_ALLOCATE   => DATA_ARRAYS_ALLOCATE_STATION
    PROCEDURE                  :: DATA_ARRAYS_DEALLOCATE => DATA_ARRAYS_DEALLOCATE_STATION
    PROCEDURE                  :: BUFFER_PACK   => BUFFER_PACK_STATION
    PROCEDURE                  :: BUFFER_UNPACK => BUFFER_UNPACK_STATION
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_ALLOCATE_STATION
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_DEALLOCATE_STATION
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_PACK_STATION
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_UNPACK_STATION
  END TYPE TSTATIONDATA

TYPE, EXTENDS( TSTATPROFDATA ) ::  TPROFILERDATA
  ! Type to store all the data of 1 profiler

  ! (n: recording instants)
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XFF        ! wind intensity
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XDD        ! wind direction
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XZZ        ! altitude(n)
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XTHV       ! thv(n)
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XVISIGUL   ! VISI GULTEPE(n)
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XVISIKUN   ! VISI KUNKEL(n)
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XCIZ       ! Ice number concentration ICE3 (n)
  REAL, DIMENSION(:,:),   ALLOCATABLE :: XRHOD      ! density of dry air/moist air
  REAL, DIMENSION(:,:,:), ALLOCATABLE :: XAER       ! AER*(n) aerosol extinction

  REAL, DIMENSION(:), ALLOCATABLE :: XIWV ! integrated water vpour(n)
  REAL, DIMENSION(:), ALLOCATABLE :: XZTD ! GPS zenith tropo delay(n)
  REAL, DIMENSION(:), ALLOCATABLE :: XZWD ! GPS zenith wet delay(n)
  REAL, DIMENSION(:), ALLOCATABLE :: XZHD ! GPS zenith hydro delay(n)

  REAL, DIMENSION(:,:), ALLOCATABLE :: XTKE_DISS ! TKE dissipation rate

  CONTAINS
    PROCEDURE                  :: DATA_ARRAYS_ALLOCATE   => DATA_ARRAYS_ALLOCATE_PROFILER
    PROCEDURE                  :: DATA_ARRAYS_DEALLOCATE => DATA_ARRAYS_DEALLOCATE_PROFILER
    PROCEDURE                  :: BUFFER_PACK   => BUFFER_PACK_PROFILER
    PROCEDURE                  :: BUFFER_UNPACK => BUFFER_UNPACK_PROFILER
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_ALLOCATE_PROFILER
    PROCEDURE, NON_OVERRIDABLE :: DATA_ARRAYS_DEALLOCATE_PROFILER
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_PACK_PROFILER
    PROCEDURE, NON_OVERRIDABLE :: BUFFER_UNPACK_PROFILER
END TYPE


CONTAINS

! #############################################################################################
SUBROUTINE DATA_ARRAYS_ALLOCATE_STATPROF( TPSENSOR, OVERTPROF, KLEVELS, KSTORE, ODIAG_SURFRAD )
! #############################################################################################

  USE MODD_PARAMETERS, ONLY: XUNDEF
  USE MODD_PARAM_n,    ONLY: CRAD
  USE MODD_SURF_PAR,   ONLY: XUNDEF_SFX => XUNDEF

  USE MODE_MSG

  CLASS(TSTATPROFDATA), INTENT(INOUT) :: TPSENSOR
  LOGICAL,              INTENT(IN)    :: OVERTPROF ! vertical profile or not
  INTEGER,              INTENT(IN)    :: KLEVELS   ! number of vertical levels
  INTEGER,              INTENT(IN)    :: KSTORE
  LOGICAL,              INTENT(IN)    :: ODIAG_SURFRAD

  INTEGER :: IVARSIZE ! allocated size per store

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_allocate_statprof', 'statprof: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  CALL TPSENSOR%DATA_ARRAYS_ALLOCATE_SENSOR( OVERTPROF, KLEVELS, KSTORE )

  IVARSIZE = 0

  IF ( ODIAG_SURFRAD ) THEN
    ALLOCATE( TPSENSOR%XT2M   (KSTORE) )
    ALLOCATE( TPSENSOR%XQ2M   (KSTORE) )
    ALLOCATE( TPSENSOR%XHU2M  (KSTORE) )
    ALLOCATE( TPSENSOR%XZON10M(KSTORE) )
    ALLOCATE( TPSENSOR%XMER10M(KSTORE) )
    ALLOCATE( TPSENSOR%XRN    (KSTORE) )
    ALLOCATE( TPSENSOR%XH     (KSTORE) )
    ALLOCATE( TPSENSOR%XLE    (KSTORE) )
    ALLOCATE( TPSENSOR%XLEI   (KSTORE) )
    ALLOCATE( TPSENSOR%XGFLUX (KSTORE) )
    IVARSIZE = IVARSIZE + 10
    IF ( CRAD /= 'NONE' ) THEN
      ALLOCATE( TPSENSOR%XSWD   (KSTORE) )
      ALLOCATE( TPSENSOR%XSWU   (KSTORE) )
      ALLOCATE( TPSENSOR%XLWD   (KSTORE) )
      ALLOCATE( TPSENSOR%XLWU   (KSTORE) )
      ALLOCATE( TPSENSOR%XSWDIR (KSTORE) )
      ALLOCATE( TPSENSOR%XSWDIFF(KSTORE) )
      ALLOCATE( TPSENSOR%XDSTAOD(KSTORE) )
      ALLOCATE( TPSENSOR%XSLTAOD(KSTORE) )
      IVARSIZE = IVARSIZE + 8
    ELSE
      ALLOCATE( TPSENSOR%XSWD   (0) )
      ALLOCATE( TPSENSOR%XSWU   (0) )
      ALLOCATE( TPSENSOR%XLWD   (0) )
      ALLOCATE( TPSENSOR%XLWU   (0) )
      ALLOCATE( TPSENSOR%XSWDIR (0) )
      ALLOCATE( TPSENSOR%XSWDIFF(0) )
      ALLOCATE( TPSENSOR%XDSTAOD(0) )
      ALLOCATE( TPSENSOR%XSLTAOD(0) )
    END IF
    ALLOCATE( TPSENSOR%XSFCO2   (KSTORE) )
    IVARSIZE = IVARSIZE + 1
  ELSE
    ALLOCATE( TPSENSOR%XT2M   (0) )
    ALLOCATE( TPSENSOR%XQ2M   (0) )
    ALLOCATE( TPSENSOR%XHU2M  (0) )
    ALLOCATE( TPSENSOR%XZON10M(0) )
    ALLOCATE( TPSENSOR%XMER10M(0) )
    ALLOCATE( TPSENSOR%XRN    (0) )
    ALLOCATE( TPSENSOR%XH     (0) )
    ALLOCATE( TPSENSOR%XLE    (0) )
    ALLOCATE( TPSENSOR%XLEI   (0) )
    ALLOCATE( TPSENSOR%XGFLUX (0) )
    ALLOCATE( TPSENSOR%XSWD   (0) )
    ALLOCATE( TPSENSOR%XSWU   (0) )
    ALLOCATE( TPSENSOR%XLWD   (0) )
    ALLOCATE( TPSENSOR%XLWU   (0) )
    ALLOCATE( TPSENSOR%XSWDIR (0) )
    ALLOCATE( TPSENSOR%XSWDIFF(0) )
    ALLOCATE( TPSENSOR%XDSTAOD(0) )
    ALLOCATE( TPSENSOR%XSLTAOD(0) )
    ALLOCATE( TPSENSOR%XSFCO2 (0) )
  END IF

  IF ( ODIAG_SURFRAD ) THEN
    TPSENSOR%XT2M   (:) = XUNDEF_SFX
    TPSENSOR%XQ2M   (:) = XUNDEF_SFX
    TPSENSOR%XHU2M  (:) = XUNDEF_SFX
    TPSENSOR%XZON10M(:) = XUNDEF_SFX
    TPSENSOR%XMER10M(:) = XUNDEF_SFX
    TPSENSOR%XRN    (:) = XUNDEF_SFX
    TPSENSOR%XH     (:) = XUNDEF_SFX
    TPSENSOR%XLE    (:) = XUNDEF_SFX
    TPSENSOR%XLEI   (:) = XUNDEF_SFX
    TPSENSOR%XGFLUX (:) = XUNDEF_SFX
    IF ( CRAD /= 'NONE' ) THEN
      TPSENSOR%XSWD   (:) = XUNDEF
      TPSENSOR%XSWU   (:) = XUNDEF
      TPSENSOR%XLWD   (:) = XUNDEF
      TPSENSOR%XLWU   (:) = XUNDEF
      TPSENSOR%XSWDIR (:) = XUNDEF
      TPSENSOR%XSWDIFF(:) = XUNDEF
      TPSENSOR%XDSTAOD(:) = XUNDEF
      TPSENSOR%XSLTAOD(:) = XUNDEF
    END IF
    TPSENSOR%XSFCO2(:)      = XUNDEF
  END IF

  ! TPSENSOR%NBUFFER_FIXSIZE = TPSENSOR%NBUFFER_FIXSIZE +
  TPSENSOR%NBUFFER_VARSIZE = TPSENSOR%NBUFFER_VARSIZE + IVARSIZE

END SUBROUTINE DATA_ARRAYS_ALLOCATE_STATPROF


! ####################################################
SUBROUTINE DATA_ARRAYS_DEALLOCATE_STATPROF( TPSENSOR )
! ####################################################

  USE MODE_MSG

  CLASS(TSTATPROFDATA), INTENT(INOUT) :: TPSENSOR

  CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_deallocate_statprof', 'statprof: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

  CALL TPSENSOR%DATA_ARRAYS_DEALLOCATE_SENSOR()

  DEALLOCATE( TPSENSOR%XT2M    )
  DEALLOCATE( TPSENSOR%XQ2M    )
  DEALLOCATE( TPSENSOR%XHU2M   )
  DEALLOCATE( TPSENSOR%XZON10M )
  DEALLOCATE( TPSENSOR%XMER10M )
  DEALLOCATE( TPSENSOR%XRN     )
  DEALLOCATE( TPSENSOR%XH      )
  DEALLOCATE( TPSENSOR%XLE     )
  DEALLOCATE( TPSENSOR%XLEI    )
  DEALLOCATE( TPSENSOR%XGFLUX  )
  DEALLOCATE( TPSENSOR%XSWD    )
  DEALLOCATE( TPSENSOR%XSWU    )
  DEALLOCATE( TPSENSOR%XLWD    )
  DEALLOCATE( TPSENSOR%XLWU    )
  DEALLOCATE( TPSENSOR%XSWDIR  )
  DEALLOCATE( TPSENSOR%XSWDIFF )
  DEALLOCATE( TPSENSOR%XDSTAOD )
  DEALLOCATE( TPSENSOR%XSLTAOD )
  DEALLOCATE( TPSENSOR%XSFCO2  )

END SUBROUTINE DATA_ARRAYS_DEALLOCATE_STATPROF


! ##########################################################
SUBROUTINE DATA_ARRAYS_ALLOCATE_PROFILER( TPSENSOR, KSTORE )
! ##########################################################

    USE MODD_ALLPROFILER_n, ONLY: LDIAG_SURFRAD_PROF
    USE MODD_DIM_n,         ONLY: NKMAX
    USE MODD_PARAMETERS,    ONLY: JPVEXT
    USE MODD_PARAM_n,       ONLY: CCLOUD
    USE MODD_RADIATIONS_n,  ONLY: NAER

    USE MODE_MSG

    CLASS(TPROFILERDATA), INTENT(INOUT) :: TPSENSOR
    INTEGER, OPTIONAL,    INTENT(IN)    :: KSTORE  ! number of moments to store

    INTEGER :: IKU
    INTEGER :: IVARSIZE ! allocated size per store

    CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_allocate_profiler', 'profiler: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

    IF ( .NOT.PRESENT( KSTORE ) ) &
      CALL PRINT_MSG( NVERB_FATAL, 'GEN', 'Data_arrays_allocate_profiler', 'KSTORE not provided', OLOCAL = .TRUE. )

    IKU = NKMAX + 2 * JPVEXT
    IVARSIZE = 0

    CALL DATA_ARRAYS_ALLOCATE_STATPROF( TPSENSOR, OVERTPROF = .TRUE., KLEVELS = IKU, KSTORE = KSTORE, &
                                        ODIAG_SURFRAD = LDIAG_SURFRAD_PROF )

    ALLOCATE( TPSENSOR%XFF       (IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU
    ALLOCATE( TPSENSOR%XDD       (IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU
    ALLOCATE( TPSENSOR%XZZ       (IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU
    ALLOCATE( TPSENSOR%XTHV      (IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU
    IF ( CCLOUD == 'C2R2' .OR. CCLOUD == 'KHKO' ) THEN
      ALLOCATE( TPSENSOR%XVISIGUL  (IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU
    ELSE
      ALLOCATE( TPSENSOR%XVISIGUL  (0, 0) )
    END IF
    IF ( CCLOUD /= 'NONE' .AND. CCLOUD /= 'REVE' ) THEN
      ALLOCATE( TPSENSOR%XVISIKUN  (IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU
    ELSE
      ALLOCATE( TPSENSOR%XVISIKUN  (0, 0) )
    END IF
    IF ( CCLOUD == 'ICE3' .OR. CCLOUD == 'ICE4' ) THEN
      ALLOCATE( TPSENSOR%XCIZ    (IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU
    ELSE
      ALLOCATE( TPSENSOR%XCIZ    (0, 0) )
    END IF
    ALLOCATE( TPSENSOR%XRHOD     (IKU, KSTORE) )        ; IVARSIZE = IVARSIZE + IKU
    ALLOCATE( TPSENSOR%XAER      (IKU, KSTORE, NAER ) ) ; IVARSIZE = IVARSIZE + IKU * NAER

    ALLOCATE( TPSENSOR%XIWV(KSTORE) ) ; IVARSIZE = IVARSIZE + 1
    ALLOCATE( TPSENSOR%XZTD(KSTORE) ) ; IVARSIZE = IVARSIZE + 1
    ALLOCATE( TPSENSOR%XZWD(KSTORE) ) ; IVARSIZE = IVARSIZE + 1
    ALLOCATE( TPSENSOR%XZHD(KSTORE) ) ; IVARSIZE = IVARSIZE + 1

    ALLOCATE( TPSENSOR%XTKE_DISS(IKU, KSTORE) ) ; IVARSIZE = IVARSIZE + IKU

    TPSENSOR%NBUFFER_FIXSIZE = TPSENSOR%NBUFFER_FIXSIZE
    TPSENSOR%NBUFFER_VARSIZE = TPSENSOR%NBUFFER_VARSIZE + IVARSIZE

    TPSENSOR%XFF       (:,:) = XUNDEF
    TPSENSOR%XDD       (:,:) = XUNDEF
    TPSENSOR%XZZ       (:,:) = XUNDEF
    TPSENSOR%XTHV      (:,:) = XUNDEF
    IF ( CCLOUD == 'C2R2' .OR. CCLOUD == 'KHKO' )  TPSENSOR%XVISIGUL(:,:) = XUNDEF
    IF ( CCLOUD /= 'NONE' .AND. CCLOUD /= 'REVE' ) TPSENSOR%XVISIKUN(:,:) = XUNDEF
    IF ( CCLOUD == 'ICE3' .OR. CCLOUD == 'ICE4' ) TPSENSOR%XCIZ      (:,:) = XUNDEF
    TPSENSOR%XRHOD     (:,:) = XUNDEF
    TPSENSOR%XAER      (:,:,:) = XUNDEF

    TPSENSOR%XIWV(:) = XUNDEF
    TPSENSOR%XZTD(:) = XUNDEF
    TPSENSOR%XZWD(:) = XUNDEF
    TPSENSOR%XZHD(:) = XUNDEF

    TPSENSOR%XTKE_DISS(:,:) = XUNDEF

  END SUBROUTINE DATA_ARRAYS_ALLOCATE_PROFILER

  ! ####################################################
  SUBROUTINE DATA_ARRAYS_DEALLOCATE_PROFILER( TPSENSOR )
  ! ####################################################
    USE MODE_MSG

    CLASS(TPROFILERDATA), INTENT(INOUT) :: TPSENSOR

    CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_deallocate_profiler', 'profiler: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

    CALL DATA_ARRAYS_DEALLOCATE_STATPROF( TPSENSOR )

    DEALLOCATE( TPSENSOR%XFF        )
    DEALLOCATE( TPSENSOR%XDD        )
    DEALLOCATE( TPSENSOR%XZZ        )
    DEALLOCATE( TPSENSOR%XTHV       )
    DEALLOCATE( TPSENSOR%XVISIGUL   )
    DEALLOCATE( TPSENSOR%XVISIKUN   )
    DEALLOCATE( TPSENSOR%XCIZ       )
    DEALLOCATE( TPSENSOR%XRHOD      )
    DEALLOCATE( TPSENSOR%XAER       )

    DEALLOCATE( TPSENSOR%XIWV )
    DEALLOCATE( TPSENSOR%XZTD )
    DEALLOCATE( TPSENSOR%XZWD )
    DEALLOCATE( TPSENSOR%XZHD )

    DEALLOCATE( TPSENSOR%XTKE_DISS )

  END SUBROUTINE DATA_ARRAYS_DEALLOCATE_PROFILER

  ! #########################################################
  SUBROUTINE DATA_ARRAYS_ALLOCATE_STATION( TPSENSOR, KSTORE )
  ! #########################################################

    USE MODD_ALLSTATION_n, ONLY: LDIAG_SURFRAD_STAT

    USE MODE_MSG

    CLASS(TSTATIONDATA), INTENT(INOUT) :: TPSENSOR
    INTEGER, OPTIONAL,   INTENT(IN)    :: KSTORE  ! number of moments to store

    CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_allocate_station', 'station: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

    IF ( .NOT.PRESENT( KSTORE ) ) &
      CALL PRINT_MSG( NVERB_FATAL, 'GEN', 'Data_arrays_allocate_station', 'KSTORE not provided', OLOCAL = .TRUE. )

    CALL DATA_ARRAYS_ALLOCATE_STATPROF( TPSENSOR, OVERTPROF = .FALSE., KLEVELS = 1, KSTORE = KSTORE, &
                                        ODIAG_SURFRAD = LDIAG_SURFRAD_STAT )

    TPSENSOR%NBUFFER_FIXSIZE = TPSENSOR%NBUFFER_FIXSIZE + 3
    ! TPSENSOR%NBUFFER_VARSIZE = TPSENSOR%NBUFFER_VARSIZE + IVARSIZE

  END SUBROUTINE DATA_ARRAYS_ALLOCATE_STATION

  ! ###################################################
  SUBROUTINE DATA_ARRAYS_DEALLOCATE_STATION( TPSENSOR )
  ! ###################################################

    USE MODE_MSG

    CLASS(TSTATIONDATA), INTENT(INOUT) :: TPSENSOR

    CALL PRINT_MSG( NVERB_DEBUG, 'GEN', 'Data_arrays_deallocate_station', 'station: ' // TRIM(TPSENSOR%CNAME), OLOCAL = .TRUE. )

    CALL DATA_ARRAYS_DEALLOCATE_STATPROF( TPSENSOR )

  END SUBROUTINE DATA_ARRAYS_DEALLOCATE_STATION

  ! ########################################################################
  SUBROUTINE BUFFER_PACK_STATPROF( TPSENSOR, PBUFFER, KPOS, KSTORE_CURRENT )
  ! ########################################################################

    USE MODD_PARAM_n, ONLY: CRAD

    USE MODE_MSG

    CLASS(TSTATPROFDATA),         INTENT(IN)    :: TPSENSOR
    REAL, DIMENSION(:),           INTENT(INOUT) :: PBUFFER        ! Buffer to pack
    INTEGER,                      INTENT(INOUT) :: KPOS           ! Position in the buffer
    INTEGER,            OPTIONAL, INTENT(IN)    :: KSTORE_CURRENT ! Current number of stored instants

    INTEGER :: ISTORES
    LOGICAL :: GISALLOC

    IF ( PRESENT( KSTORE_CURRENT ) ) THEN
      ISTORES = KSTORE_CURRENT
      IF ( ISTORES > TPSENSOR%NSTORE_MAX ) THEN
        CALL PRINT_MSG( NVERB_ERROR, 'GEN', 'Buffer_pack_statprof', 'statprof: ' // TRIM(TPSENSOR%CNAME) &
                        // ': KSTORE_CURRENT>NSTORE_MAX', OLOCAL = .TRUE. )
        ISTORES = TPSENSOR%NSTORE_MAX
      END IF
    ELSE
      ISTORES = TPSENSOR%NSTORE_MAX
    END IF

    CALL TPSENSOR%BUFFER_PACK_SENSOR( PBUFFER, KPOS, ISTORES )

    ! Check if the arrays are allocated with a size > 0
    GISALLOC = ( SIZE( TPSENSOR%XT2M ) > 0 )

    IF ( GISALLOC ) THEN
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XT2M    ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XQ2M    ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XHU2M   ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XZON10M ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XMER10M ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XRN     ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XH      ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XLE     ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XLEI    ; KPOS = KPOS + ISTORES
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XGFLUX  ; KPOS = KPOS + ISTORES
      IF ( CRAD /= 'NONE' ) THEN
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XSWD    ; KPOS = KPOS + ISTORES
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XSWU    ; KPOS = KPOS + ISTORES
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XLWD    ; KPOS = KPOS + ISTORES
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XLWU    ; KPOS = KPOS + ISTORES
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XSWDIR  ; KPOS = KPOS + ISTORES
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XSWDIFF ; KPOS = KPOS + ISTORES
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XDSTAOD ; KPOS = KPOS + ISTORES
        PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XSLTAOD ; KPOS = KPOS + ISTORES
      END IF
      PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XSFCO2    ; KPOS = KPOS + ISTORES
    END IF

  END SUBROUTINE BUFFER_PACK_STATPROF


  ! ########################################################################
  SUBROUTINE BUFFER_PACK_PROFILER( TPSENSOR, PBUFFER, KPOS, KSTORE_CURRENT )
  ! ########################################################################

    USE MODD_DIM_n,        ONLY: NKMAX
    USE MODD_PARAMETERS,   ONLY: JPVEXT
    USE MODD_PARAM_n,      ONLY: CCLOUD
    USE MODD_RADIATIONS_n, ONLY: NAER

    USE MODE_MSG

    CLASS(TPROFILERDATA),         INTENT(IN)    :: TPSENSOR
    REAL, DIMENSION(:),           INTENT(INOUT) :: PBUFFER        ! Buffer to pack
    INTEGER,                      INTENT(INOUT) :: KPOS           ! Position in the buffer
    INTEGER,            OPTIONAL, INTENT(IN)    :: KSTORE_CURRENT ! Current number of stored instants

    INTEGER :: IKU      ! number of vertical levels
    INTEGER :: ISTORES
    INTEGER :: JI

    IKU = NKMAX + 2 * JPVEXT

    IF ( PRESENT( KSTORE_CURRENT ) ) THEN
      ISTORES = KSTORE_CURRENT
      IF ( ISTORES > TPSENSOR%NSTORE_MAX ) THEN
        CALL PRINT_MSG( NVERB_ERROR, 'GEN', 'Buffer_pack_flyer', 'flyer: ' // TRIM(TPSENSOR%CNAME) &
                        // ': KSTORE_CURRENT>NSTORE_MAX', OLOCAL = .TRUE. )
        ISTORES = TPSENSOR%NSTORE_MAX
      END IF
    ELSE
      ISTORES = TPSENSOR%NSTORE_MAX
    END IF

    CALL TPSENSOR%BUFFER_PACK_STATPROF( PBUFFER, KPOS, ISTORES )

    PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XFF (:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XDD (:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XZZ (:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XTHV(:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    IF ( CCLOUD == 'C2R2' .OR. CCLOUD == 'KHKO' ) THEN
      PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XVISIGUL(:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    END IF
    IF ( CCLOUD /= 'NONE' .AND. CCLOUD /= 'REVE' ) THEN
      PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XVISIKUN(:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    END IF
    IF ( CCLOUD == 'ICE3' .OR. CCLOUD == 'ICE4' ) THEN
      PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XCIZ(:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    END IF
    PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XRHOD(:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES
    PBUFFER(KPOS:KPOS+IKU*ISTORES*NAER-1) = RESHAPE( TPSENSOR%XAER(:,1:ISTORES,:), [IKU*ISTORES*NAER] )
    KPOS = KPOS + IKU * ISTORES * NAER

    PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XIWV(1:ISTORES) ; KPOS = KPOS + ISTORES
    PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XZTD(1:ISTORES) ; KPOS = KPOS + ISTORES
    PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XZWD(1:ISTORES) ; KPOS = KPOS + ISTORES
    PBUFFER(KPOS:KPOS+ISTORES-1) = TPSENSOR%XZHD(1:ISTORES) ; KPOS = KPOS + ISTORES

    PBUFFER(KPOS:KPOS+IKU*ISTORES-1) = RESHAPE( TPSENSOR%XTKE_DISS(:,1:ISTORES), [IKU*ISTORES] ) ; KPOS = KPOS + IKU * ISTORES

  END SUBROUTINE BUFFER_PACK_PROFILER


  ! #######################################################################
  SUBROUTINE BUFFER_PACK_STATION( TPSENSOR, PBUFFER, KPOS, KSTORE_CURRENT )
  ! #######################################################################

    USE MODE_MSG

    CLASS(TSTATIONDATA),          INTENT(IN)    :: TPSENSOR
    REAL, DIMENSION(:),           INTENT(INOUT) :: PBUFFER        ! Buffer to pack
    INTEGER,                      INTENT(INOUT) :: KPOS           ! Position in the buffer
    INTEGER,            OPTIONAL, INTENT(IN)    :: KSTORE_CURRENT ! Current number of stored instants

    INTEGER :: ISTORES

    IF ( PRESENT( KSTORE_CURRENT ) ) THEN
      ISTORES = KSTORE_CURRENT
      IF ( ISTORES > TPSENSOR%NSTORE_MAX ) THEN
        CALL PRINT_MSG( NVERB_ERROR, 'GEN', 'Buffer_pack_flyer', 'flyer: ' // TRIM(TPSENSOR%CNAME) &
                        // ': KSTORE_CURRENT>NSTORE_MAX', OLOCAL = .TRUE. )
        ISTORES = TPSENSOR%NSTORE_MAX
      END IF
    ELSE
      ISTORES = TPSENSOR%NSTORE_MAX
    END IF

    CALL TPSENSOR%BUFFER_PACK_STATPROF( PBUFFER, KPOS, ISTORES )

    PBUFFER(KPOS) = TPSENSOR%NK     ; KPOS = KPOS + 1

    PBUFFER(KPOS) = TPSENSOR%XZS    ; KPOS = KPOS + 1
    PBUFFER(KPOS) = TPSENSOR%XZMEAS ; KPOS = KPOS + 1

  END SUBROUTINE BUFFER_PACK_STATION


  ! ##################################################################
  SUBROUTINE BUFFER_UNPACK_STATPROF( TPSENSOR, PBUFFER, KPOS, KSTORE )
  ! ##################################################################

    USE MODD_PARAM_n, ONLY: CRAD

    CLASS(TSTATPROFDATA), INTENT(INOUT) :: TPSENSOR
    REAL, DIMENSION(:),   INTENT(IN)    :: PBUFFER  ! Buffer to unpack
    INTEGER,              INTENT(INOUT) :: KPOS     ! Position in the buffer
    INTEGER,              INTENT(IN)    :: KSTORE   ! Current number of stored instants

    LOGICAL :: GISALLOC

    CALL TPSENSOR%BUFFER_UNPACK_SENSOR( PBUFFER, KPOS, KSTORE )

    ! Check if the arrays are allocated with a size > 0
    GISALLOC = ( SIZE( TPSENSOR%XT2M ) > 0 )

    IF ( GISALLOC ) THEN
      TPSENSOR%XT2M    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XQ2M    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XHU2M   = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XZON10M = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XMER10M = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XRN     = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XH      = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XLE     = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XLEI    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      TPSENSOR%XGFLUX  = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      IF ( CRAD /= 'NONE' ) THEN
        TPSENSOR%XSWD    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
        TPSENSOR%XSWU    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
        TPSENSOR%XLWD    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
        TPSENSOR%XLWU    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
        TPSENSOR%XSWDIR  = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
        TPSENSOR%XSWDIFF = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
        TPSENSOR%XDSTAOD = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
        TPSENSOR%XSLTAOD = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
      END IF
      TPSENSOR%XSFCO2    = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
    END IF

  END SUBROUTINE BUFFER_UNPACK_STATPROF


  ! ##################################################################
  SUBROUTINE BUFFER_UNPACK_PROFILER( TPSENSOR, PBUFFER, KPOS, KSTORE )
  ! ##################################################################

    USE MODD_DIM_n,         ONLY: NKMAX
    USE MODD_PARAMETERS,    ONLY: JPVEXT
    USE MODD_PARAM_n,       ONLY: CCLOUD
    USE MODD_RADIATIONS_n,  ONLY: NAER

    USE MODE_MSG

    CLASS(TPROFILERDATA), INTENT(INOUT) :: TPSENSOR
    REAL, DIMENSION(:),   INTENT(IN)    :: PBUFFER  ! Buffer to unpack
    INTEGER,              INTENT(INOUT) :: KPOS     ! Position in the buffer
    INTEGER,              INTENT(IN)    :: KSTORE   ! Current number of stored instants

    INTEGER :: IKU
    INTEGER :: JI

    IKU = NKMAX + 2 * JPVEXT

    CALL TPSENSOR%BUFFER_UNPACK_STATPROF( PBUFFER, KPOS, KSTORE )

    TPSENSOR%XFF (:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    TPSENSOR%XDD (:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    TPSENSOR%XZZ (:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    TPSENSOR%XTHV(:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    IF ( CCLOUD == 'C2R2' .OR. CCLOUD == 'KHKO' ) THEN
      TPSENSOR%XVISIGUL(:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    END IF
    IF ( CCLOUD /= 'NONE' .AND. CCLOUD /= 'REVE' ) THEN
      TPSENSOR%XVISIKUN(:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    END IF
    IF ( CCLOUD == 'ICE3' .OR. CCLOUD == 'ICE4' ) THEN
      TPSENSOR%XCIZ(:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    END IF
    TPSENSOR%XRHOD(:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE
    TPSENSOR%XAER(:,1:KSTORE,:) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE*NAER-1), [ IKU, KSTORE, NAER ] )
    KPOS = KPOS + IKU * KSTORE * NAER

    TPSENSOR%XIWV(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
    TPSENSOR%XZTD(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
    TPSENSOR%XZWD(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE
    TPSENSOR%XZHD(1:KSTORE) = PBUFFER(KPOS:KPOS+KSTORE-1) ; KPOS = KPOS + KSTORE

    TPSENSOR%XTKE_DISS(:,1:KSTORE) = RESHAPE( PBUFFER(KPOS:KPOS+IKU*KSTORE-1), [ IKU, KSTORE ] ) ; KPOS = KPOS + IKU * KSTORE

  END SUBROUTINE BUFFER_UNPACK_PROFILER

  ! #################################################################
  SUBROUTINE BUFFER_UNPACK_STATION( TPSENSOR, PBUFFER, KPOS, KSTORE )
  ! #################################################################

    USE MODE_MSG

    CLASS(TSTATIONDATA), INTENT(INOUT) :: TPSENSOR
    REAL, DIMENSION(:),  INTENT(IN)    :: PBUFFER  ! Buffer to unpack
    INTEGER,             INTENT(INOUT) :: KPOS     ! Position in the buffer
    INTEGER,             INTENT(IN)    :: KSTORE   ! Current number of stored instants

    CALL TPSENSOR%BUFFER_UNPACK_STATPROF( PBUFFER, KPOS, KSTORE )

    TPSENSOR%NK     = PBUFFER(KPOS) ; KPOS = KPOS + 1

    TPSENSOR%XZS    = PBUFFER(KPOS) ; KPOS = KPOS + 1
    TPSENSOR%XZMEAS = PBUFFER(KPOS) ; KPOS = KPOS + 1

  END SUBROUTINE BUFFER_UNPACK_STATION

END MODULE MODD_TYPE_STATPROF
