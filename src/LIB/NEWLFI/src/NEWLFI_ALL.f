!MNH_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
      SUBROUTINE ABOR2(CDTEXT)

      IMPLICIT LOGICAL (L)

      CHARACTER(LEN=*) :: CDTEXT

      ILEN=LEN(CDTEXT)
      WRITE(*,'(TR1,A)') 'ABOR2 CALLED'
      IF(ILEN.LE.512) THEN
        WRITE(*,'(TR1,A)') CDTEXT
        WRITE(*,'(TR1,A,TR1,A)') 'ABORT!! ',CDTEXT
      ELSE
        WRITE(*,'(TR1,A,TR1,A)') 'ABORT!! ',
     &   'ABOR2 CALLED WITHOUT TEXT STRING'
      ENDIF

      CLOSE(6)
      CLOSE(20)
#ifdef VPP
      CALL ERRTRA
      STOP 2
#else
      CALL ABORT
#endif

      RETURN
      END SUBROUTINE ABOR2
      SUBROUTINE LFICAS ( KREP, KNUMER, CDNOMA, KLONG, KPOSEX, LDAVAN )
#include "lficomt.h" 
C****
C        SOUS-PROGRAMME DONNANT LES CARACTERISTIQUES ( NOM, LONGUEUR,
C     POSITION ) DE L'ARTICLE LOGIQUE *DE DONNEES* SUIVANT, SUR UNE
C     UNITE LOGIQUE OUVERTE POUR LE LOGICIEL DE FICHIERS INDEXES *LFI* .
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE;
C                CDNOMA (SORTIE) ==> NOM DE L'ARTICLE SUIVANT;
C                KLONG  (SORTIE) ==> LONGUEUR DE L'ARTICLE SUIVANT;
C                KPOSEX (SORTIE) ==> POSITION ( DANS LE FICHIER, DU PRE-
C                                    MIER MOT ) DE L'ARTICLE SUIVANT;
C                LDAVAN (ENTREE) ==> VRAI SI ON DOIT "AVANCER" LE
C                                    POINTEUR DU FICHIER.
C
C     SI L'ON SOUHAITE LIRE ENSUITE L'ARTICLE EN QUESTION (VIA *LFILAS*)
C     IL FAUT PRECISER A L'APPEL LDAVAN=.FALSE. ; LDAVAN=.TRUE. SERT
C     ESSENTIELLEMENT A ANALYSER LE CONTENU DU FICHIER EN TERMES
C     D'ARTICLES LOGIQUES, SANS LIRE LES DONNEES.
C
C     SI LE FICHIER EST VIDE OU QUE LE DERNIER ARTICLE LOGIQUE LU ETAIT
C     LE DERNIER, LE SOUS-PROGRAMME "RETOURNE" KLONG=0, ET CDNOMA=' ' .
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
C
      CHARACTER CDNOMA*(*), CLNOMA*(JPNCPN)
C
      INTEGER KREP, KNUMER, KLONG, KPOSEX, IREP, ILCDNO, IDECBL, IPOSBL
      INTEGER ILCLNO, IRANG, IRGPIM, IARTIC, IRGPIF, INIMES, IRETIN
C
      LOGICAL LDAVAN, LLVERF
C
C
C       FONCTION SERVANT A RENDRE FATALE OU NON UNE ERREUR DETECTEE,
C       A L'AIDE DU CODE-REPONSE COURANT, DU NIVEAU DE FILTRAGE GLOBAL,
C       ET DE L'OPTION D'ERREUR FATALE PROPRE AU FICHIER.
C       S'IL N'Y A PAS DE FICHIER (I5678=0, D'OU DIMENSIONNEMENT DE
C          *LERFAT*), LE NIVEAU DE FILTRAGE JOUE LE ROLE PRINCIPAL.
C
      INTEGER IXNIMS, I1234, I5678, I3456, IXC, IXM, IXT, IABCDE, IFGHIJ
      INTEGER IKLMNO, IPQRST, IUVWXY, IZABCD, IEFGHI
C
      LOGICAL LLMOER
C
      LLMOER (I1234,I5678)=I1234.EQ.-16.OR.
     S (I1234.NE.0.AND.(NERFAG.EQ.0.OR.(NERFAG.EQ.1.AND.LERFAT(I5678))))
C
C       FONCTION DONNANT LE PLUS HAUT NIVEAU DE MESSAGERIE ACCEPTABLE
C       POUR L'UNITE LOGIQUE DE RANG "I3456" .
C       (UTILISATION DES NIVEAUX DE MESSAGERIE GLOBAL ET PROPRE AU
C        FICHIER - MEME REMARQUE QUE CI-DESSUS SI I3456=0, POUR NIVMES)
C
      IXNIMS (I3456)=MIN0 (2,2*NIMESG,MAX0 (2*NIMESG-2,NIVMES(I3456)))
C
C       Fonctions servant a l'adressage 1D dans les tableaux CNOMAR,
C     MLGPOS et MDES1D, MTAMPD.
C
      IXC (IABCDE,IFGHIJ) = IABCDE + JPNXNA * ( IFGHIJ - 1 )
      IXM (IKLMNO,IPQRST) = IKLMNO + JPLARD * ( IPQRST - 1 )
      IXT (IUVWXY,IZABCD,IEFGHI) = IUVWXY + JPLARD *
     S ( MFACTM(IEFGHI) * IZABCD + JPNPDF * ( IEFGHI - 1 ) )
C
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
C        Appel legerement anticipe a LFINUM, garantissant l'initialisa-
C     tion des variables globales du logiciel a la 1ere utilisation.
C
      CALL LFINUM (KNUMER,IRANG)
      LLVERF=.FALSE.
      IREP=0
      KLONG=0
      KPOSEX=0
      ILCDNO=LEN (CDNOMA)
C
      IF (ILCDNO.LE.0) THEN
        IREP=-15
        CLNOMA=CHINCO(:JPNCPN)
        ILCLNO=JPNCPN
        GOTO 1001
      ELSE
        CDNOMA=' '
        CLNOMA=' '
        ILCLNO=1
      ENDIF
C
      IF (IRANG.EQ.0) THEN
        IREP=-1
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
      LLVERF=LMULTI
C**
C     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
C            A LA RECHERCHE DE L'ARTICLE LOGIQUE DEMANDE,
C            DEFINI PAR SON RANG "A PRIORI" DANS LE FICHIER.
C-----------------------------------------------------------------------
C
      CALL LFICAX (IREP,IRANG,IRGPIM,IARTIC,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0.OR.IARTIC.EQ.0) THEN
        GOTO 1001
      ENDIF
C*
C     2.1 -  ARTICLE DE DONNEES TROUVE... APRES CONTROLES SUPPLEMENTAI-
C            RES, ON RETOURNE SES CARACTERISTIQUES.
C-----------------------------------------------------------------------
C
      IRGPIF=MRGPIF(IRGPIM)
C
      IF (.NOT.LPHASP(IRGPIM)) THEN
C
        CALL LFIPHA (IREP,IRANG,IRGPIM,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      KLONG=MLGPOS(IXM(2*IARTIC-1,IRGPIM))
      KPOSEX=MLGPOS(IXM(2*IARTIC,IRGPIM))
      CLNOMA=CNOMAR(IXC(IARTIC,IRGPIM))
C
C        Recherche de la longueur "utile" du nom d'article.
C        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
C
      IDECBL=0
C
  211 CONTINUE
      IPOSBL=IDECBL+INDEX (CLNOMA(IDECBL+1:),' ')
C
      IF (IPOSBL.LE.IDECBL) THEN
        ILCLNO=JPNCPN
      ELSEIF (CLNOMA(IPOSBL:).EQ.' ') THEN
        ILCLNO=IPOSBL-1
      ELSE
        IDECBL=IPOSBL
        GOTO 211
      ENDIF
C
      IF (ILCDNO.GE.ILCLNO) THEN
        CDNOMA=CLNOMA(:ILCLNO)
      ELSE
        IREP=-24
        CLACTI=CLNOMA
        GOTO 1001
      ENDIF
C
      IF (LDAVAN) THEN
C
C          ON AVANCE LE "POINTEUR" DU FICHIER...
C       ET ON REINITIALISE LES "POINTEURS" SUIVANT ET PRECEDENT.
C
        NDERGF(IRANG)=JPNAPP*MFACTM(IRANG)*(IRGPIF-1)+IARTIC
        CNDERA(IRANG)=CLNOMA
        NSUIVF(IRANG)=JPNIL
        NPRECF(IRANG)=JPNIL
      ENDIF
C
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      CLACTI='READ'
C
  909 CONTINUE
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      IREP=IABS (IREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (IRANG.NE.0) THEN
        NDEROP(IRANG)=11
        NDERCO(IRANG)=IREP
         IF (LLVERF) CALL LFIVER (VERRUE(IRANG),'OFF')
      ENDIF
C
      IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
        INIMES=2
      ELSE
        RETURN
      ENDIF
C
      CLNSPR='LFICAS'
      WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S    '', CDNOMA='''''',A,'''''', KLONG='',I7,'', KPOSEX='',I8,
     S    '', LDAVAN= '',L1)')
     S  KREP,KNUMER,CLNOMA(:ILCLNO),KLONG,KPOSEX,LDAVAN
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      RETURN
      END
      SUBROUTINE LFICAX ( KREP, KRANG, KRGPIM, KARTEX, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI;
C     RECHERCHE DE L'ARTICLE LOGIQUE *DE DONNEES* SUIVANT, DANS UNE
C     UNITE LOGIQUE DONNEE.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                KRGPIM (SORTIE) ==> RANG DANS LES TABLES CNOMAR,MLGPOS,
C                                    ETC. DE LA P.P.I OU FIGURE
C                                    L'ARTICLE ( 0 SI PAS TROUVE );
C                KARTEX (SORTIE) ==> RANG ( DANS LA PAGE D'INDEX ) DE L'
C                                    ARTICLE S'IL EXISTE ( 0 SINON );
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
C
      INTEGER KREP, KRANG, KRGPIM, KARTEX, IRANG, INBALO, INALPP, INTPPI
      INTEGER INPPIM, IDERGF, IRANGF, IRGPIF, IRGPIM, IRANGM, ILFORC, J
      INTEGER INPILE, IARTIK, IARTIC, IRETOU, INIMES, INUMER, INALPI
      INTEGER KRETIN, IRETIN
C
C
C       FONCTION SERVANT A RENDRE FATALE OU NON UNE ERREUR DETECTEE,
C       A L'AIDE DU CODE-REPONSE COURANT, DU NIVEAU DE FILTRAGE GLOBAL,
C       ET DE L'OPTION D'ERREUR FATALE PROPRE AU FICHIER.
C       S'IL N'Y A PAS DE FICHIER (I5678=0, D'OU DIMENSIONNEMENT DE
C          *LERFAT*), LE NIVEAU DE FILTRAGE JOUE LE ROLE PRINCIPAL.
C
      INTEGER IXNIMS, I1234, I5678, I3456, IXC, IXM, IXT, IABCDE, IFGHIJ
      INTEGER IKLMNO, IPQRST, IUVWXY, IZABCD, IEFGHI
C
      LOGICAL LLMOER
C
      LLMOER (I1234,I5678)=I1234.EQ.-16.OR.
     S (I1234.NE.0.AND.(NERFAG.EQ.0.OR.(NERFAG.EQ.1.AND.LERFAT(I5678))))
C
C       FONCTION DONNANT LE PLUS HAUT NIVEAU DE MESSAGERIE ACCEPTABLE
C       POUR L'UNITE LOGIQUE DE RANG "I3456" .
C       (UTILISATION DES NIVEAUX DE MESSAGERIE GLOBAL ET PROPRE AU
C        FICHIER - MEME REMARQUE QUE CI-DESSUS SI I3456=0, POUR NIVMES)
C
      IXNIMS (I3456)=MIN0 (2,2*NIMESG,MAX0 (2*NIMESG-2,NIVMES(I3456)))
C
C       Fonctions servant a l'adressage 1D dans les tableaux CNOMAR,
C     MLGPOS et MDES1D, MTAMPD.
C
      IXC (IABCDE,IFGHIJ) = IABCDE + JPNXNA * ( IFGHIJ - 1 )
      IXM (IKLMNO,IPQRST) = IKLMNO + JPLARD * ( IPQRST - 1 )
      IXT (IUVWXY,IZABCD,IEFGHI) = IUVWXY + JPLARD *
     S ( MFACTM(IEFGHI) * IZABCD + JPNPDF * ( IEFGHI - 1 ) )
C
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IRETOU=0
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI) THEN
        KREP=-16
        GOTO 1001
      ENDIF
C
      IRANG=KRANG
      KREP=0
      KRGPIM=0
      KARTEX=0
      INBALO=MDES1D(IXM(JPNALO,IRANG))
      INALPP=JPNAPP*MFACTM(IRANG)
      INTPPI=(INBALO-1+INALPP)/INALPP
      INPPIM=NPPIMM(IRANG)
C
      IF (NSUIVF(IRANG).EQ.JPNIL) THEN
C
C           ON N'A DONC PAS ENCORE APPELE CE SOUS-PROGRAMME POUR
C        RECHERCHER CET ARTICLE ( A PRIORI, VIA *LFICAS* ) .
C
        IF (NDERGF(IRANG).EQ.JPNIL) THEN
          IDERGF=0
        ELSE
          IDERGF=NDERGF(IRANG)
        ENDIF
C
        IF (IDERGF.GE.INBALO) THEN
          NSUIVF(IRANG)=0
          GOTO 1001
        ENDIF
C
        IRANGF=IDERGF+1
C
      ELSEIF (NSUIVF(IRANG).EQ.0) THEN
C
C        PLUS D'ARTICLE LOGIQUE A LIRE "SEQUENTIELLEMENT".
C
        GOTO 1001
      ELSEIF (NDERGF(IRANG).EQ.JPNIL.OR.
     S        NSUIVF(IRANG).GT.NDERGF(IRANG)) THEN
        IRANGF=NSUIVF(IRANG)
      ELSE
        KREP=-16
        GOTO 1001
      ENDIF
C**
C     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
C            A LA RECHERCHE DE L'ARTICLE LOGIQUE DEMANDE,
C            DEFINI PAR SON RANG "A PRIORI" DANS LE FICHIER.
C            ( MAIS IL FAUT "SAUTER" LES TROUS )
C-----------------------------------------------------------------------
C*
C     2.1 -  RECHERCHE DANS LES PAGES D'INDEX .
C-----------------------------------------------------------------------
C
      IRGPIF=1+(IRANGF-1)/INALPP
C
  211 CONTINUE
C
      IF (IRANGF.LE.INALPP) THEN
        IRGPIM=MRGPIM(1,IRANG)
        GOTO 215
      ELSEIF (IRANGF.GT.INALPP*(INTPPI-1)) THEN
        IRGPIM=MRGPIM(NPODPI(IRANG),IRANG)
        GOTO 215
      ENDIF
C
      DO 213 J=2,INPPIM
      IRGPIM=MRGPIM(J,IRANG)
      IF (MRGPIF(IRGPIM).EQ.IRGPIF) GOTO 215
  213 CONTINUE
C
C        MISE EN MEMOIRE DE L'ARTICLE D'INDEX "NOMS" CHERCHE.
C
      ILFORC=1
      INPILE=1
      CALL LFIPIM (KREP,IRANG,IRANGM,IRGPIM,IRGPIF,ILFORC,INPILE,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
      INPPIM=MAX0 (INPPIM,IRANGM)
C
  215 CONTINUE
      IARTIK=IRANGF-INALPP*(IRGPIF-1)
      INALPI=MIN0 (INALPP,INBALO-(IRGPIF-1)*INALPP)
C
C         ON CHERCHE LE PREMIER ARTICLE LOGIQUE *DE DONNEES* DE LA PAGE
C       D'INDEX, A PARTIR DU RANG *IARTIK* DANS CETTE PAGE.
C
      DO 216 J=IARTIK,INALPI
C
      IF (CNOMAR(IXC(J,IRGPIM)).NE.' ') THEN
        IARTIC=J
        GOTO 220
      ENDIF
C
  216 CONTINUE
C
C        CHOU BLANC POUR CETTE PAGE... A PRIORI, ON VA CHERCHER DANS
C     LA P.A.I. SUIVANTE, EN RANG DANS LE FICHIER.
C
      IF (IRGPIF.LT.INTPPI) THEN
        IRANGF=INALPP*IRGPIF+1
        IRGPIF=IRGPIF+1
        GOTO 211
      ENDIF
C
C    SI ON ARRIVE ICI, C'EST QUE LE DERNIER ARTICLE LOGIQUE EST UN TROU.
C
      NSUIVF(IRANG)=0
      GOTO 1001
C*
C     2.2 -  ARTICLE DE DONNEES REPERE, ON RENVOIE SES CARACTERISTIQUES.
C-----------------------------------------------------------------------
C
  220 CONTINUE
      KRGPIM=IRGPIM
      KARTEX=IARTIC
      NSUIVF(IRANG)=(IRGPIF-1)*INALPP+IARTIC
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
      KREP=IABS (KREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INUMER=NUMERO(KRANG)
        INIMES=2
        CLNSPR='LFICAX'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I3,
     S         '', KRGPIM='',I3,'', KARTEX='',I5,'', KRETIN='',I2)')
     S    KREP,KRANG,KRGPIM,KARTEX,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIDAH ( KDATE, KHEURE )
#include "lficomt.h"
C****
C     SOUS-PROGRAMME CHARGE DE DONNER LA DATE ET L'HEURE MACHINE
C     SOUS LA FORME D'ENTIERS .
C**
C     ARGUMENTS (SORTIE) KDATE  ==> DATE SOUS LA FORME AAMMJJ;
C                        KHEURE ==> HEURE SOUS LA FORME HHMMSS .
C
      CHARACTER CLAUXI*8
C
#ifndef f77
#include "precision.h"
      INTEGER (KIND=JPDBLE) KDATE, KHEURE
      CHARACTER CLAUXIT*10
      CHARACTER CLDIFF*5
      INTEGER KTIME(8)
#else
      INTEGER KDATE, KHEURE
#endif
      INTEGER IMOIS, IJOUR, IANNEE, IHEURE, IMINUT, ISECON
C
#ifndef f77
      CALL DATE_AND_TIME (CLAUXI,CLAUXIT,CLDIFF,KTIME)
      IANNEE=KTIME(1)
      IMOIS=KTIME(2)
      IJOUR=KTIME(3)
      IHEURE=KTIME(5)
      IMINUT=KTIME(6)
      ISECON=KTIME(7)
#else
#ifdef HP
      CALL IDATE (IMOIS,IJOUR,IANNEE)
      CALL TIME (CLAUXIT)
#else
      CALL DATE (CLAUXI)
      READ (UNIT=CLAUXI,FMT='(I2,2(TR1,I2))') IMOIS,IJOUR,IANNEE
      CALL CLOCK (CLAUXI)
#endif
      READ (UNIT=CLAUXI,FMT='(I2,2(TR1,I2))') IHEURE,IMINUT,ISECON
#endif
C
      KDATE=100*(100*IANNEE+IMOIS)+IJOUR
      KHEURE=100*(100*IHEURE+IMINUT)+ISECON
C
      RETURN
      END
      SUBROUTINE LFIECC ( KREP, KNUMER, KREC, CDTAB, KNBECR, KFACTM,
     S                    KRETIN )
#include "lficomt.h"
C****
C        Sous-programme charge des Ecritures de Chaines de Caracteres
C     du logiciel LFI (articles d'index "noms").
C**
C     Arguments: KREP   (Sortie) ==> Code-reponse ( zero si OK; code-
C                                    reponse du "WRITE" FORTRAN sinon);
C                KNUMER (Entree) ==> NUMERo d'unite logique FORTRAN;
C                KREC   (Entree) ==> Numero d'enregistrement a ecrire;
C                KTAB   (Sortie) ==> Zone a ecrire, de Longueur
C                                    JPLARD*KFACTM *mots*;
C                KNBECR (Entree  ==> Compteur d'ECRitures sur l'unite;
C                       +Sortie)
C                KFACTM (Entree) ==> FACteur Multiplicatif LFI de
C                                    l'unite logique;
C                KRETIN (Sortie) ==> Code-retour interne.
C
#include "lficom0.h"
C
      INTEGER KREP, KNUMER, KREC, KNBECR, KFACTM, KRETIN
C
      CHARACTER CDTAB (JPNXNA*KFACTM)*(JPNCPN)
C
C        ECRITURE .
C
      WRITE (UNIT=KNUMER,REC=KREC,ERR=901,IOSTAT=KREP) CDTAB
C
      IF (LMISOP) THEN
        PRINT *,'+++++ LFIECC - WRITE / ',KNUMER,', REC = ',KREC,
     S          ' +++++'
      ENDIF
C
      KNBECR=KNBECR+1
      KRETIN=0
      GOTO 1001
C
  901 CONTINUE
      KRETIN=1
C
 1001 CONTINUE
C
      RETURN
C
      END
      SUBROUTINE LFIECD ( KREP, KRANG, KTAB, KLONG, KPOSEC, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     ECRITURE DES DONNEES PROPREMENT DITES, UNE FOIS L'ARTICLE LOGIQUE
C     DEFINI (PAR NOM, OU PAR POSITION) .
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                KTAB   (ENTREE) ==> PREMIER MOT A ECRIRE;
C                KLONG  (ENTREE) ==> LONGUEUR DE L'ARTICLE A ECRIRE;
C                KPOSEC (ENTREE) ==> POSITION ( DANS LE FICHIER ) OU
C                                    COMMENCER A ECRIRE L'ARTICLE;
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP, KRANG, KLONG, KPOSEC, KRETIN
#ifndef f77
      INTEGER (KIND=JPDBLE)  KTAB (KLONG), IFOURT (JPLARX)
#else
      INTEGER KTAB (KLONG), IFOURT (JPLARX)
#endif
      INTEGER INUCPL (JPNPDF), INAPHY, INUMER, ILARPH, IPODEB, IPOFIN
      INTEGER IARDEB, IARFIN, IDCDEB, IDCFIN, ICPLTI, ICPLTF, ICPTTN
      INTEGER ICPTTX, INCPLT, INUMAP, J, JD, IDECDE, IPAREC, ITAMLI
      INTEGER INUMPJ, INUMPD, IARTIC, INPDRE, INPDTA, INPDIS, INDIK1
      INTEGER INDIK2, INDIC1, INDIC2, JI, IFACTM, IRETOU, INIMES
      INTEGER IRETIN
C
      LOGICAL LLADON, LLDERN
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IRETOU=0
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI.OR.KPOSEC.EQ.0)
     S     THEN
        KREP=-16
        GOTO 1001
      ENDIF
C
      INUMER=NUMERO(KRANG)
      IFACTM=MFACTM(KRANG)
      ILARPH=JPLARD*IFACTM
      KREP=0
C**
C     2.  -   PARTIE ECRITURE DES DONNEES .
C-----------------------------------------------------------------------
C*
C     2.1 - UTILISATION DES ARTICLES PHYSIQUES PRESENTS EN MEMOIRE,
C           ET QUE L'ON S'APPRETE A ECRIRE *EN ENTIER*.
C-----------------------------------------------------------------------
C
      IPODEB=KPOSEC
      IPOFIN=KPOSEC+KLONG-1
      IARDEB=1+(IPODEB-1)/ILARPH
      IARFIN=1+(IPOFIN-1)/ILARPH
      IDCDEB=MOD (IPODEB-1,ILARPH)
      IDCFIN=MOD (IPOFIN  ,ILARPH)
      LLDERN=IDCFIN.NE.0.AND.((IARFIN.NE.IARDEB)
     S                        .OR.(IARFIN.EQ.IARDEB.AND.IDCDEB.EQ.0))
      ICPLTI=IARDEB+(IDCDEB+ILARPH-1)/ILARPH
      ICPLTF=IARFIN-1+(ILARPH-IDCFIN)/ILARPH
      ICPTTN=ICPLTF+1
      ICPTTX=ICPLTI-1
      INCPLT=0
C
      IF (LMISOP) THEN
       PRINT *,'KPOSEC= ',KPOSEC,', IPODEB= ',IPODEB,', IPOFIN= ',IPOFIN
       PRINT *,'IARDEB= ',IARDEB,', IARFIN= ',IARFIN,', IDCDEB= ',IDCDEB
       PRINT *,'IDCFIN= ',IDCFIN,', ICPLTI= ',ICPLTI,', ICPLTF= ',ICPLTF
       PRINT *,'ICPTTN= ',ICPTTN,', ICPTTX= ',ICPTTX
      ENDIF
C
      IF (ICPLTF.GE.ICPLTI) THEN
C
        DO 212 J=0,JPNPDF-1
        INUMAP=NUMAPD(J,KRANG)
C
        IF (INUMAP.GE.ICPLTI.AND.INUMAP.LE.ICPLTF) THEN
          INCPLT=INCPLT+1
          INUCPL(INCPLT)=INUMAP
          ICPTTN=MIN0 (ICPTTN,INUMAP)
          ICPTTX=MAX0 (ICPTTX,INUMAP)
          IDECDE=(INUMAP-IARDEB)*ILARPH-IDCDEB
C
          DO 211 JD=1,ILARPH
          MTAMPD(IXT(JD,J,KRANG))=KTAB(IDECDE+JD)
  211     CONTINUE
C
          NLONPD(J,KRANG)=ILARPH
          LECRPD(J,KRANG)=.TRUE.
          IF (INCPLT.GT.(ICPLTF-ICPLTI)) GOTO 220
        ENDIF
C
  212   CONTINUE
C
      ENDIF
C
  220 CONTINUE
C*
C     2.2 - TRAITEMENT DE LA PREMIERE PAGE DE DONNEES, SI L'ARTICLE
C           LOGIQUE NE COMMENCE PAS JUSTE EN DEBUT D'ARTICLE PHYSIQUE.
C           CETTE PAGE EST CONSERVEE... DES FOIS QUE LE PROCHAIN ACCES
C           AU FICHIER SOIT POUR L'ARTICLE LOGIQUE IMMEDIATEMENT DEVANT
C           ( CAS DE BALAYAGE INVERSE DU FICHIER, PAR EXEMPLE ) .
C-----------------------------------------------------------------------
C
      IDECDE=0
C
      IF (IDCDEB.EQ.0) THEN
        IPAREC=0
        ITAMLI=JPNPDF
      ELSE
        IPAREC=MIN0 (ILARPH*IARDEB,IPOFIN)-KPOSEC+1
        ITAMLI=JPNPDF-1
C
C           L'ARTICLE DE DONNEES A ECRIRE NE COMMENCE PAS AU DEBUT D'UN
C         ARTICLE PHYSIQUE. IL FAUT DONC AVOIR CET ARTICLE PHYSIQUE
C         EN MEMOIRE POUR LE COMPLETER.
C
        DO 222 J=1,JPNPDF
        INUMPJ=MOD (NDERPD(KRANG)+J,JPNPDF)
C
        IF (NUMAPD(INUMPJ,KRANG).EQ.IARDEB) THEN
C
C           ARTICLE PHYSIQUE CHERCHE EN MEMOIRE.
C
          IF (NLONPD(INUMPJ,KRANG).LT.IDCDEB
     S        .AND.IARDEB.LE.MDES1D(IXM(JPAXPD,KRANG))) THEN
C
C           LA PAGE DE DONNEES EST INSUFFISAMMENT REMPLIE, ET A
C       UN ARTICLE ASSOCIE SUR FICHIER; IL FAUT DONC LIRE CET ARTICLE,
C       ET RECOLLER LES MORCEAUX...
C
            INAPHY=IARDEB
            CALL LFILDO (KREP,INUMER,IARDEB,IFOURT,NBREAD(KRANG),
     S                   IFACTM,IRETIN)
C
            IF (IRETIN.NE.0) THEN
              GOTO 904
            ENDIF
C
            DO 221 JD=NLONPD(INUMPJ,KRANG)+1,ILARPH
            MTAMPD(IXT(JD,INUMPJ,KRANG))=IFOURT(JD)
  221       CONTINUE
C
            NLONPD(INUMPJ,KRANG)=ILARPH
          ENDIF
C
          INUMPD=INUMPJ
          GOTO 223
        ENDIF
C
  222   CONTINUE
C
C     ARTICLE PHYSIQUE CHERCHE PAS EN MEMOIRE... ON DOIT DONC LE LIRE.
C
        INUMPD=MOD (1+NDERPD(KRANG),JPNPDF)
        INAPHY=0
C
        IF (LECRPD(INUMPD,KRANG)) THEN
C
          CALL LFIVID (KREP,KRANG,INUMPD,IFOURT,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        NUMAPD(INUMPD,KRANG)=JPNIL
        INAPHY=IARDEB
        CALL LFILDO (KREP,INUMER,IARDEB,MTAMPD(IXT(1,INUMPD,KRANG)),
     S               NBREAD(KRANG),IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 904
        ENDIF
C
        NUMAPD(INUMPD,KRANG)=IARDEB
        NLONPD(INUMPD,KRANG)=ILARPH
C
  223   CONTINUE
C
C         COMPLEMENT DE LA PAGE DE DONNEES ASSOCIEE AU PREMIER ARTICLE
C       PHYSIQUE OU DOIVENT ETRE STOCKEES LES DONNEES A ECRIRE.
C
        DO 224 JD=1,IPAREC
        MTAMPD(IXT(IDCDEB+JD,INUMPD,KRANG))=KTAB(JD)
  224   CONTINUE
C
        LECRPD(INUMPD,KRANG)=.TRUE.
        NLONPD(INUMPD,KRANG)=MAX0 (NLONPD(INUMPD,KRANG),IDCDEB+IPAREC)
        NDERPD(KRANG)=INUMPD
      ENDIF
C*
C     2.3 - ECRITURE DES ARTICLES PHYSIQUES COMPLETS NE TENANT PAS OU NE
C           DEVANT PAS ETRE STOCKES DANS LES PAGES DE DONNEES "TAMPON".
C           S'IL Y EN A, LES EVENTUELLES PAGES DE DONNEES COPIEES AUX
C           PARAGRAPHES PRECEDENTS (2.1 ET 2.2) PRECEDANT CES ARTICLES
C           DANS LE FICHIER SERONT ALORS ELLES AUSSI ECRITES SUR DISQUE.
C-----------------------------------------------------------------------
C
      IF (.NOT.LTAMPE(KRANG)) THEN
        ITAMLI=0
      ELSEIF (LLDERN) THEN
        ITAMLI=ITAMLI-1
      ENDIF
C
      IARTIC=ICPLTI-1
      INPDRE=(KLONG-IPAREC-IDCFIN+ILARPH-1)/ILARPH-INCPLT
      INPDTA=MIN0 (INPDRE,ITAMLI)
      INPDIS=INPDRE-ITAMLI
      INDIK1=1
      INDIK2=INCPLT
      LLADON=.TRUE.
C
      DO 235 J=1,INPDIS
C
  231 CONTINUE
      IARTIC=IARTIC+1
      IF (LMISOP) PRINT *,
     S 'BOUCLE 235, J= ',J,', IARTIC= ',IARTIC,', IDECDE= ',IDECDE
C
      IF (IARTIC.GE.ICPTTN.AND.IARTIC.LE.ICPTTX) THEN
        IF (IARTIC.EQ.ICPTTN) ICPTTN=ICPTTN+1
        IF (IARTIC.EQ.ICPTTX) ICPTTX=ICPTTX-1
        INDIC1=INDIK1
        INDIC2=INDIK2
C
C          ON FILTRE LES ARTICLES PHYSIQUES DEJA STOCKES DANS DES PAGES
C        DE DONNEES LORS DE LA PARTIE 2.1 ...
C
        DO 232 JI=INDIC1,INDIC2
C
        IF (IARTIC.EQ.INUCPL(JI)) THEN
          IF (JI.EQ.INDIK1+1) INDIK1=INDIK1+1
          IF (JI.EQ.INDIK2-1) INDIK2=INDIK2-1
          GOTO 231
        ENDIF
C
  232   CONTINUE
C
      ENDIF
C
      IDECDE=(IARTIC-IARDEB)*ILARPH-IDCDEB
      INAPHY=0
      CALL LFIECX (KREP,KRANG,IARTIC,KTAB(IDECDE+1),LLADON,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
  235 CONTINUE
C*
C     2.4 - ECRITURE DES ARTICLES PHYSIQUES COMPLETS QUE L'ON PEUT STOC-
C           KER DANS LES PAGES DE DONNEES "TAMPON".
C           ( TOUT EN PRESERVANT LES EMPLACEMENTS DE LA PREMIERE ET/OU
C             DE LA DERNIERE PAGE DE DONNEES, SI INCOMPLETE(S) )
C-----------------------------------------------------------------------
C
      DO 246 J=1,INPDTA
      INUMPD=MOD (NDERPD(KRANG)+J,JPNPDF)
C
  241 CONTINUE
      IARTIC=IARTIC+1
C
      IF (IARTIC.GE.ICPTTN.AND.IARTIC.LE.ICPTTX) THEN
        IF (IARTIC.EQ.ICPTTN) ICPTTN=ICPTTN+1
        IF (IARTIC.EQ.ICPTTX) ICPTTX=ICPTTX-1
        INDIC1=INDIK1
        INDIC2=INDIK2
C
C          ON FILTRE LES ARTICLES PHYSIQUES DEJA STOCKES DANS DES PAGES
C        DE DONNEES LORS DE LA PARTIE 2.1 ...
C
        DO 242 JI=INDIC1,INDIC2
C
        IF (IARTIC.EQ.INUCPL(JI)) THEN
          IF (JI.EQ.INDIK1+1) INDIK1=INDIK1+1
          IF (JI.EQ.INDIK2-1) INDIK2=INDIK2-1
          GOTO 241
        ENDIF
C
  242   CONTINUE
C
      ENDIF
C
C         SI NECESSAIRE, "VIDAGE" SUR FICHIER DE LA PAGE A UTILISER.
C
      INAPHY=0
C
      IF (LECRPD(INUMPD,KRANG)) THEN
C
        CALL LFIVID (KREP,KRANG,INUMPD,IFOURT,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      IDECDE=(IARTIC-IARDEB)*ILARPH-IDCDEB
C
      DO 245 JD=1,ILARPH
      MTAMPD(IXT(JD,INUMPD,KRANG))=KTAB(IDECDE+JD)
  245 CONTINUE
C
      LECRPD(INUMPD,KRANG)=.TRUE.
      NUMAPD(INUMPD,KRANG)=IARTIC
      NLONPD(INUMPD,KRANG)=ILARPH
  246 CONTINUE
C
      NDERPD(KRANG)=MOD (NDERPD(KRANG)+INPDTA,JPNPDF)
C*
C     2.5 - TRAITEMENT DE LA DERNIERE PAGE DE DONNEES SI ELLE EST
C           INCOMPLETE, ET SI ON EST DANS L'UN DES 2 CAS SUIVANTS:
C           SOIT ELLE DIFFERE DE LA PREMIERE, SOIT C'EST LA MEME QUE LA
C           PREMIERE ET ELLE COMMENCE JUSTE EN DEBUT D'ARTICLE PHYSIQUE.
C           CETTE PAGE EST CONSERVEE...EN ESPERANT QUE LE PROCHAIN ACCES
C           AU FICHIER SERA POUR L'ARTICLE LOGIQUE IMMEDIATEMENT
C           DERRIERE ( CAS DE CREATION DU FICHIER, PAR EXEMPLE ) .
C-----------------------------------------------------------------------
C
      IF (LLDERN) THEN
C
        DO 252 J=1,JPNPDF
        INUMPJ=MOD (NDERPD(KRANG)+J,JPNPDF)
C
        IF (NUMAPD(INUMPJ,KRANG).EQ.IARFIN) THEN
C
C           ARTICLE PHYSIQUE CHERCHE EN MEMOIRE.
C
          INUMPD=INUMPJ
          GOTO 253
        ENDIF
C
  252   CONTINUE
C
C           ARTICLE PHYSIQUE CHERCHE PAS EN MEMOIRE...
C
        INUMPD=MOD (1+NDERPD(KRANG),JPNPDF)
        INAPHY=0
C
        IF (LECRPD(INUMPD,KRANG)) THEN
C
          CALL LFIVID (KREP,KRANG,INUMPD,IFOURT,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        IF (IARFIN.LE.MDES1D(IXM(JPAXPD,KRANG))) THEN
          NUMAPD(INUMPD,KRANG)=JPNIL
          INAPHY=IARFIN
          CALL LFILDO (KREP,INUMER,IARFIN,MTAMPD(IXT(1,INUMPD,KRANG)),
     S                 NBREAD(KRANG),IFACTM,IRETIN)
C
          IF (IRETIN.NE.0) THEN
            GOTO 904
          ENDIF
C
          NLONPD(INUMPD,KRANG)=ILARPH
        ELSE
          NLONPD(INUMPD,KRANG)=0
        ENDIF
C
        NUMAPD(INUMPD,KRANG)=IARFIN
C
  253   CONTINUE
        IDECDE=(IARFIN-IARDEB)*ILARPH-IDCDEB
C
C         COMPLEMENT DE LA PAGE DE DONNEES ASSOCIEE AU DERNIER ARTICLE
C       PHYSIQUE OU DOIVENT ETRE STOCKEES LES DONNEES A ECRIRE.
C
        DO 254 JD=1,IDCFIN
        MTAMPD(IXT(JD,INUMPD,KRANG))=KTAB(IDECDE+JD)
  254   CONTINUE
C
        LECRPD(INUMPD,KRANG)=.TRUE.
        NLONPD(INUMPD,KRANG)=MAX0 (NLONPD(INUMPD,KRANG),IDCFIN)
        NDERPD(KRANG)=INUMPD
      ENDIF
C
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
      KREP=IABS (KREP)
      IF (INAPHY.NE.0) NUMAPH(KRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFIECD'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I3,
     S  '', KLONG='',I7,'', KPOSEC='',I8,'', KRETIN='',I2)')
     S   KREP, KRANG, KLONG, KPOSEC, KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIECR ( KREP, KNUMER, CDNOMA, KTAB, KLONG )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME D'ECRITURE D'UN ARTICLE (DE DONNEES) SUR UNE
C     UNITE LOGIQUE OUVERTE POUR LE LOGICIEL DE FICHIERS INDEXES LFI;
C     L'ARTICLE DOIT ETRE UN "BLOC" DE DONNEES ADJACENTES.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE;
C                CDNOMA (ENTREE) ==> NOM DE L'ARTICLE A ECRIRE;
C                KTAB   (ENTREE) ==> PREMIER MOT A ECRIRE
C                KLONG  (ENTREE) ==> LONGUEUR DE L'ARTICLE A ECRIRE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CDNOMA*(*), CLNOMA*(JPNCPN)
C
      INTEGER KREP, KNUMER, KLONG
#ifndef f77
      INTEGER (KIND=JPDBLE)  KTAB (KLONG)
#else
      INTEGER KTAB (KLONG)
#endif
      INTEGER IRANG, IREP, ILCLNO, IDECBL, IPOSBL, INBALO, INBPIR
      INTEGER IFACTM, ILARPH, INALPP, IRPIEX, IARTEX, ILONEX, IRPIEC
      INTEGER IARTEC, IPOSEC, IDTROU, ILONUT, INPPIM, IRETIN, IRGPI, J
      INTEGER IRGPIM, ILFORC, INPILE, INAPHY, IRANGM, INAPXX, INDMAX
      INTEGER IMDESC, INIMES, ILCDNO
C
      LOGICAL LLLECT, LLECR, LLVERF
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
C        Appel legerement anticipe a LFINUM, garantissant l'initialisa-
C     tion des variables globales du logiciel a la 1ere utilisation.
C
      CALL LFINUM (KNUMER,IRANG)
      LLVERF=.FALSE.
      ILCDNO=LEN (CDNOMA)
C
      IF (ILCDNO.LE.0) THEN
        IREP=-15
        CLNOMA=CHINCO(:JPNCPN)
        ILCLNO=JPNCPN
        GOTO 1001
      ELSEIF (CDNOMA.EQ.' ') THEN
        IREP=-18
        CLNOMA=' '
        ILCLNO=1
        GOTO 1001
      ENDIF
C
C        Recherche de la longueur "utile" du nom d'article specifie.
C        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
C
      IDECBL=0
C
  101 CONTINUE
      IPOSBL=IDECBL+INDEX (CDNOMA(IDECBL+1:),' ')
C
      IF (IPOSBL.LE.IDECBL) THEN
        ILCLNO=ILCDNO
      ELSEIF (CDNOMA(IPOSBL:).EQ.' ') THEN
        ILCLNO=IPOSBL-1
      ELSE
        IDECBL=IPOSBL
        GOTO 101
      ENDIF
C
      IF (ILCLNO.LE.JPNCPN) THEN
        CLNOMA=CDNOMA(:ILCLNO)
      ELSE
        CLNOMA=CDNOMA(:JPNCPN)
        ILCLNO=JPNCPN
        IREP=-15
        GOTO 1001
      ENDIF
C
      IF (KLONG.LE.0) THEN
        IREP=-14
        GOTO 1001
      ELSEIF (IRANG.EQ.0) THEN
        IREP=-1
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
      LLVERF=LMULTI
C
      IF (NEXPOR(IRANG).GT.0) THEN
C
C         Fichier en cours d'export... ne devant donc pas etre modifie.
C
        IREP=-37
        GOTO 1001
      ENDIF
C
      LLLECT=.TRUE.
      LLECR =.FALSE.
      INBALO=MDES1D(IXM(JPNALO,IRANG))
      INBPIR=MDES1D(IXM(JPNPIR,IRANG))
      IFACTM=MFACTM(IRANG)
      ILARPH=JPLARD*IFACTM
      INALPP=JPNAPP*IFACTM
C**
C     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
C            A LA RECHERCHE DE L'ARTICLE LOGIQUE ET/OU D'UN "TROU"
C            DANS L'INDEX, SUFFISANT POUR Y "CASER" LEDIT ARTICLE.
C-----------------------------------------------------------------------
C
      INAPHY=0
      CALL LFIREE (IREP,IRANG,CLNOMA(:ILCLNO),KLONG,IRPIEX,IARTEX,
     S             ILONEX,IRPIEC,IARTEC,IPOSEC,IDTROU,ILONUT,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
      INPPIM=NPPIMM(IRANG)
C
      IF (IARTEX.NE.0.AND.NEXPOR(IRANG).GT.0) THEN
C
C         Fichier en cours d'export... la seule modification acceptee
C         est l'ajout de nouveaux articles.
C
        IREP=-37
        GOTO 1001
      ENDIF
C**
C     3.  -   PARTIE ECRITURE DES DONNEES .
C-----------------------------------------------------------------------
C
      CALL LFIECD (IREP,IRANG,KTAB,KLONG,IPOSEC,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C**
C     4.  -   MODIFICATION(S) EVENTUELLE(S) DE L'INDEX.
C-----------------------------------------------------------------------
C
      IF (IARTEX.NE.0.AND.IARTEC.NE.IARTEX) THEN
C*
C     4.1 - CAS OU L'ON CREE UN TROU DANS L'INDEX.
C-----------------------------------------------------------------------
C
C           RECHERCHE OU MISE EN MEMOIRE DE L'ARTICLE D'INDEX "NOMS"
C        CONTENANT LES CARACTERISTIQUES DE L'ARTICLE LOGIQUE
C        QUE L'ON "TROUE".
C
        DO 411 J=1,INPPIM
        IRGPI=MRGPIM(J,IRANG)
C
        IF (MRGPIF(IRGPI).EQ.IRPIEX) THEN
          IRGPIM=IRGPI
          GOTO 413
        ENDIF
C
  411   CONTINUE
C
        ILFORC=1
        INPILE=1
        INAPHY=0
        CALL LFIPIM (IREP,IRANG,IRANGM,IRGPIM,IRPIEX,ILFORC,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
        INPPIM=MAX0 (INPPIM,IRANGM)
C
  413   CONTINUE
        CNOMAR(IXC(IARTEX,IRGPIM))=' '
        LECRPI(IRGPIM,1)=.TRUE.
C
        IF (ILONEX.NE.ILONUT) THEN
C
C           STOCKAGE DE LA LONGUEUR TOTALE UTILISABLE DU TROU .
C         DANS CE CAS, ON EST SUR QUE LA PAGE D'INDEX "LONG./POS."
C         EST TOUJOURS PHASEE.
C
          MLGPOS(IXM(2*IARTEX-1,IRGPIM))=ILONUT
          LECRPI(IRGPIM,2)=.TRUE.
        ENDIF
C
      ENDIF
C
      IF (INALPP*(IRPIEC-1)+IARTEC.GT.INBALO) THEN
C*
C     4.2 - CAS OU L'ON A CREE UN ARTICLE LOGIQUE SUPPLEMENTAIRE.
C-----------------------------------------------------------------------
C
        MDES1D(IXM(JPNALO,IRANG))=INBALO+1
C
        IF (INBALO.NE.0.AND.IARTEC.EQ.1) THEN
C
C             ON DOIT CREER UNE P.A.I. SUPPLEMENTAIRE.
C
          IF (IRPIEC.GT.INBPIR) THEN
C
C             CETTE NOUVELLE P.A.I. EST "EXCEDENTAIRE".
C             RECHERCHE DU PREMIER ARTICLE PHYSIQUE DISPONIBLE
C             POUR Y ECRIRE (ULTERIEUREMENT) CETTE P.A.I. EXCEDENTAIRE.
C             LE CONTROLE DE DEPASSEMENT DE CAPACITE DE L'INDEX
C             DU FICHIER A ETE FAIT DANS LE SOUS-PROGRAMME *LFIREE*.
C
            INAPXX=MDES1D(IXM(JPAXPD,IRANG))
            INDMAX=JPNIL
C
            DO 421 J=0,JPNPDF-1
C
            IF (NUMAPD(J,IRANG).GT.INAPXX) THEN
              INAPXX=NUMAPD(J,IRANG)
              INDMAX=J
            ENDIF
C
  421       CONTINUE
C
            IF (IRPIEC.GT.(INBPIR+1)) THEN
              IMDESC=MDES1D(IXM(ILARPH+2-IRPIEC+INBPIR,IRANG))
              INAPXX=MAX0 (INAPXX,IMDESC+1)
            ENDIF
C
            MDES1D(IXM(ILARPH+1-IRPIEC+INBPIR,IRANG))=INAPXX+1
C
C      L'ON A AUSSI CREE, EN GENERAL, UNE ZONE "PERDUE" (MAIS NEANMOINS
C     REUTILISABLE DANS UNE CERTAINE MESURE) A LA FIN DU DERNIER
C     ARTICLE PHYSIQUE DES DONNEES QUE L'ON VIENT D'ECRIRE.
C           IL EST ALORS NECESSAIRE DE "COMPLETER" LA ZONE PERDUE,
C     POUR NE PAS AVOIR DE PROBLEME ULTERIEUR DANS *LFIECX*.
C
            IF (INDMAX.NE.JPNIL) THEN
C
              DO 423 J=NLONPD(INDMAX,IRANG)+1,ILARPH
              MTAMPD(IXT(J,INDMAX,IRANG))=0
  423         CONTINUE
C
              NLONPD(INDMAX,IRANG)=ILARPH
            ENDIF
C
          ENDIF
C
          ILFORC=1
          INPILE=0
          INAPHY=0
          CALL LFIPIM (IREP,IRANG,IRANGM,IRGPIM,IRPIEC,ILFORC,INPILE,
     S                 IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
          NPODPI(IRANG)=IRANGM
C
C           REMARQUE: LA DERNIERE P.P.I. EST TOUJOURS "PHASEE".
C
          LPHASP(IRGPIM)=.TRUE.
        ELSE
          IRGPIM=MRGPIM(NPODPI(IRANG),IRANG)
        ENDIF
C
        NALDPI(IRANG)=IARTEC
        CNOMAR(IXC(IARTEC,IRGPIM))=CLNOMA(:ILCLNO)
        MLGPOS(IXM(2*IARTEC-1,IRGPIM))=KLONG
        MLGPOS(IXM(2*IARTEC  ,IRGPIM))=IPOSEC
        LECRPI(IRGPIM,1)=.TRUE.
        LECRPI(IRGPIM,2)=.TRUE.
C
      ELSEIF (IARTEX.EQ.0.OR.KLONG.NE.ILONEX) THEN
C*
C     4.3 - CAS OU L'ON REUTILISE UN ARTICLE OU TROU QUI EXISTAIT
C           AU PREALABLE, EN MODIFIANT SES CARACTERISTIQUES DE NOM ET/OU
C           DE LONGUEUR.
C-----------------------------------------------------------------------
C
        DO 431 J=1,INPPIM
        IRGPI=MRGPIM(J,IRANG)
C
        IF (MRGPIF(IRGPI).EQ.IRPIEC) THEN
          IRANGM=J
          IRGPIM=IRGPI
C
C           L'ARTICLE D'INDEX "NOMS" CORRESPONDANT EST EN MEMOIRE...
C       PHASAGE EVENTUEL DE LA PAGE D'INDEX "LONG/POS" .
C
          INAPHY=0
C
          IF (.NOT.LPHASP(IRGPIM)) THEN
C
            CALL LFIPHA (IREP,IRANG,IRGPIM,IRETIN)
C
            IF (IRETIN.EQ.1) THEN
              GOTO 903
            ELSEIF (IRETIN.EQ.2) THEN
              GOTO 904
            ELSEIF (IRETIN.NE.0) THEN
              GOTO 1001
            ENDIF
C
          ENDIF
C
          GOTO 434
        ENDIF
C
  431   CONTINUE
C
C            ARTICLE D'INDEX CORRESPONDANT NON PRESENT EN MEMOIRE...
C         ON L'Y AMENE.
C
        ILFORC=1
        INPILE=2
        INAPHY=0
        CALL LFIPIM (IREP,IRANG,IRANGM,IRGPIM,IRPIEC,ILFORC,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
  434   CONTINUE
C
        IF (IARTEC.NE.IARTEX.OR.IRPIEC.NE.IRPIEX) THEN
          CNOMAR(IXC(IARTEC,IRGPIM))=CLNOMA(:ILCLNO)
          LECRPI(IRGPIM,1)=.TRUE.
        ENDIF
C
        MLGPOS(IXM(2*IARTEC-1,IRGPIM))=KLONG
        LECRPI(IRGPIM,2)=.TRUE.
C
      ENDIF
C**
C     5.  -   MISE A JOUR: STATISTIQUES, TABLES, PAGE DOCUMENTAIRE.
C-----------------------------------------------------------------------
C
      IF (IARTEX.EQ.0) THEN
        NBNECR(IRANG)=NBNECR(IRANG)+1
      ELSEIF (KLONG.EQ.ILONEX) THEN
        NREESP(IRANG)=NREESP(IRANG)+1
      ELSEIF (KLONG.LT.ILONEX) THEN
        NREECO(IRANG)=NREECO(IRANG)+1
        LMIMAL(IRANG)=LMIMAL(IRANG).OR.
     S                ILONEX.EQ.MDES1D(IXM(JPLXAL,IRANG))
      ELSE
        NREELO(IRANG)=NREELO(IRANG)+1
        LMIMAL(IRANG)=LMIMAL(IRANG).OR.
     S                ILONEX.EQ.MDES1D(IXM(JPLNAL,IRANG))
      ENDIF
C
      NBTROU(IRANG)=NBTROU(IRANG)+IDTROU
      IF (LMISOP) PRINT *,
     S        'IDTROU = ',IDTROU,', ILONEX = ',ILONEX,', KLONG = ',KLONG
C
C        On met a jour ce qui a trait aux acces pseudo-sequentiels...
C
      NDERGF(IRANG)=INALPP*(IRPIEC-1)+IARTEC
      CNDERA(IRANG)=CLNOMA(:ILCLNO)
      NSUIVF(IRANG)=JPNIL
      NPRECF(IRANG)=JPNIL
C
      IMDESC=MDES1D(IXM(JPLNAL,IRANG))
      MDES1D(IXM(JPLNAL,IRANG))=MIN0 (IMDESC,KLONG)
      IMDESC=MDES1D(IXM(JPLXAL,IRANG))
      MDES1D(IXM(JPLXAL,IRANG))=MAX0 (IMDESC,KLONG)
      MDES1D(IXM(JPLTAL,IRANG))=MDES1D(IXM(JPLTAL,IRANG))+KLONG-ILONEX
      IF (INBALO.EQ.0) MDES1D(IXM(JPLNAL,IRANG))=KLONG
C
      IF (.NOT.LMODIF(IRANG)) THEN
C
C         CAS DE LA PREMIERE ECRITURE DEPUIS L'OUVERTURE DU FICHIER.
C
        LMODIF(IRANG)=.TRUE.
        INAPHY=0
        CALL LFIMOD (IREP,IRANG,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      IREP=0
      NBMOEC(IRANG)=NBMOEC(IRANG)+KLONG
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      CLACTI='READ'
C
  909 CONTINUE
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      IREP=IABS (IREP)
      IF (INAPHY.NE.0) NUMAPH(IRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (IRANG.NE.0) THEN
        NDEROP(IRANG)=1
        NDERCO(IRANG)=IREP
         IF (LLVERF) CALL LFIVER (VERRUE(IRANG),'OFF')
      ENDIF
C
      IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
        INIMES=2
      ELSE
        RETURN
      ENDIF
C
      CLNSPR='LFIECR'
      WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S       '', CDNOMA='''''',A,'''''', KLONG='',I7)')
     S     KREP,KNUMER,CLNOMA(:ILCLNO),KLONG
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      RETURN
      END
      SUBROUTINE LFIECX ( KREP, KRANG, KREC, KZONE, LDADON, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     ECRITURE SUR FICHIER D'UNE PAGE DE DONNEES OU D'INDEX LONG./POS.,
C     EN "BOUCHANT LES TROUS" SI ON N'ECRIT PAS A LA SUITE DU DERNIER
C     ARTICLE PRESENT SUR LE FICHIER, ET EN ESSAYANT D'ECRIRE DES ARTI-
C     CLES ADJACENTS SI ON N'ECRIT PAS UN ARTICLE (PHYSIQUE) "NOUVEAU".
C        CE S/P MET A JOUR LE NOMBRE D'ARTICLES PHYSIQUES DU FICHIER,
C     ET DANS LE CAS D'UN ARTICLE PHYSIQUE DE DONNEES, LE NUMERO MAXI.
C     D'ARTICLE PHYSIQUE DE DONNEES DU FICHIER.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DE L'ECRITURE FORTRAN;
C                KRANG  (ENTREE) ==> RANG EN MEMOIRE DE L'UNITE LOGIQUE;
C                KREC   (ENTREE) ==> NUMERO D'ENREGISTREMENT A ECRIRE;
C                KZONE  (ENTREE) ==> PREMIER MOT A ECRIRE;
C                LDADON (ENTREE) ==> VRAI SI ARTICLE DE DONNEES;
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
#ifndef f77
      INTEGER (KIND=JPDBLE) KZONE (JPLARX)
#else
      INTEGER KZONE (JPLARX)
#endif
      INTEGER KREP, KRANG, KREC, KRETIN
      INTEGER INADJA (2), IPOSAD (JPNPDF), IMDESC, INUMER, INPPIM, JREC
      INTEGER IPODPI, IFACTM, ILARPH, INALPP, INBPIR, INDIK1, INDIK2, J
      INTEGER INDIC1, INDIC2, INUMPD, INAPHY, IJ, IRGPIM, IRGPIF, IDEBSE
      INTEGER INDIS1, INDIS2, JSENS, ISENS, IREC, INUMAP, IRECX, INIMES
      INTEGER IRETOU, IRETIN
C
      LOGICAL LDADON, LLSAUT, LLFILT, LLLOIN
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES ET INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI) THEN
        INUMER=JPNIL
      ELSE
        INUMER=NUMERO(KRANG)
      ENDIF
C
      IRETOU=0
C
      IF (INUMER.EQ.JPNIL) THEN
        KREP=-14
        GOTO 1001
      ENDIF
C
      INAPHY=0
      LLSAUT=.FALSE.
      INPPIM=NPPIMM(KRANG)
      IPODPI=NPODPI(KRANG)
      IFACTM=MFACTM(KRANG)
      ILARPH=JPLARD*IFACTM
      INALPP=JPNAPP*IFACTM
      INBPIR=MDES1D(IXM(JPNPIR,KRANG))
      LLLOIN=KREC.GT.MDES1D(IXM(JPNAPH,KRANG))
C
      IF (LLLOIN) THEN
C**
C     2.  -  CAS OU L'ON ECRIT PLUS LOIN QUE LE DERNIER ARTICLE
C            EFFECTIVEMENT ECRIT SUR LE FICHIER.
C-----------------------------------------------------------------------
C
        INDIK1=1
        INDIK2=JPNPDF
C*
C     2.1 -  ECRITURE D'EVENTUELS ARTICLES ENTRE LE DERNIER PRESENT
C            SUR LE FICHIER, ET CELUI QUE L'ON DOIT ECRIRE.
C-----------------------------------------------------------------------
C
        DO 214 JREC=MDES1D(IXM(JPNAPH,KRANG))+1,KREC-1
C
        IF (LLSAUT) THEN
          LLSAUT=.FALSE.
          GOTO 213
        ENDIF
C
        INDIC1=INDIK1
        INDIC2=INDIK2
C
        DO 211 J=INDIC1,INDIC2
        INUMPD=MOD (NDERPD(KRANG)+J,JPNPDF)
C
        IF (NUMAPD(INUMPD,KRANG).EQ.JREC) THEN
          IF (J.EQ.INDIK1) INDIK1=INDIK1+1
          IF (J.EQ.INDIK2) INDIK2=INDIK2-1
          IF (LMISOP) PRINT *,'$$$ LFIECX - INUMPD= ',INUMPD,
     S          ', INDIK1= ', INDIK1,', INDIK2= ',INDIK2,' $$$'
C
C          ARTICLE PHYSIQUE TROUVE DANS LES PAGES DE DONNEES;
C       IL S'AGIT DONC D'UNE PAGE DE DONNEES NON ENCORE ECRITE,
C       ET FORCEMENT COMPLETE DANS CE CAS.
C
          IF (.NOT.LECRPD(INUMPD,KRANG)
     S        .OR.NLONPD(INUMPD,KRANG).NE.ILARPH) THEN
            KREP=-16
            GOTO 1001
          ENDIF
C
          INAPHY=JREC
          CALL LFIEDO (KREP,INUMER,JREC,MTAMPD(IXT(1,INUMPD,KRANG)),
     S                 NBWRIT(KRANG),IFACTM,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
          LECRPD(INUMPD,KRANG)=.FALSE.
          GOTO 213
        ELSEIF (NUMAPD(INUMPD,KRANG).LT.JREC) THEN
          IF (J.EQ.INDIK1) INDIK1=INDIK1+1
          IF (J.EQ.INDIK2) INDIK2=INDIK2-1
        ENDIF
C
  211   CONTINUE
C
C        CAS OU L'ARTICLE N'A PAS ETE TROUVE DANS LES PAGES DE DONNEES;
C        IL S'AGIT DONC D'UN ARTICLE D'INDEX "EXCEDENTAIRE", NON ENCORE
C        ECRIT, ET EN FAIT IL Y A DEUX ARTICLES CONSECUTIFS A ECRIRE.
C
        DO 212 J=1,INPPIM
C
C       ON COMMENCE EN FAIT LA RECHERCHE PAR LA DERNIERE P.P.I., CAR IL
C       Y A PRATIQUEMENT TOUTES LES CHANCES QUE CE SOIT CELLE CHERCHEE.
C       ( LA PREMIERE EST, PAR CONSTRUCTION, NON EXCEDENTAIRE )
C
        IF (J.EQ.1) THEN
          IJ=IPODPI
        ELSEIF (J.EQ.IPODPI) THEN
          GOTO 212
        ELSE
          IJ=J
        ENDIF
C
        IRGPIM=MRGPIM(IJ,KRANG)
        IRGPIF=MRGPIF(IRGPIM)
        IF (IRGPIF.LE.INBPIR) GOTO 212
        CALL LFIREC (IRGPIF,KRANG,IREC)
C
        IF (IREC.EQ.JREC) THEN
C
          IF (.NOT.LECRPI(IRGPIM,1).OR..NOT.LECRPI(IRGPIM,2)) THEN
            KREP=-16
            GOTO 1001
          ENDIF
C
          INAPHY=JREC
          CALL LFIECC (KREP,INUMER,JREC,CNOMAR(IXC(1,IRGPIM)),
     S                 NBWRIT(KRANG),IFACTM,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
          INAPHY=JREC+1
          CALL LFIEDO (KREP,INUMER,JREC+1,MLGPOS(IXM(1,IRGPIM)),
     S                 NBWRIT(KRANG),IFACTM,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
          LECRPI(IRGPIM,1)=IJ.NE.IPODPI.OR.NALDPI(KRANG).EQ.INALPP
          LECRPI(IRGPIM,2)=LECRPI(IRGPIM,1)
          LLSAUT=.TRUE.
          GOTO 213
        ENDIF
C
  212   CONTINUE
C
        PRINT *,'$$$ LFIECX - APRES ETIQUETTE 212, JREC= ',
     S              JREC,' NON TROUVE $$$'
        KREP=-16
        GOTO 1001
C
  213   CONTINUE
C
  214   CONTINUE
C
        IDEBSE=2
C
      ELSE
C
C       CAS OU L'ARTICLE PHYSIQUE A ECRIRE EXISTE DEJA SUR LE FICHIER.
C
        IDEBSE=1
C
      ENDIF
C**
C     3.  -  CAS "GENERAL" .
C-----------------------------------------------------------------------
C*
C     3.1 -  RECHERCHE D'ARTICLES PHYSIQUES ADJACENTS A ECRIRE,
C            PARMI LES PAGES DE DONNEES *COMPLETES* EXCLUSIVEMENT.
C-----------------------------------------------------------------------
C
      INDIS1=0
      INDIS2=JPNPDF-1
C
      DO 313 JSENS=IDEBSE,2
      ISENS=2*JSENS-3
      INADJA(JSENS)=(JPNPDF+1)*(JSENS-1)
      IF (.NOT.LDADON.AND.JSENS.EQ.2) GOTO 320
      INDIK1=INDIS1
      INDIK2=INDIS2
      IREC=KREC
C
  311 CONTINUE
      IREC=IREC+ISENS
      INDIC1=INDIK1
      INDIC2=INDIK2
C
      DO 312 J=INDIC1,INDIC2
      INUMAP=NUMAPD(J,KRANG)
      LLFILT=LECRPD(J,KRANG).AND.NLONPD(J,KRANG).EQ.ILARPH
C
      IF (LLFILT.AND.INUMAP.EQ.IREC) THEN
        INADJA(JSENS)=INADJA(JSENS)-ISENS
        IPOSAD(INADJA(JSENS))=J
        IF (J.EQ.INDIK1) INDIK1=INDIK1+1
        IF (J.EQ.INDIK2) INDIK2=INDIK2-1
        IF (J.EQ.INDIS1) INDIS1=INDIS1+1
        IF (J.EQ.INDIS2) INDIS2=INDIS2-1
        GOTO 311
      ELSEIF(.NOT.LLFILT.OR.INUMAP.EQ.KREC
     S       .OR.IABS (INUMAP-KREC).GT.JPNPDF) THEN
        IF (J.EQ.INDIS1) INDIS1=INDIS1+1
        IF (J.EQ.INDIS2) INDIS2=INDIS2-1
      ELSEIF(INUMAP*ISENS.LT.IREC*ISENS) THEN
        IF (J.EQ.INDIK1) INDIK1=INDIK1+1
        IF (J.EQ.INDIK2) INDIK2=INDIK2-1
      ENDIF
C
  312 CONTINUE
C
  313 CONTINUE
C*
C     3.2 -  ECRITURE DES (EVENTUELS) ARTICLES ADJACENTS DE NUMERO
C            *INFERIEUR* A CELUI QUE LE SOUS-PROGRAMME DOIT ECRIRE.
C-----------------------------------------------------------------------
C
  320 CONTINUE
C
      IF (.NOT.LLLOIN) THEN
        IREC=KREC-INADJA(1)
C
        DO 321 J=INADJA(1),1,-1
        IJ=IPOSAD(J)
        INAPHY=IREC
        CALL LFIEDO (KREP,INUMER,IREC,MTAMPD(IXT(1,IJ,KRANG)),
     S               NBWRIT(KRANG),IFACTM,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
        LECRPD(IJ,KRANG)=.FALSE.
        IREC=IREC+1
  321   CONTINUE
C
      ENDIF
C*
C     3.3 -  ECRITURE DE L'ARTICLE DEMANDE.
C-----------------------------------------------------------------------
C
      INAPHY=KREC
      CALL LFIEDO (KREP,INUMER,KREC,KZONE,NBWRIT(KRANG),IFACTM,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
C*
C     3.4 -  ECRITURE DES (EVENTUELS) ARTICLES ADJACENTS DE NUMERO
C            *SUPERIEUR* A CELUI QUE LE SOUS-PROGRAMME DOIT ECRIRE.
C-----------------------------------------------------------------------
C
      IREC=KREC
C
      DO 341 J=JPNPDF,INADJA(2),-1
      IREC=IREC+1
      IJ=IPOSAD(J)
      INAPHY=IREC
      CALL LFIEDO (KREP,INUMER,IREC,MTAMPD(IXT(1,IJ,KRANG)),
     S             NBWRIT(KRANG),IFACTM,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
      LECRPD(IJ,KRANG)=.FALSE.
  341 CONTINUE
C
      IRECX=KREC+JPNPDF-INADJA(2)+1
C**
C     4.  -  DANS LE CAS D'UN ARTICLE DE DONNEES, MISE A JOUR DU NUMERO
C            MAXI D'ENREGISTREMENT DE CES ARTICLES PHYSIQUES, ET DANS
C            TOUS LES CAS MISE A JOUR DU NOMBRE D'ARTICLES PHYSIQUES.
C-----------------------------------------------------------------------
C
      IF (LDADON) THEN
        IMDESC=MDES1D(IXM(JPAXPD,KRANG))
        MDES1D(IXM(JPAXPD,KRANG))=MAX0 (IMDESC,IRECX)
      ENDIF
C
      IMDESC=MDES1D(IXM(JPNAPH,KRANG))
      MDES1D(IXM(JPNAPH,KRANG))=MAX0 (IMDESC,IRECX)
      KREP=0
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTE DE BRANCHEMENT EN CAS D'ERREUR ECR.
C           ON FORCE LE CODE DE RETOUR A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      KREP=IABS (KREP)
      NUMAPH(KRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFIECX'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I5,'', KRANG='',I3,
     S       '', KREC='',I6,'', LDADON='',L2,'', KRETIN='',I2)')
     S    KREP,KRANG,KREC,LDADON,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIEDO ( KREP, KNUMER, KREC, KTAB, KNBECR, KFACTM,
     S                    KRETIN )
#include "lficomt.h"
C****
C        Sous-programme charge des Ecritures de DOnnees du logiciel LFI,
C     *SAUF* pour les articles d'index de TYPE caractere.
C**
C     Arguments: KREP   (Sortie) ==> Code-reponse ( zero si OK; code-
C                                    reponse du "WRITE" FORTRAN sinon);
C                KNUMER (Entree) ==> NUMERo d'unite logique FORTRAN;
C                KREC   (Entree) ==> Numero d'enregistrement a ecrire;
C                KTAB   (Sortie) ==> Zone a ecrire, de Longueur
C                                    JPLARD*KFACTM *mots*;
C                KNBECR (Entree  ==> Compteur d'ECRitures sur l'unite;
C                       +Sortie)
C                KFACTM (Entree) ==> FACteur Multiplicatif LFI de
C                                    l'unite logique;
C                KRETIN (Sortie) ==> Code-retour interne.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
C
      INTEGER KREP, KNUMER, KREC, KNBECR, KFACTM, KRETIN
C
      INTEGER (KIND=JPDBLE)  KTAB (JPLARD*KFACTM)
#ifdef SWAPIO
      INTEGER(KIND=JPDBLE)  KTABTMP (JPLARD*KFACTM)
#endif
#else
      INTEGER KTAB (JPLARD*KFACTM)
#endif
C
C        ECRITURE .
C

#if defined(SWAPIO) && !defined(f77)       
      call SWAP8(KTABTMP,KTAB,JPLARD*KFACTM)
      WRITE (UNIT=KNUMER,REC=KREC,ERR=901,IOSTAT=KREP) KTABTMP
#else
      WRITE (UNIT=KNUMER,REC=KREC,ERR=901,IOSTAT=KREP) KTAB
#endif
C
      IF (LMISOP) THEN
        PRINT *,'+++++ LFIEDO - WRITE / ',KNUMER,', REC = ',KREC,
     S          ' +++++'
      ENDIF
C
      KNBECR=KNBECR+1
      KRETIN=0
      GOTO 1001
C
  901 CONTINUE
      KRETIN=1
C
 1001 CONTINUE
C
      RETURN
C
      END
      SUBROUTINE LFIEFR ( KNUMER, KNIMES, KCODE, LDFATA, CDMESS, CDNSPR,
     S                    CDACTI )
#include "lficomt.h"
C****
C        CE SOUS-PROGRAMME EST CHARGE DE FAIRE L'IMPRESSION DES MESSAGES
C     STANDARD EMIS PAR LE LOGICIEL DE FICHIERS INDEXES LFI, EN FAISANT
C     SI BESOIN EST L'"ABORT" DU PROGRAMME .
C        Les messages lies au mode "mise au point" sont emis directement
C     par les sous-programmes concernes.
C
C        Ce sous-programme est la V.O. (Version Originale, francaise),
C     et est appele par le sous-programme "chapeau" LFIEMS.
C     Pour la version anglaise, voir LFIENG.
C     ( For english version see subroutine LFIENG )
C**
C        ARGUMENTS : KNUMER ==> Numero eventuel de l'Unite Logique;
C        ( tous                 ( si JPNIL ==> pas d'Unite Logique )
C         d'Entree ) KNIMES ==> Niveau (0,1,2) du Message;
C                    KCODE  ==> Code correspondant a l'action en cause;
C                    LDFATA ==> Vrai si on doit avorter le programme;
C                    CDMESS ==> Si KNIMES#0, Message a emettre;
C                    CDNSPR ==> Nom du sous-programme appelant LFIEMS;
C                    CDACTI ==> Nom de l'action d'entree/sortie FORTRAN
C                               si KCODE >0), sinon fourre-tout (!) .
C*
C     !----------------------------------------------------------------!
C     ! TABLE DES VALEURS POSSIBLES DES CODES-REPONSES DU LOGICIEL LFI !
C     !----------------------------------------------------------------!
C
C-----------------------------------------------------------------------
C      0 ==> Aucune erreur n'a ete detectee, tout est OK.
C-----------------------------------------------------------------------
C valeur ==> Il s'agit (de la valeur absolue) du code-reponse FORTRAN
C positive   d'une instruction OPEN, READ, WRITE, CLOSE ou INQUIRE; pour
C            le sens exact voir le manuel de reference du constructeur.
C-----------------------------------------------------------------------
C     -1 ==> Unite Logique non ouverte pour le logiciel.
C-----------------------------------------------------------------------
C     -2 ==> Valeur d'un "NIVEAU" hors plage [0-2] .
C-----------------------------------------------------------------------
C     -3 ==> Option de verrou erronee (s/p a usage interne "LFIVER") .
C-----------------------------------------------------------------------
C     -4 ==> Changement explicite de mode Multi-Taches avec au moins une
C            unite logique ouverte-risque de problemes (s/p "LFIINI") .
C-----------------------------------------------------------------------
C     -5 ==> Unite Logique deja ouverte (LFIOUV, LFIAFM, LFISFM) .
C-----------------------------------------------------------------------
C     -6 ==> Pas assez de place dans les tables pour ouvrir l'Unite
C            Logique demandee (LFIOUV) .
C-----------------------------------------------------------------------
C     -7 ==> Argument illicite de "STATUS" pour l'instruction FORTRAN
C            "OPEN" (LFIOUV) .
C-----------------------------------------------------------------------
C     -8 ==> Incompatibilite entre "LDNOMM" et "CDSTTO" (LFIOUV) :
C            un fichier de "STATUS" 'OLD' ou 'NEW' doit etre nomme .
C            (CE CODE-REPONSE N'A PLUS DE SENS ACTUELLEMENT)
C-----------------------------------------------------------------------
C     -9 ==> Incompatibilite entre le "STATUS" 'NEW' ou 'OLD' et (respe-
C            ctivement) l'existence ou non du fichier (LFIOUV) .
C-----------------------------------------------------------------------
C    -10 ==> Le fichier considere n'est pas un fichier de TYPE LFI, ou
C            ne peut pas etre traite par cette version du logiciel.
C            (LFIOUV)
C-----------------------------------------------------------------------
C    -11 ==> Fichier non ferme apres une modification (LFIOUV): cette
C            erreur n'est pas fatale si "LDERFA" est .FALSE., mais alors
C            integrite et coherence des donnees ne sont pas garanties.
C            Noter qu'une fois qu'un fichier a ce type de probleme, ce
C            code-reponse restera meme apres modification ulterieure.
C-----------------------------------------------------------------------
C    -12 ==> Fichier de "STATUS" 'OLD' mais erreur sur la lecture du
C            premier article physique du fichier (LFIOUV) .
C-----------------------------------------------------------------------
C    -13 ==> Fichier deja ouvert pour une autre unite logique LFI.
C            (LFIOUV)
C-----------------------------------------------------------------------
C    -14 ==> Argument d'appel de TYPE ENTIER incorrect (souvent negatif)
C-----------------------------------------------------------------------
C    -15 ==> Argument d'appel de type CARACTERE incorrect (longueur).
C-----------------------------------------------------------------------
C    -16 ==> Incoherence Tables, Fichier, appels s/p internes, logiciel.
C            CETTE ERREUR NE PEUT PAS ETRE FILTREE. EST TOUJOURS FATALE.
C-----------------------------------------------------------------------
C    -17 ==> Trop d'articles logiques sur le fichier pour un de plus.
C            (par articles logiques on entend ceux lisibles par l'utili-
C             sateur, mais aussi les trous reperes dans l'index... qui
C             sont crees lors de reecritures d'articles de donnees ne
C             pouvant se faire sur place, et lors de suppression d'arti-
C             cles; ces trous peuvent etre "recycles" - LFIECR)
C-----------------------------------------------------------------------
C    -18 ==> Nom d'Article logique compose uniquement de BLANCS illicite
C            (pour le fonctionnement interne du logiciel LFI,
C             les trous d'index sont reperes par un nom d'article blanc)
C-----------------------------------------------------------------------
C    -19 ==> Un fichier ouvert avec le "STATUS" 'SCRATCH' ne peut pas
C            etre conserve: "CDSTTC" a 'KEEP' est illicite (LFIFER) .
C            si cette erreur n'est pas fatale, alors on execute un
C            "CLOSE" FORTRAN sans parametre "STATUS", de la meme maniere
C            que lorsque "CDSTTC" n'est ni a 'KEEP' ni a 'DELETE'.
C-----------------------------------------------------------------------
C    -20 ==> L'article logique demande n'existe pas dans le fichier.
C            (LFILEC, LFIREN, LFISUP)
C-----------------------------------------------------------------------
C    -21 ==> L'article logique demande est PLUS LONG sur le fichier;
C            si cette erreur n'est pas fatale, le resultat est une
C            lecture PARTIELLE de l'article, a la longueur demandee.
C            (LFILAP, LFILAS, LFILEC)
C-----------------------------------------------------------------------
C    -22 ==> L'article logique demande est PLUS COURT sur le fichier;
C            meme si cette erreur n'est pas fatale, AUCUNE LECTURE DE
C            DONNEES N'EST FAITE (LFILAP, LFILAS, LFILEC) .
C-----------------------------------------------------------------------
C    -23 ==> Il n'y a pas ou plus d'article "SUIVANT" a lire (LFILAS) .
C-----------------------------------------------------------------------
C    -24 ==> La variable caractere donnee en argument d'appel de sortie
C            est TROP COURTE pour y stocker le NOM de l'article, meme en
C            supprimant d'eventuels caracteres blancs en fin de nom.
C            (LFICAP, LFICAS, LFILAP, LFILAS)
C-----------------------------------------------------------------------
C    -25 ==> Le nouveau nom de l'article logique est (deja) celui d'un
C            autre article logique du fichier (LFIREN).
C-----------------------------------------------------------------------
C    -26 ==> Il n'y a pas ou plus d'article "PRECEDENT" a lire (LFILAP).
C-----------------------------------------------------------------------
C    -27 ==> Espace CONTIGU insuffisant dans les tables pour gerer le
C            fichier "multiple" demande (LFIOUV) .
C-----------------------------------------------------------------------
C    -28 ==> Facteur multiplicatif (de la longueur d'article physique
C            elementaire) trop grand pour la configuration du logiciel.
C            (LFIOUV, LFIAFM, LFIFMD)
C-----------------------------------------------------------------------
C    -29 ==> Pas assez de place dans les tables pour definir le facteur
C            multiplicatif a associer a l'Unite Logique (LFIAFM) .
C-----------------------------------------------------------------------
C    -30 ==> Numero d'Unite Logique FORTRAN illicite.
C-----------------------------------------------------------------------
C    -31 ==> Numero d'Unite Logique sans facteur multiplicatif predefini
C            (LFISFM)
C-----------------------------------------------------------------------
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KNUMER, KNIMES, KCODE, ILDMES, ILBLAN, INLNOM, INUMER
      INTEGER IDECBL, IPOSBL, ILACTI, ILACT2, ILNSPR, ILMESU, IJL, J, IJ
      INTEGER INBALO, ILMESA, INLIGN, IDECAL
C
      LOGICAL LDFATA
C
      CHARACTER  CDNSPR*(*), CLJOLI*6, CDMESS*(*), CLMESA*80, CDACTI*(*)
C
#include "lficom2.h"
C**
C     1.  -  INITIALISATIONS.
C-----------------------------------------------------------------------
C
C        Recherche de la longueur "utile" de l'argument CDACTI.
C        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
C
      IDECBL=0
C
  101 CONTINUE
      IPOSBL=IDECBL+INDEX (CDACTI(IDECBL+1:),' ')
C
      IF (IPOSBL.LE.IDECBL) THEN
        ILACTI=LEN (CDACTI)
      ELSEIF (CDACTI(IPOSBL:).EQ.' ') THEN
        ILACTI=IPOSBL-1
      ELSE
        IDECBL=IPOSBL
        GOTO 101
      ENDIF
C
      ILACT2=MIN0 (ILACTI,JPNCPN)
      ILACTI=MIN0 (ILACT2,8)
      ILNSPR=MIN0 (LEN (CDNSPR),JPLSPX)
C
C        Prefixe (et eventuellement suffixe) pour le(s) message(s).
C
      IF (LDFATA) THEN
        CLJOLI=' *****'
      ELSEIF (KNIMES.EQ.0.OR.KCODE.NE.0) THEN
        CLJOLI=' */*/*'
      ELSE
        CLJOLI=' /////'
      ENDIF
C
      IF (KNIMES.NE.0) THEN
C**
C     2.  -  ON IMPRIME LE MESSAGE PREPARE PAR LE S/P APPELLANT LFIEMS.
C-----------------------------------------------------------------------
C
        ILMESU=MIN0 (LEN (CLMESS)-LEN (CLJOLI)-ILNSPR-4,LEN (CDMESS))
        CLMESS=CLJOLI//' '//CDNSPR(1:ILNSPR)//' - '//CDMESS(1:ILMESU)
        WRITE (UNIT=*,FMT='(A)') CLMESS
      ENDIF
C
      IF (KNIMES.EQ.0.OR.LDFATA) THEN
C**
C     3.  -  CONSTITUTION D'UN MESSAGE "AD HOC", EN FONCTION DE *KCODE*.
C-----------------------------------------------------------------------
C
C     En preambule, on cherche si l'unite logique concernee correspond
C     ou non a une unite logique ouverte pour le logiciel LFI.
C
        IF (KNUMER.EQ.JPNIL) THEN
          IJL=0
        ELSE
C
          DO 301 J=1,NBFIOU
          IJL=NUMIND(J)
          IF (KNUMER.EQ.NUMERO(IJL)) GOTO 302
  301     CONTINUE
C
          IJL=0
        ENDIF
C
  302   CONTINUE
C
        IF (KCODE.GT.0) THEN
C
          IF ((CDACTI.EQ.'READ'.OR.CDACTI.EQ.'WRITE')
     S        .AND.NUMAPH(IJL).GT.0) THEN
            WRITE (UNIT=CLMESS,FMT='(''ERREUR "'',A,''"'',I7,
     S             '',UNITE'',I3,'',NUM.ART'',I6,'',*'',I6,
     S             '' MOTS'')') CDACTI(1:ILACTI),KCODE,KNUMER,
     S                           NUMAPH(IJL),JPLARD*MFACTM(IJL)
          ELSE
            WRITE (UNIT=CLMESS,FMT='(''ERREUR "'',A,''" FORTRAN, CODE=''
     S             ,I7,'', UNITE='',I3)') CDACTI(1:ILACTI),KCODE,KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-1) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNITE LOGIQUE'',I3,
     S           '' NON OUVERTE POUR LE LOGICIEL LFI'')') KNUMER
C
        ELSEIF (KCODE.EQ.-2) THEN
C
          IF (KNUMER.EQ.JPNIL) THEN
            CLMESS='PARAMETRE DE NIVEAU "KNIVAU" HORS PLAGE [0-2]'
          ELSE
            WRITE (UNIT=CLMESS,FMT=
     S   '(''NIVEAU DE MESSAGERIE HORS PLAGE [0-2], UNITE'',I3)') KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-3) THEN
          ILDMES=MIN0 (8,LEN (CDMESS))
          CLMESS='ACTION '''//CDMESS(1:ILDMES)
     S           //''' INCONNUE SUR LES VERROUS'
C
        ELSEIF (KCODE.EQ.-4) THEN
          CLMESS='CHANGEMENT MODE MULTI-TACHES AVEC UNITE(S) OUVERTE(S)'
C
        ELSEIF (KCODE.EQ.-5) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNITE LOGIQUE'',I3,
     S           '' DEJA OUVERTE POUR LFI - NE DEVRAIT PAS.'')') KNUMER
C
        ELSEIF (KCODE.EQ.-6) THEN
          WRITE (UNIT=CLMESS,FMT='(I3,'' ENTREES,'',
     S    '' PLUS ASSEZ DE PLACE DANS LES TABLES, UNITE'',I3)')
     S    JPNXFI,KNUMER
C
        ELSEIF (KCODE.EQ.-7) THEN
          WRITE (UNIT=CLMESS,FMT='(''STATUS FORTRAN '''''',A,
     S           '''''' INCONNU, UNITE'',I3)') CDACTI(1:ILACTI),KNUMER
C
        ELSEIF (KCODE.EQ.-8) THEN
          WRITE (UNIT=CLMESS,FMT='(''L''''UNITE'',I3,'' DE STATUS ''''''
     S,A,'''''' DOIT AVOIR UN NOM EXPLICITE'')') KNUMER,CDACTI(1:ILACTI)
C
        ELSEIF (KCODE.EQ.-9) THEN
C
        IF (CDACTI.EQ.'OLD') THEN
          WRITE (UNIT=CLMESS,FMT=
     S'(''STATUS ''''OLD'''' MAIS LE FICHIER N''''EXISTE PAS, UNITE'',
     S      I3)') KNUMER
        ELSE
          ILBLAN=INDEX (CDACTI(1:ILACTI),' ')
          IF (ILBLAN.GT.1) ILACTI=ILBLAN-1
          WRITE (UNIT=CLMESS,FMT=
     S'(''STATUS '''''',A,'''''' MAIS LE FICHIER EXISTE DEJA, UNITE'',
     S  I3)') CDACTI(1:ILACTI),KNUMER
        ENDIF
C
        ELSEIF (KCODE.EQ.-10) THEN
          WRITE (UNIT=CLMESS,FMT='(''INCOMPATIBILITE'',
     S           '' FICHIER / LOGICIEL, UNITE'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-11) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNITE'',I3,'' NON FERMEE APRES '',
     S           ''LA DERNIERE MODIFICATION'')') KNUMER
C
        ELSEIF (KCODE.EQ.-12) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNITE'',I3,
     S  '' DE STATUS ''''OLD'''' - ERREUR LECTURE PREMIER ARTICLE'')')
     S       KNUMER
C
        ELSEIF (KCODE.EQ.-13) THEN
          INLNOM=1
          INUMER=JPNIL
C
          DO 131 J=1,NBFIOU
          IJ=NUMIND(J)
C
          IF (CDACTI.EQ.CNOMFI(IJ)) THEN
            INUMER=NUMERO(IJ)
            INLNOM=MIN0 (NLNOMF(IJ),LEN (CLMESS)-3)
            GOTO 132
          ENDIF
C
  131     CONTINUE
C
  132     CONTINUE
          CLMESS=' '''//CDACTI(1:INLNOM)//''''
          WRITE (UNIT=*,FMT='(A)') CLMESS
          WRITE (UNIT=CLMESS,FMT='(''UNITE'',I3,'' - FICHIER '',
     S           ''DEJA OUVERT POUR L''''UNITE'',I3)') KNUMER,INUMER
C
        ELSEIF (KCODE.EQ.-14) THEN
C
          IF (CDNSPR.EQ.'LFIECR'.OR.CDNSPR.EQ.'LFILEC'.OR.
     S        CDNSPR.EQ.'LFILAS'.OR.CDNSPR.EQ.'LFILAP') THEN
            WRITE (UNIT=CLMESS,FMT=
     S   '(''LONGUEUR D''''ARTICLE INCORRECTE, UNITE'',I3)') KNUMER
          ELSEIF (KNUMER.EQ.JPNIL) THEN
            CLMESS='RANG DANS LA TABLE *NUMERO* INCORRECT'
          ELSE
            WRITE (UNIT=CLMESS,FMT=
     S   '(''ARGUMENT DE TYPE ENTIER INCORRECT, UNITE'',I3)') KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-15) THEN
          WRITE (UNIT=CLMESS,FMT='(''NOM D''''ARTICLE INCORRECT OU '',
     S           ''TROP LONG, UNITE'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-16) THEN
          WRITE (UNIT=CLMESS,FMT='(''INCOHERENCE (TABLES, FICHIER, '',
     S           ''APPELS S/P INT, LOGICIEL), UNITE'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-17) THEN
C
          IF (IJL.NE.0) THEN
            INBALO=MDES1D(IXM(JPNALO,IJL))
          ELSE
            INBALO=JPNIL
          ENDIF
C
          WRITE (UNIT=CLMESS,FMT='(I6,'' ARTICLES, INDEX PLEIN, UNITE'',
     S           I3)') INBALO,KNUMER
C
        ELSEIF (KCODE.EQ.-18) THEN
          WRITE (UNIT=CLMESS,FMT='(''ARTICLE DE NOM BLANC ILLICITE'',
     S           '', UNITE'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-19) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNITE'',I3,
     S           '' ''''SCRATCH'''', NE PEUT ETRE CONSERVEE'')') KNUMER
C
        ELSEIF (KCODE.EQ.-20) THEN
          WRITE (UNIT=CLMESS,FMT='(''ARTICLE "'',A,
     S           ''" NON TROUVE, UNITE'',I3)') CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-21) THEN
          WRITE (UNIT=CLMESS,FMT='(''ARTICLE "'',A,
     S    ''" + *LONG* QUE DEMANDE, UNITE'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-22) THEN
          WRITE (UNIT=CLMESS,FMT='(''ARTICLE "'',A,
     S    ''" + *COURT* QUE DEMANDE, UNITE'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-23) THEN
          WRITE (UNIT=CLMESS,FMT='(''PAS OU PLUS D''''ARTICLE SUIVANT'',
     S    '' A LIRE, UNITE'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-24) THEN
          WRITE (UNIT=CLMESS,FMT='(''VARIABLE CAR.TROP COURTE '',
     S    ''POUR "'',A,''", UNITE'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-25) THEN
          WRITE (UNIT=CLMESS,FMT='(''NOUVEAU NOM D''''ARTICLE: "'',A,
     S    ''" DEJA UTILISE, UNITE'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-26) THEN
          WRITE (UNIT=CLMESS,FMT='(''PAS OU PLUS D''''ARTICLE '',
     S    '' PRECEDENT A LIRE, UNITE'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-27) THEN
          WRITE (UNIT=CLMESS,FMT='(''ESPACE CONTIGU INSUFFISANT DANS '',
     S    '' LES TABLES, UNITE'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-28) THEN
C
          IF (KNUMER.EQ.JPNIL) THEN
            WRITE (UNIT=CLMESS,FMT='(''FACTEUR MULTIPLICATIF PAR '',
     S      ''DEFAUT SUPERIEUR AU MAXIMUM('',I3,'')'')') JPFACX
          ELSE
            WRITE (UNIT=CLMESS,FMT='(''FACTEUR MULTIPLICATIF '',
     S      ''DEMANDE SUPERIEUR AU MAXIMUM ('',I3,''), UNITE'',I3)')
     S        JPFACX,KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-29) THEN
          WRITE (UNIT=CLMESS,FMT='(I3,'' ENTREES,'',
     S    '' PAS DE PLACE POUR FACTEUR MULTIPLIC, UNITE'',I3)')
     S    JPXUFM,KNUMER
C
        ELSEIF (KCODE.EQ.-30) THEN
          WRITE (UNIT=CLMESS,FMT='(''NUMERO D''''UNITE LOGIQUE FORTRAN''
     S           ,I8,'' ILLICITE'')') KNUMER
C
        ELSEIF (KCODE.EQ.-31) THEN
          WRITE (UNIT=CLMESS,FMT='(''NUMERO UNITE LOGIQ'',I3,
     S       '' SANS FACTEUR MULTIPLICATIF PREDEFINI'')') KNUMER
C
C                  Pour les codes d'erreur non prevus...
C
        ELSEIF (KNUMER.EQ.JPNIL) THEN
          WRITE (UNIT=CLMESS,FMT='(''ERREUR GLOBALE *INCONNUE* NUMERO'',
     S                             I6)') KCODE
        ELSE
          WRITE (UNIT=CLMESS,FMT='(''ERREUR *INCONNUE* NUMERO'',I6,
     S           '' SUR UNITE LOGIQUE'',I3)') KCODE,KNUMER
        ENDIF
C
        ILMESA=LEN (CLMESA)
        ILMESU=ILMESA-1-2*LEN (CLJOLI)-ILNSPR-4
        CLMESA=CLJOLI//' '//CDNSPR(1:ILNSPR)//' - '//CLMESS(1:ILMESU)
     S         //CLJOLI
        WRITE (UNIT=*,FMT='(A)') CLMESA
C
C           Si l'unite logique correspond a une unite logique LFI
C     deja ouverte, on en imprime le nom.
C
        IF (IJL.NE.0) THEN
C
          IF (NLNOMF(IJL).LE.JPLFTX) THEN
            WRITE (UNIT=*,FMT='(A,/)') CLJOLI//' NOM - APPARENT MAIS'
     S             //' COMPLET - DE L''UNITE LOGIQUE LFI CONCERNEE:'
          ELSE
            WRITE (UNIT=CLMESS,FMT='(A,
     S             '' NOM - APPARENT, ET TRONQUE DE'',I4,
     S       '' CARACTERES - DE L''''UNITE LOGIQUE LFI CONCERNEE:'')')
     S      CLJOLI,NLNOMF(IJL)-JPLFTX
            WRITE (UNIT=*,FMT='(A,/)') CLMESS
          ENDIF
C
          INLIGN=(NLNOMF(IJL)-1)/JPLFIX
          IDECAL=0
C
          DO 801 J=1,INLIGN
          WRITE (UNIT=*,FMT='(A)')
     S           CNOMFI(IJL)(IDECAL+1:IDECAL+JPLFIX)//'...'
          IDECAL=IDECAL+JPLFIX
  801     CONTINUE
C
          IF (NLNOMF(IJL).LE.JPLFTX) THEN
            WRITE (UNIT=*,FMT='(A,/)') CNOMFI(IJL)(IDECAL+1:NLNOMF(IJL))
          ELSE
            WRITE (UNIT=*,FMT='(A,/)') CNOMFI(IJL)(IDECAL+1:JPLFTX)
     S             //'...'
          ENDIF
C
          IF (CNOMSY(IJL).NE.CNOMFI(IJL)) THEN
            WRITE (UNIT=*,FMT='(A,/)') CLJOLI//
     S ' NOM *SYSTEME* (APPARENT) DE L''UNITE LOGIQUE LFI CONCERNEE:'
            INLIGN=(NLNOMS(IJL)-1)/JPLFIX
            IDECAL=0
C
            DO 802 J=1,INLIGN
            WRITE (UNIT=*,FMT='(A)')
     S             CNOMSY(IJL)(IDECAL+1:IDECAL+JPLFIX)//'...'
            IDECAL=IDECAL+JPLFIX
  802       CONTINUE
C
            WRITE (UNIT=*,FMT='(A,/)') CNOMSY(IJL)(IDECAL+1:NLNOMS(IJL))
          ENDIF
C
        ENDIF
C
        IF (LDFATA.AND.KCODE.NE.0) THEN
C
C            Saborde le programme.
C
          CALL ABOR2 (CLMESA)
        ELSE
          CALL REMARK2 (CLMESA(2:))
        ENDIF
C
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIEMS ( KNUMER, KNIMES, KCODE, LDFATA, CDMESS, CDNSPR,
     S                    CDACTI )
#include "lficomt.h"
C****
C        CE SOUS-PROGRAMME EST CHARGE DE FAIRE L'ECHO DES MESSAGES
C     EMIS PAR LE LOGICIEL DE FICHIERS INDEXES LFI, EN FAISANT SI
C     BESOIN EST L'"ABORT" DU PROGRAMME .
C        En l'occurrence, il s'agit d'un "chapeau" qui aiguille sur
C     LFIEFR ou LFIENG en fonction de la variable logique LFRANC.
C**
C        ARGUMENTS : KNUMER ==> Numero eventuel de l'Unite Logique;
C        ( tous                 ( si JPNIL ==> pas d'Unite Logique )
C         d'Entree ) KNIMES ==> Niveau (0,1,2) du Message;
C                    KCODE  ==> CODE CORRESPONDANT A L'ACTION;
C                    LDFATA ==> VRAI SI ON DOIT AVORTER LE PROGRAMME;
C                    CDMESS ==> SI KNIMES#0, MESSAGE A EMETTRE;
C                    CDNSPR ==> NOM DU SOUS-PROGRAMME APPELANT;
C                    CDACTI ==> NOM DE L'ACTION D'ENTREE/SORTIE FORTRAN
C                               (SI KCODE >0), SINON FOURRE-TOUT (!) .
C*
C        Pour la table des codes-reponses possibles, voir LFIEFR/LFIENG.
C
#include "lficom0.h"
C
      INTEGER KNUMER, KNIMES, KCODE, ICODE, IREPON
C
      LOGICAL LDFATA, LLEXUL
C
      CHARACTER  CDNSPR*(*), CDMESS*(*), CDACTI*(*)
C**
C     1.  -  MODIFICATION EVENTUELLE DU CODE-REPONSE S'IL VAUT (-1).
C-----------------------------------------------------------------------
C*
C        Il s'agit en effet de discriminer entre un numero d'unite
C     logique licite pour le FORTRAN, mais effectivement non ouvert pour
C     le logiciel LFI, auquel cas le code-reponse est laisse a (-1),
C     et un numero d'unite logique FORTRAN carrement illicite, que l'on
C     traduit par le code-reponse (-30).
C
      IF (KCODE.EQ.-1) THEN
        ICODE=-30
        INQUIRE (UNIT=KNUMER,EXIST=LLEXUL,ERR=101,IOSTAT=IREPON)
        IF (LLEXUL) ICODE=KCODE
      ELSE
        ICODE=KCODE
      ENDIF
C
  101 CONTINUE
C**
C     2.  -  APPEL AU SOUS-PROGRAMME AD HOC EN FONCTION DE *LFRANC*.
C-----------------------------------------------------------------------
C
      IF (LFRANC) THEN
        CALL LFIEFR (KNUMER,KNIMES,ICODE,LDFATA,CDMESS,CDNSPR,CDACTI)
      ELSE
        CALL LFIENG (KNUMER,KNIMES,ICODE,LDFATA,CDMESS,CDNSPR,CDACTI)
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIENG ( KNUMER, KNIMES, KCODE, LDFATA, CDMESS, CDNSPR,
     S                    CDACTI )
#include "lficomt.h"
C****
C        THIS SUBROUTINE PRINTS STANDARD MESSAGES FROM LFI INDEXED-
C     FILE SOFTWARE, ABORTING PROGRAM IF REQUIRED.
C        Messages related to "debugging mode" are directly printed
C     by concerned subroutines.
C
C        This SUBROUTINE is the english version, translated from the
C     the original (french) one, and is always called through the
C     "hat" routine LFIEMS.
C     For french version see SUBROUTINE LFIEFR.
C     ( Pour la version francaise, voir LFIEFR )
C**
C  DUMMY ARGUMENTS : KNUMER ==> LOGICAL Unit concerned, IF any;
C  ( all INPUT ones )           ( IF JPNIL ==> no LOGICAL Unit )
C                    KNIMES ==> Level (0,1,2) of Message;
C                    KCODE  ==> Response code of action concerned;
C                    LDFATA ==> True IF Abort of PROGRAM is required;
C                    CDMESS ==> IF KNIMES#0, Message to PRINT;
C                    CDNSPR ==> SUBROUTINE name which calls LFIEMS;
C                    CDACTI ==> Name of FORTRAN input/output action
C                               IF KCODE >0, ELSE... it depends !
C*
C     !----------------------------------------------------------------!
C     !   TABLE OF POSSIBLE VALUES FOR RESPONSE CODES OF LFI SOFTWARE  !
C     !----------------------------------------------------------------!
C
C-----------------------------------------------------------------------
C      0 ==> No error has been detected, everything is OK.
C-----------------------------------------------------------------------
Cpositive==> It is the (absolute value of) FORTRAN response code
C  value     from an OPEN, READ, WRITE, CLOSE or INQUIRE instruction;
C            see vendor's reference manual for exact meaning.
C-----------------------------------------------------------------------
C     -1 ==> Logical Unit currently not opened for the software.
C-----------------------------------------------------------------------
C     -2 ==> "LEVEL" value outside [0-2] range .
C-----------------------------------------------------------------------
C     -3 ==> Bad lock option (internal subroutine "LFIVER") .
C-----------------------------------------------------------------------
C     -4 ==> Explicit change for Multi-Tasking mode, but almost one unit
C            is currently open-problems may arise (subroutine "LFIINI").
C-----------------------------------------------------------------------
C     -5 ==> Logical Unit is currently opened (LFIOUV, LFIAFM, LFISFM) .
C-----------------------------------------------------------------------
C     -6 ==> Not enough space within tables to open requested Unit.
C            (LFIOUV)
C-----------------------------------------------------------------------
C     -7 ==> Invalid "STATUS" for FORTRAN instruction "OPEN" (LFIOUV) .
C-----------------------------------------------------------------------
C     -8 ==> Incompatible values given for "LDNOMM" and "CDSTTO":
C            a file which "STATUS" is 'OLD' or 'NEW' must have a name .
C            (LFIOUV) (THIS REPONSE CODE HAS CURRENTLY NO MORE SENSE)
C-----------------------------------------------------------------------
C     -9 ==> Incompatibility between "STATUS" 'NEW' or 'OLD' and (respe-
C            ctively) file existence or non-existence (LFIOUV) .
C-----------------------------------------------------------------------
C    -10 ==> The file is not a LFI one, or may not be treated through
C            this configuration or version of the software (LFIOUV) .
C-----------------------------------------------------------------------
C    -11 ==> File not closed after a modification (LFIOUV): this
C            error is not fatal if "LDERFA" is .FALSE., but in such a
C            case file integrity and data coherence are not guaranteed.
C            Note that once a file has got such problem, this response
C            code will stay even after a subsequent modification.
C-----------------------------------------------------------------------
C    -12 ==> File has a "STATUS" 'OLD' but an error occurred when
C            reading the first physical record of file (LFIOUV) .
C-----------------------------------------------------------------------
C    -13 ==> File is already open for another LFI logical unit.
C            (LFIOUV)
C-----------------------------------------------------------------------
C    -14 ==> Incorrect value for INTEGER argument (generally negative) .
C-----------------------------------------------------------------------
C    -15 ==> Incorrect CHARACTER argument (too long, for instance).
C-----------------------------------------------------------------------
C    -16 ==> Incoherence in Tables, File, internal calls, software.
C            THIS ERROR MAY NEVER BE FILTERED. ALWAYS FATAL.
C-----------------------------------------------------------------------
C    -17 ==> Too many logical records to store an extra one (LFIECR) .
C            (note that logical records consist of user-readable data
C             records, but also of holes cataloged in index... which are
C             created when existing records may not be rewritten in
C             place, or when records are suppressed; such holes may be
C             "re-cycled")
C-----------------------------------------------------------------------
C    -18 ==> A logical record name formed only with SPACES is invalid.
C            (for internal use of LFI software, holes in index are
C             described by a blank record name)
C-----------------------------------------------------------------------
C    -19 ==> File opened with "STATUS" set to 'SCRATCH', so may not be
C            kept at CLOSE time: 'KEEP' is illicit for "CDSTTC" (LFIFER)
C            if this error is not fatal, then a FORTRAN "CLOSE" without
C            "STATUS" parameter is performed, in the same manner as if
C            "CDSTTC" is neither 'KEEP' nor 'DELETE'.
C-----------------------------------------------------------------------
C    -20 ==> No logical record with such name found within logical unit.
C            (LFILEC, LFIREN, LFISUP)
C-----------------------------------------------------------------------
C    -21 ==> Requested logical record is LONGER (has more data) in file;
C            if this error is not fatal, then a PARTIAL read is
C            performed, at requested length.
C            (LFILAP, LFILAS, LFILEC)
C-----------------------------------------------------------------------
C    -22 ==> Requested logical record SHORTER (has less data) in file;
C            even if this error is not fatal, NO READING OF DATA OCCURS.
C            (LFILAP, LFILAS, LFILEC) .
C-----------------------------------------------------------------------
C    -23 ==> No or no more "NEXT" record to read (LFILAS) .
C-----------------------------------------------------------------------
C    -24 ==> The character variable given as actual output argument is
C            TOO SHORT to store the record NAME, even when suppressing
C            any spaces at the end of the name.
C            (LFICAP, LFICAS, LFILAP, LFILAS)
C-----------------------------------------------------------------------
C    -25 ==> The new name of the logical record is (already) used for
C            another logical record within the file (LFIREN).
C-----------------------------------------------------------------------
C    -26 ==> No or no more "PREVIOUS" logical record to read (LFILAP).
C-----------------------------------------------------------------------
C    -27 ==> Insufficient CONTIGUOUS space within tables to treat the
C            "multiple" file requested (LFIOUV) .
C-----------------------------------------------------------------------
C    -28 ==> Multiply factor (of elementary physical record length) too
C            big for the current configuration of the software.
C            (LFIOUV, LFIAFM, LFIFMD)
C-----------------------------------------------------------------------
C    -29 ==> Not enough space within tables to store the multiply factor
C            to be associated to logical unit (LFIAFM) .
C-----------------------------------------------------------------------
C    -30 ==> Logical unit number invalid for FORTRAN.
C-----------------------------------------------------------------------
C    -31 ==> Logical unit has no multiply factor predefined.
C            (LFISFM)
C-----------------------------------------------------------------------
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KNUMER, KNIMES, KCODE, ILDMES, ILBLAN, INLNOM, INUMER
      INTEGER IDECBL, IPOSBL, ILACTI, ILACT2, ILNSPR, ILMESU, IJL, J, IJ
      INTEGER INBALO, ILMESA, INLIGN, IDECAL
C
      LOGICAL LDFATA
C
      CHARACTER  CDNSPR*(*), CLJOLI*6, CDMESS*(*), CLMESA*80, CDACTI*(*)
C
#include "lficom2.h"
C**
C     1.  -  INITIALISATIONS.
C-----------------------------------------------------------------------
C
C        Search for "useful" length of argument CDACTI.
C        (i.e. not taking into account any blank characters at the end)
C
      IDECBL=0
C
  101 CONTINUE
      IPOSBL=IDECBL+INDEX (CDACTI(IDECBL+1:),' ')
C
      IF (IPOSBL.LE.IDECBL) THEN
        ILACTI=LEN (CDACTI)
      ELSEIF (CDACTI(IPOSBL:).EQ.' ') THEN
        ILACTI=IPOSBL-1
      ELSE
        IDECBL=IPOSBL
        GOTO 101
      ENDIF
C
      ILACT2=MIN0 (ILACTI,JPNCPN)
      ILACTI=MIN0 (ILACT2,8)
      ILNSPR=MIN0 (LEN (CDNSPR),JPLSPX)
C
C        Prefix (and possible suffix) for the message(s).
C
      IF (LDFATA) THEN
        CLJOLI=' *****'
      ELSEIF (KNIMES.EQ.0.OR.KCODE.NE.0) THEN
        CLJOLI=' */*/*'
      ELSE
        CLJOLI=' /////'
      ENDIF
C
      IF (KNIMES.NE.0) THEN
C**
C     2.  -  PRINTS MESSAGE PREPARED BY SUBROUTINE WHICH CALLED LFIEMS.
C-----------------------------------------------------------------------
C
        ILMESU=MIN0 (LEN (CLMESS)-LEN (CLJOLI)-ILNSPR-4,LEN (CDMESS))
        CLMESS=CLJOLI//' '//CDNSPR(1:ILNSPR)//' - '//CDMESS(1:ILMESU)
        WRITE (UNIT=*,FMT='(A)') CLMESS
      ENDIF
C
      IF (KNIMES.EQ.0.OR.LDFATA) THEN
C**
C     3.  -  CONSTITUTION OF "AD HOC" MESSAGE, DEPENDING OF *KCODE*.
C-----------------------------------------------------------------------
C
C     Before, check if logical unit considered corresponds to a logical
C     unit currently opened for LFI software (or not).
C
        IF (KNUMER.EQ.JPNIL) THEN
          IJL=0
        ELSE
C
          DO 301 J=1,NBFIOU
          IJL=NUMIND(J)
          IF (KNUMER.EQ.NUMERO(IJL)) GOTO 302
  301     CONTINUE
C
          IJL=0
        ENDIF
C
  302   CONTINUE
C
        IF (KCODE.GT.0) THEN
C
          IF ((CDACTI.EQ.'READ'.OR.CDACTI.EQ.'WRITE')
     S        .AND.NUMAPH(IJL).GT.0) THEN
            WRITE (UNIT=CLMESS,FMT='(''ERROR "'',A,''"'',I7,
     S             '',UNIT'',I3,'',REC.NUM'',I6,'',*'',I6,
     S             '' WORDS'')') CDACTI(1:ILACTI),KCODE,KNUMER,
     S                            NUMAPH(IJL),JPLARD*MFACTM(IJL)
          ELSE
            WRITE (UNIT=CLMESS,FMT='(''FORTRAN "'',A,''" ERROR, CODE=''
     S             ,I7,'', UNIT='',I3)') CDACTI(1:ILACTI),KCODE,KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-1) THEN
          WRITE (UNIT=CLMESS,FMT='(''LOGICAL UNIT'',I3,
     S           '' NOT OPENED FOR LFI SOFTWARE'')') KNUMER
C
        ELSEIF (KCODE.EQ.-2) THEN
C
          IF (KNUMER.EQ.JPNIL) THEN
            CLMESS='ACTUAL VALUE FOR LEVEL "KNIVAU" OUTSIDE [0-2] RANGE'
          ELSE
            WRITE (UNIT=CLMESS,FMT=
     S   '(''MESSAGE LEVEL OUTSIDE [0-2] RANGE, UNIT'',I3)') KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-3) THEN
          ILDMES=MIN0 (8,LEN (CDMESS))
          CLMESS='UNKNOWN ACTION '''//CDMESS(1:ILDMES)
     S           //''' ON LOCKS'
C
        ELSEIF (KCODE.EQ.-4) THEN
          CLMESS='EXPL.CHANGE OF MULTI-TASKING MODE WITH UNIT(S) OPENED'
C
        ELSEIF (KCODE.EQ.-5) THEN
          WRITE (UNIT=CLMESS,FMT='(''LOGICAL UNIT'',I3,
     S          '' ALREADY OPENED FOR LFI - AND SHOULD NOT.'')') KNUMER
C
        ELSEIF (KCODE.EQ.-6) THEN
          WRITE (UNIT=CLMESS,FMT='(I3,'' ENTRIES,'',
     S    '' NOT ENOUGH PLACE WITHIN TABLES FOR UNIT'',I3)')
     S    JPNXFI,KNUMER
C
        ELSEIF (KCODE.EQ.-7) THEN
          WRITE (UNIT=CLMESS,FMT='(''FORTRAN STATUS'''''',A,
     S           '''''' UNKNOWN, UNIT'',I3)') CDACTI(1:ILACTI),KNUMER
C
        ELSEIF (KCODE.EQ.-8) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNIT'',I3,'' OF STATUS ''''''
     S,A,'''''' MUST HAVE AN EXPLICIT NAME'')') KNUMER,CDACTI(1:ILACTI)
C
        ELSEIF (KCODE.EQ.-9) THEN
C
        IF (CDACTI.EQ.'OLD') THEN
          WRITE (UNIT=CLMESS,FMT=
     S'(''STATUS ''''OLD'''' BUT FILE DOES NOT EXIST, UNIT'',
     S      I3)') KNUMER
        ELSE
          ILBLAN=INDEX (CDACTI(1:ILACTI),' ')
          IF (ILBLAN.GT.1) ILACTI=ILBLAN-1
          WRITE (UNIT=CLMESS,FMT=
     S'(''STATUS '''''',A,'''''' BUT FILE ALREADY EXISTS, UNIT'',
     S  I3)') CDACTI(1:ILACTI),KNUMER
        ENDIF
C
        ELSEIF (KCODE.EQ.-10) THEN
          WRITE (UNIT=CLMESS,FMT='(''INCOMPATIBILITY'',
     S           '' FILE / SOFTWARE, UNIT'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-11) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNIT'',I3,'' NOT CLOSED AFTER '',
     S           ''ITS LAST MODIFICATION'')') KNUMER
C
        ELSEIF (KCODE.EQ.-12) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNIT'',I3,
     S  '' OF STATUS ''''OLD'''' - READ OF FIRST RECORD FAILED'')')
     S       KNUMER
C
        ELSEIF (KCODE.EQ.-13) THEN
          INLNOM=1
          INUMER=JPNIL
C
          DO 131 J=1,NBFIOU
          IJ=NUMIND(J)
C
          IF (CDACTI.EQ.CNOMFI(IJ)) THEN
            INUMER=NUMERO(IJ)
            INLNOM=MIN0 (NLNOMF(IJ),LEN (CLMESS)-3)
            GOTO 132
          ENDIF
C
  131     CONTINUE
C
  132     CONTINUE
          CLMESS=' '''//CDACTI(1:INLNOM)//''''
          WRITE (UNIT=*,FMT='(A)') CLMESS
          WRITE (UNIT=CLMESS,FMT='(''UNIT'',I3,'' - FILE '',
     S           ''ALREADY OPEN WITH UNIT'',I3)') KNUMER,INUMER
C
        ELSEIF (KCODE.EQ.-14) THEN
C
          IF (CDNSPR.EQ.'LFIECR'.OR.CDNSPR.EQ.'LFILEC'.OR.
     S        CDNSPR.EQ.'LFILAS'.OR.CDNSPR.EQ.'LFILAP') THEN
            WRITE (UNIT=CLMESS,FMT=
     S   '(''INCORRECT RECORD LENGTH, UNIT'',I3)') KNUMER
          ELSEIF (KNUMER.EQ.JPNIL) THEN
            CLMESS='INCORRECT ENTRY IN *NUMERO* TABLE'
          ELSE
            WRITE (UNIT=CLMESS,FMT=
     S   '(''INCORRECT INTEGER TYPE ARGUMENT, UNIT'',I3)') KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-15) THEN
          WRITE (UNIT=CLMESS,FMT='(''RECORD NAME INCORRECT OR '',
     S           ''TOO LONG, UNIT'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-16) THEN
          WRITE (UNIT=CLMESS,FMT='(''INCOHERENCE (TABLES, FILE, '',
     S           ''INTERNAL CALLS, SOFTWARE), UNIT'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-17) THEN
C
          IF (IJL.NE.0) THEN
            INBALO=MDES1D(IXM(JPNALO,IJL))
          ELSE
            INBALO=JPNIL
          ENDIF
C
          WRITE (UNIT=CLMESS,FMT='(I6,'' RECORDS, INDEX FULL, UNIT'',
     S           I3)') INBALO,KNUMER
C
        ELSEIF (KCODE.EQ.-18) THEN
          WRITE (UNIT=CLMESS,FMT='(''BLANK RECORD NAME IS INVALID'',
     S           '', UNIT'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-19) THEN
          WRITE (UNIT=CLMESS,FMT='(''UNIT'',I3,
     S           '' IS ''''SCRATCH'''', SO MAY NOT BE KEPT'')') KNUMER
C
        ELSEIF (KCODE.EQ.-20) THEN
          WRITE (UNIT=CLMESS,FMT='(''RECORD "'',A,
     S           ''" NOT FOUND, UNIT'',I3)') CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-21) THEN
          WRITE (UNIT=CLMESS,FMT='(''RECORD "'',A,
     S    ''" *LONGER* THAN REQUESTED, UNIT'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-22) THEN
          WRITE (UNIT=CLMESS,FMT='(''RECORD "'',A,
     S    ''" *SHORTER* THAN REQUESTED-UNIT'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-23) THEN
          WRITE (UNIT=CLMESS,FMT='(''NO/NO MORE NEXT RECORD'',
     S    '' TO READ, UNIT'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-24) THEN
          WRITE (UNIT=CLMESS,FMT='(''CHARAC. VARIABLE TOO SHORT '',
     S    ''FOR "'',A,''", UNIT'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-25) THEN
          WRITE (UNIT=CLMESS,FMT='(''NEW RECORD NAME: "'',A,
     S    ''" ALREADY USED, UNIT'',I3)')
     S      CDACTI(1:ILACT2),KNUMER
C
        ELSEIF (KCODE.EQ.-26) THEN
          WRITE (UNIT=CLMESS,FMT='(''NO/NO MORE PREVIOUS RECORD '',
     S    '' TO READ, UNIT'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-27) THEN
          WRITE (UNIT=CLMESS,FMT='(''INSUFFICIENT CONTIGUOUS SPACE WI'',
     S    ''THIN TABLES, UNIT'',I3)') KNUMER
C
        ELSEIF (KCODE.EQ.-28) THEN
C
          IF (KNUMER.EQ.JPNIL) THEN
            WRITE (UNIT=CLMESS,FMT='(''NEW DEFAULT MULTIPLY FACTOR EX'',
     S      ''CEEDS MAXIMUM ('',I3,'')'')') JPFACX
          ELSE
            WRITE (UNIT=CLMESS,FMT='(''SPECIFIED MULTIPLY FACTOR '',
     S      ''EXCEEDS MAXIMUM ('',I3,''), UNIT'',I3)') JPFACX,KNUMER
          ENDIF
C
        ELSEIF (KCODE.EQ.-29) THEN
          WRITE (UNIT=CLMESS,FMT='(I3,'' ENTRIES,'',
     S    '' NO MORE PLACE FOR MULTIPLY FACTOR, UNIT'',I3)')
     S    JPXUFM,KNUMER
C
        ELSEIF (KCODE.EQ.-30) THEN
          WRITE (UNIT=CLMESS,FMT='(''INVALID FORTRAN LOGICAL UNIT'',
     S           '' NUMBER:'',I8)') KNUMER
C
        ELSEIF (KCODE.EQ.-31) THEN
          WRITE (UNIT=CLMESS,FMT='(''LOGICAL UNIT NUMBER'',I3,
     S       '' HAS NO PREDEFINED MULTIPLY FACTOR'')') KNUMER
C
C                  For unexpected error codes...
C
        ELSEIF (KNUMER.EQ.JPNIL) THEN
          WRITE (UNIT=CLMESS,FMT='(''*UNKNOWN* GLOBAL ERROR CODE'',
     S                             I6)') KCODE
        ELSE
          WRITE (UNIT=CLMESS,FMT='(''*UNKNOWN* ERROR CODE'',I6,
     S           '' ON LOGICAL UNIT'',I3)') KCODE,KNUMER
        ENDIF
C
        ILMESA=LEN (CLMESA)
        ILMESU=ILMESA-1-2*LEN (CLJOLI)-ILNSPR-4
        CLMESA=CLJOLI//' '//CDNSPR(1:ILNSPR)//' - '//CLMESS(1:ILMESU)
     S         //CLJOLI
        WRITE (UNIT=*,FMT='(A)') CLMESA
C
C           If logical unit corresponds to a LFI logical unit
C     already opened, its name is printed.
C
        IF (IJL.NE.0) THEN
C
          IF (NLNOMF(IJL).LE.JPLFTX) THEN
            WRITE (UNIT=*,FMT='(A,/)') CLJOLI//' NAME - APPEARENT BUT'
     S             //' COMPLETE - OF LFI LOGICAL UNIT CONCERNED:'
          ELSE
            WRITE (UNIT=CLMESS,FMT='(A,
     S             '' NAME - APPEARENT, AND TRUNCATED BY'',I4,
     S       '' CARACTERES - OF LFI LOGICAL UNIT CONCERNED:'')')
     S      CLJOLI,NLNOMF(IJL)-JPLFTX
            WRITE (UNIT=*,FMT='(A,/)') CLMESS
          ENDIF
C
          INLIGN=(NLNOMF(IJL)-1)/JPLFIX
          IDECAL=0
C
          DO 801 J=1,INLIGN
          WRITE (UNIT=*,FMT='(A)')
     S           CNOMFI(IJL)(IDECAL+1:IDECAL+JPLFIX)//'...'
          IDECAL=IDECAL+JPLFIX
  801     CONTINUE
C
          IF (NLNOMF(IJL).LE.JPLFTX) THEN
            WRITE (UNIT=*,FMT='(A,/)') CNOMFI(IJL)(IDECAL+1:NLNOMF(IJL))
          ELSE
            WRITE (UNIT=*,FMT='(A,/)') CNOMFI(IJL)(IDECAL+1:JPLFTX)
     S             //'...'
          ENDIF
C
          IF (CNOMSY(IJL).NE.CNOMFI(IJL)) THEN
            WRITE (UNIT=*,FMT='(A,/)') CLJOLI//
     S ' *SYSTEM* NAME (APPEARENT) OF LFI LOGICAL UNIT CONCERNED:'
            INLIGN=(NLNOMS(IJL)-1)/JPLFIX
            IDECAL=0
C
            DO 802 J=1,INLIGN
            WRITE (UNIT=*,FMT='(A)')
     S             CNOMSY(IJL)(IDECAL+1:IDECAL+JPLFIX)//'...'
            IDECAL=IDECAL+JPLFIX
  802       CONTINUE
C
            WRITE (UNIT=*,FMT='(A,/)') CNOMSY(IJL)(IDECAL+1:NLNOMS(IJL))
          ENDIF
C
        ENDIF
C
        IF (LDFATA.AND.KCODE.NE.0) THEN
C
C            Aborts program.
C
          CALL ABOR2 (CLMESA)
        ELSE
          CALL REMARK2 (CLMESA(2:))
        ENDIF
C
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIFER ( KREP, KNUMER, CDSTTC )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME DE FERMETURE D'UN FICHIER INDEXE AU SENS DU
C     LOGICIEL DE FICHIERS INDEXES LFI.
C        CETTE FERMETURE EST VITALE SI LE FICHIER A ETE MODIFIE DEPUIS
C     LA DERNIERE OUVERTURE, ET EST DE TOUTE MANIERE CHAUDEMENT
C     RECOMMANDEE AVANT DE SORTIR DU PROGRAMME UTILISATEUR.
C
C        De maniere generale, il vaut mieux fermer une unite logique
C     des que l'on n'en a plus besoin, de maniere a ne pas bloquer un
C     espace dans les tables qui pourrait faire defaut lors d'une
C     ouverture ulterieure, particulierement pour un fichier "multiple"
C     qui a besoin d'espace CONTIGU dans les tables des unites logiques.
C     Par ailleurs, tout fichier ouvert (au sens FORTRAN du terme cette
C     fois) "occupe" generalement un morceau de la memoire du programme.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE;
C                CDSTTC (ENTREE) ==> "STATUS" EVENTUEL POUR "CLOSE".
C
C    Modifications:
C
C    02/06/97, Jean Clochard.
C
C              -Modification des impressions pour que l'annee puisse
C               etre imprimee avec 4 chiffres.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CDSTTC*(*), CLSTTC*(JPLSTX), CLAUXI*3
C
#ifndef f77
      INTEGER (KIND=JPDBLE) ITAMPO (JPLARX)
#else
      INTEGER ITAMPO (JPLARX)
#endif
      INTEGER KREP, KNUMER, IEXPLO (JPNPIA+JPNPIS)
      INTEGER ILSTTU, IREPX, INAPHY, IRANG, IREP, ILSTTC, IREC, INPPIM
      INTEGER IFACTM, ILARPH, INALPP, INBALO, INTPPI, INTRLZ, IDECAL, J
      INTEGER IPOTZC, IRGPFC, IRGPMC, ILFORC, INPILE, INIMES, IPOTZS, JJ
      INTEGER IRGPFS, IPOTZE, IRGPMS, INTCON, IPOSFE, JNPAGE, IRGPFE, JR
      INTEGER IRGPME, IRANGM, IDECDB, INBARE, IRGPC2, IRGPS2, IDECDC
      INTEGER INBARC, IDECDS, INBARS, INBART, INTPPN, ILOMIN, ILOMAX
      INTEGER IRPIFN, INPIME, IDEBEX, IRGPIM, IRGPIF, INLNOM, IDEBUT
      INTEGER ILONGA, INALDO, IPOSNU, IRANIE, IRETIN, IAUXIL
C
      LOGICAL LLSTTU, LLVERF, LLVERG, LLECRD, LLIMST
C
#include "lficom2.h"
C
      CLACTI=''
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IF (LMISOP) PRINT *,'DEBUT LFIFER'
      CLNSPR='LFIFER'
      ILSTTU=MIN0 (LEN (CLSTTC), LEN (CDSTTC))
      CLSTTC=CDSTTC(:ILSTTU)
      IREPX=0
      INAPHY=0
      LLVERF=.FALSE.
      LLVERG=.FALSE.
      CALL LFINUM (KNUMER,IRANG)
C
      IF (IRANG.EQ.0) THEN
        IREP=-1
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
      LLVERF=LMULTI
C
      IF (CDSTTC.EQ.'KEEP'.AND.CSTAOP(IRANG).EQ.'SCRATCH') THEN
        IREP=-19
        LLFATA=LLMOER (IREP,IRANG)
C
        IF (LLFATA) THEN
          GOTO 1001
        ELSE
C
C        SI L'ERREUR (-19) N'EST PAS FATALE, ON FERME L'UNITE LOGIQUE,
C       MAIS SANS PRECISER DE DIRECTIVE "STATUS" DANS LE "CLOSE".
C
          LLSTTU=.FALSE.
          GOTO 105
        ENDIF
C
      ELSE
        LLSTTU=CDSTTC.EQ.'KEEP'.OR.CDSTTC.EQ.'DELETE'
C
        IF (LLSTTU) THEN
          ILSTTC=INDEX (CDSTTC,' ')-1
          IF (ILSTTC.GT.0) ILSTTU=ILSTTC
          CLSTTC=CDSTTC(:ILSTTU)
        ELSE
          CLSTTC=CHINCO(:ILSTTU)
        ENDIF
C
      ENDIF
C
      IREP=0
C
  105 CONTINUE
      IREPX=IREP
      INPPIM=NPPIMM(IRANG)
      IFACTM=MFACTM(IRANG)
      ILARPH=JPLARD*IFACTM
      INALPP=JPNAPP*IFACTM
      INBALO=MDES1D(IXM(JPNALO,IRANG))
      INTPPI=(INBALO-1+INALPP)/INALPP
C**
C     2.  -  TRAITEMENT D'EVENTUELS "TROUS" D'INDEX DE LONGUEUR ZERO.
C            CES "PARASITES" PEUVENT AVOIR ETE CREES PAR LE RECYCLAGE
C            DE TROUS DANS LE FICHIER; ON VA LES SUPPRIMER.
C
C         L'ALGORITHME CHOISI N'EST PEUT-ETRE PAS LE PLUS EFFICACE;
C     MAIS A PARTIR DU MOMENT OU LA PROBABILITE DE GENERER DES TROUS
C     DE LONGUEUR NULLE EST FAIBLE, ET OU ON NE LES RETASSE
C     QU'A LA FERMETURE, IL N'Y A PAS LIEU DE RAFFINER A OUTRANCE !
C-----------------------------------------------------------------------
C
      INTRLZ=NTRULZ(IRANG)
      IF (INTRLZ.EQ.0) GOTO 300
C
      IDECAL=0
      IPOTZC=NRFPTZ(IRANG)
      IRGPFC=1+(IPOTZC-1)/INALPP
C*
C     2.1 - MISE EN MEMOIRE DE LA PREMIERE P.A.I. AYANT UN TEL TROU.
C-----------------------------------------------------------------------
C
      DO 211 J=1,INPPIM
      IRGPMC=MRGPIM(J,IRANG)
C
      IF (MRGPIF(IRGPMC).EQ.IRGPFC) THEN
C
      IF (.NOT.LPHASP(IRGPMC)) THEN
C
        CALL LFIPHA (IREP,IRANG,IRGPMC,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        GOTO 220
C
      ENDIF
C
  211 CONTINUE
C
      ILFORC=IRGPFC+1
      INPILE=2
      CALL LFIPIM (IREP,IRANG,IRANGM,IRGPMC,IRGPFC,ILFORC,INPILE,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
      INPPIM=MAX0 (INPPIM,IRANGM)
C
  220 CONTINUE
C*
C     2.2 - AMORCAGE DE LA RECHERCHE DU NOMBRE DE TROUS NULS CONSECUTIFS
C           ET DE L'EVENTUEL TROU NUL "SUIVANT" CE PAQUET.
C-----------------------------------------------------------------------
C
      IPOTZS=IPOTZC+IDECAL
      IRGPFS=1+(IPOTZS-1)/INALPP
      IPOTZE=IPOTZS
      IRGPMS=0
C
C       ON ELIMINE LES CAS "TRIVIAUX"
C
      IF (INTRLZ.EQ.1.OR.IPOTZE+INTRLZ.GT.INBALO) THEN
        INTCON=INTRLZ
        IPOSFE=INBALO
        GOTO 250
      ENDIF
C*
C     2.3 - DECOMPTE DU NOMBRE DE TROUS NULS CONSECUTIFS.
C-----------------------------------------------------------------------
C
      DO 235 JNPAGE=IRGPFS,INTPPI
      IRGPFE=JNPAGE
C
      DO 231 J=1,INPPIM
      IRGPME=MRGPIM(J,IRANG)
C
      IF (MRGPIF(IRGPME).EQ.IRGPFE) THEN
C
        IF (.NOT.LPHASP(IRGPME)) THEN
C
          CALL LFIPHA (IREP,IRANG,IRGPME,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        GOTO 233
C
      ENDIF
C
  231 CONTINUE
C
      INPILE=2
      CALL LFIPIM (IREP,IRANG,IRANGM,IRGPME,IRGPFE,IRGPFC,INPILE,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
      INPPIM=MAX0 (INPPIM,IRANGM)
C
  233 CONTINUE
      IF (IRGPMS.EQ.0) IRGPMS=IRGPME
      IDECDB=IPOTZE-1-(IRGPFE-1)*INALPP
      INBARE=MIN0 (INBALO,IRGPFE*INALPP)-IPOTZE+1
      INTCON=0
C
      DO 234 J=1,INBARE
C
      IF (MLGPOS(IXM(2*(J+IDECDB)-1,IRGPME)).NE.0) THEN
        INTCON=INTCON+J-1
        GOTO 240
      ENDIF
C
  234 CONTINUE
C
      INTCON=INTCON+INBARE
      IPOTZE=IPOTZE+INBARE
  235 CONTINUE
C*
C     2.4 - RECHERCHE DU PROCHAIN TROU NUL, APRES LE PAQUET TROUVE.
C-----------------------------------------------------------------------
C
  240 CONTINUE
      IPOTZE=IPOTZE+INTCON
C
C             D'ABORD, ELIMINATION DES CAS "TRIVIAUX"
C
      IF (INTCON.EQ.INTRLZ) THEN
C
C        ON A TROUVE TOUS LES TROUS NULS RESTANT.
C
        IPOSFE=INBALO
      ELSEIF (INTCON.EQ.(INTRLZ-1)) THEN
C
C        PLUS QU'UN SEUL TROU NUL... CE SERA DONC CELUI DE RANG MAXIMUM.
C
        IPOSFE=NRFDTZ(IRANG)-1
      ELSE
C
C          CAS GENERAL.
C
        DO 245 JNPAGE=IRGPFE,INTPPI
C
        IF (JNPAGE.NE.IRGPFE) THEN
C
          DO 241 J=1,INPPIM
          IRGPME=MRGPIM(J,IRANG)
C
          IF (MRGPIF(IRGPME).EQ.JNPAGE) THEN
C
            IF (.NOT.LPHASP(IRGPME)) THEN
C
              CALL LFIPHA (IREP,IRANG,IRGPME,IRETIN)
C
              IF (IRETIN.EQ.1) THEN
                GOTO 903
              ELSEIF (IRETIN.EQ.2) THEN
                GOTO 904
              ELSEIF (IRETIN.NE.0) THEN
                GOTO 1001
              ENDIF
C
            ENDIF
C
            GOTO 243
C
          ENDIF
C
  241     CONTINUE
C
          INPILE=2
          CALL LFIPIM (IREP,IRANG,IRANGM,IRGPME,JNPAGE,IRGPFC,INPILE,
     S                 IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
          INPPIM=MAX0 (INPPIM,IRANGM)
        ENDIF
C
  243   CONTINUE
        IDECDB=IPOTZE-1-(JNPAGE-1)*INALPP
        INBARE=MIN0 (INBALO,JNPAGE*INALPP)-IPOTZE+1
C
        DO 244 J=1,INBARE
C
        IF (MLGPOS(IXM(2*(J+IDECDB)-1,IRGPME)).EQ.0) THEN
          IPOSFE=(JNPAGE-1)*INALPP+J-1
          GOTO 250
        ENDIF
C
  244   CONTINUE
C
  245   CONTINUE
C
      ENDIF
C
  250 CONTINUE
C*
C     2.5 - RETASSAGE "A GAUCHE" D'UNE PARTIE DE L'INDEX.
C-----------------------------------------------------------------------
C
      IDECAL=IDECAL+INTCON
C
  251 CONTINUE
      IPOTZS=IPOTZC+IDECAL
      IRGPC2=1+(IPOTZC-1)/INALPP
      IRGPS2=1+(IPOTZS-1)/INALPP
C
      IF (IRGPC2.NE.IRGPFC) THEN
        IRGPFC=IRGPC2
C
        DO 252 J=2,INPPIM
        IRGPMC=MRGPIM(J,IRANG)
C
        IF (MRGPIF(IRGPMC).EQ.IRGPFC) THEN
C
          IF (.NOT.LPHASP(IRGPMC)) THEN
C
            CALL LFIPHA (IREP,IRANG,IRGPMC,IRETIN)
C
            IF (IRETIN.EQ.1) THEN
              GOTO 903
            ELSEIF (IRETIN.EQ.2) THEN
              GOTO 904
            ELSEIF (IRETIN.NE.0) THEN
              GOTO 1001
            ENDIF
C
          ENDIF
C
          GOTO 254
C
        ENDIF
C
  252   CONTINUE
C
        INPILE=2
        CALL LFIPIM (IREP,IRANG,IRANGM,IRGPMC,IRGPFC,IRGPS2,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
        INPPIM=MAX0 (INPPIM,IRANGM)
      ENDIF
C
  254 CONTINUE
C
      IF (IRGPS2.NE.IRGPFS) THEN
        IRGPFS=IRGPS2
C
        DO 255 J=2,INPPIM
        IRGPMS=MRGPIM(J,IRANG)
C
        IF (MRGPIF(IRGPMS).EQ.IRGPFS) THEN
C
          IF (.NOT.LPHASP(IRGPMS)) THEN
C
            CALL LFIPHA (IREP,IRANG,IRGPMS,IRETIN)
C
            IF (IRETIN.EQ.1) THEN
              GOTO 903
            ELSEIF (IRETIN.EQ.2) THEN
              GOTO 904
            ELSEIF (IRETIN.NE.0) THEN
              GOTO 1001
            ENDIF
C
          ENDIF
C
          GOTO 257
C
        ENDIF
C
  255   CONTINUE
C
        INPILE=2
        CALL LFIPIM (IREP,IRANG,IRANGM,IRGPMS,IRGPFS,IRGPFC,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
        INPPIM=MAX0 (INPPIM,IRANGM)
      ENDIF
C
  257 CONTINUE
      IDECDC=IPOTZC-1+(IRGPFC-1)/INALPP
      INBARC=MIN0 (INBALO-IDECAL,IRGPFC*INALPP)-IPOTZC+1
      IDECDS=IPOTZS-1+(IRGPFS-1)/INALPP
      INBARS=MIN0 (INBALO,IRGPFS*INALPP)-IPOTZS+1
      INBART=MIN0 (INBARC,INBARS)
C
      DO 258 J=1,INBART
      CNOMAR(IXC(IDECDC+J,IRGPMC))=CNOMAR(IXC(IDECDS+J,IRGPMS))
  258 CONTINUE
C
      DO 259 J=1,2*INBART
      MLGPOS(IXM(2*IDECDC+J,IRGPMC))=MLGPOS(IXM(2*IDECDS+J,IRGPMS))
  259 CONTINUE
C
      IPOTZC=IPOTZC+INBART
C
      IF (IPOTZS+INBART.LT.IPOSFE) THEN
        GOTO 251
      ELSEIF (IPOSFE.LT.INBALO) THEN
        GOTO 220
      ENDIF
C*
C     2.6 - MISE A JOUR DE CERTAINES TABLES.
C-----------------------------------------------------------------------
C
      NBTROU(IRANG)=NBTROU(IRANG)-IDECAL
      INBALO=INBALO-IDECAL
      MDES1D(IXM(JPNALO,IRANG))=INBALO
      INTPPN=(INBALO-1+INALPP)/INALPP
      NALDPI(IRANG)=INBALO-(INTPPN-1)*INALPP
C
      IF (INTPPN.NE.INTPPI) THEN
C
C           ON A DONC LAISSE DES P.P.I. "PARASITES" EN MEMOIRE.
C        A PRIORI CE N'EST PAS GENANT, CAR ON VA BIENTOT RELACHER
C        TOUTES CELLES RELATIVES AU FICHIER QUE L'ON TRAITE.
C        NEANMOINS IL EST PREFERABLE DE REDEFINIR LE RANG EN MEMOIRE
C        DE LA DERNIERE P.P.I. DU FICHIER.
C
        NPODPI(IRANG)=IRGPMC
        INTPPI=INTPPN
      ENDIF
C
  300 CONTINUE
C**
C     3.  -  CAS OU IL FAUT RECALCULER LES LONGUEURS EXTREMES DES
C            ARTICLES DE DONNEES.
C-----------------------------------------------------------------------
C
      IF (.NOT.LMIMAL(IRANG)) GOTO 400
C*
C     3.1 - EXPLORATION DES P.P.I., PUIS EVENTUELLEMENT DES P.A.I. .
C-----------------------------------------------------------------------
C
      ILOMIN=0
      ILOMAX=0
      IRPIFN=1
      INPIME=0
C
      IF (NPODPI(IRANG).EQ.2) THEN
        IDEBEX=3
      ELSE
        IDEBEX=2
      ENDIF
C
      DO 317 JNPAGE=1,INTPPI
C
      IF (JNPAGE.LE.INPPIM) THEN
C
C           IL S'AGIT D'UNE EXPLORATION EN MEMOIRE ( PAGES D'INDEX ).
C
        IRGPIM=MRGPIM(JNPAGE,IRANG)
        IRGPIF=MRGPIF(IRGPIM)
        INPIME=INPIME+1
        IEXPLO(INPIME)=IRGPIF
        IF (IRGPIF.EQ.(IRPIFN+1)) IRPIFN=IRGPIF
C
        IF (.NOT.LPHASP(IRGPIM)) THEN
C
          CALL LFIPHA (IREP,IRANG,IRGPIM,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
      ELSE
C
C           IL S'AGIT D'UNE EXPLORATION "HORS MEMOIRE";
C         ON CHERCHE LA PROCHAINE P.A.I. NON EXPLOREE .
C
        IF (JNPAGE.EQ.INPPIM+1) IRGPIF=IRPIFN
C
  311   CONTINUE
        IRGPIF=IRGPIF+1
C
        DO 312 J=IDEBEX,INPIME
        IF (IEXPLO(J).EQ.IRGPIF) GOTO 311
  312   CONTINUE
C
        ILFORC=1
        INPILE=2
        CALL LFIPIM (IREP,IRANG,IRANGM,IRGPIM,IRGPIF,ILFORC,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      INBART=MIN0 (INALPP,INBALO-(IRGPIF-1)*INALPP)
C
      IF (ILOMIN.EQ.0) THEN
C
        DO 314 J=1,INBART
C
        IF (CNOMAR(IXC(J,IRGPIM)).NE.' ') THEN
          ILOMIN=MLGPOS(IXM(2*J-1,IRGPIM))
          ILOMAX=ILOMIN
          IDEBUT=J+1
          GOTO 315
        ENDIF
C
  314   CONTINUE
C
        GOTO 317
      ELSE
        IDEBUT=1
      ENDIF
C
  315 CONTINUE
C
      DO 316 J=IDEBUT,INBART
C
      IF (CNOMAR(IXC(J,IRGPIM)).NE.' ') THEN
        ILONGA=MLGPOS(IXM(2*J-1,IRGPIM))
        ILOMIN=MIN0 (ILONGA,ILOMIN)
        ILOMAX=MAX0 (ILONGA,ILOMAX)
      ENDIF
C
  316 CONTINUE
C
  317 CONTINUE
C*
C     3.2 - MISE A JOUR DES TABLES CONCERNEES.
C-----------------------------------------------------------------------
C
      MDES1D(IXM(JPLNAL,IRANG))=ILOMIN
      MDES1D(IXM(JPLXAL,IRANG))=ILOMAX
C
  400 CONTINUE
C**
C     4.  -  "VIDAGE" SUR FICHIER DES PAGES RESTANT A ECRIRE.
C-----------------------------------------------------------------------
C*
C     4.1 -  PAGES DE *DONNEES* RESTANT A ECRIRE.
C-----------------------------------------------------------------------
C
      DO 411 J=0,JPNPDF-1
C
      IF (LECRPD(J,IRANG)) THEN
C
        CALL LFIVID (IREP,IRANG,J,ITAMPO(1),IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
  411 CONTINUE
C*
C     4.2 -  (PAIRES DE) PAGES D'*INDEX* RESTANT A ECRIRE.
C-----------------------------------------------------------------------
C
      INPPIM=NPPIMM(IRANG)
C
      DO 423 J=1,INPPIM
      IRGPIM=MRGPIM(J,IRANG)
      IRGPIF=MRGPIF(IRGPIM)
      CALL LFIREC (IRGPIF,IRANG,IREC)
C
      IF (LECRPI(IRGPIM,1)) THEN
C
        IF (J.EQ.NPODPI(IRANG).AND.NALDPI(IRANG).NE.INALPP) THEN
C
C          COMPLEMENT DE LA DERNIERE PAGE D'INDEX NOMS AVEC UN NOM
C        CONVENTIONNEL.
C
          DO 421 JJ=NALDPI(IRANG)+1,JPNXNA*IFACTM
          CNOMAR(IXC(JJ,IRGPIM))='**FIN D''INDEX**'
  421     CONTINUE
C
        ENDIF
C
        INAPHY=IREC
        CALL LFIECC (IREP,KNUMER,IREC,CNOMAR(IXC(1,IRGPIM)),
     S               NBWRIT(IRANG),IFACTM,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
        LECRPI(IRGPIM,1)=.FALSE.
      ENDIF
C
      IF (LECRPI(IRGPIM,2).AND.LPHASP(IRGPIM)) THEN
C
        IF (J.EQ.NPODPI(IRANG).AND.NALDPI(IRANG).NE.INALPP) THEN
C
C          COMPLEMENT DE LA DERNIERE PAGE D'INDEX LONGUEUR/POSITION
C        AVEC DES ZEROS.
C
          DO 422 JJ=2*NALDPI(IRANG)+1,ILARPH
          MLGPOS(IXM(JJ,IRGPIM))=0
  422     CONTINUE
C
        ENDIF
C
        INAPHY=IREC+1
        CALL LFIEDO (IREP,KNUMER,IREC+1,MLGPOS(IXM(1,IRGPIM)),
     S               NBWRIT(IRANG),IFACTM,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
        LECRPI(IRGPIM,2)=.FALSE.
      ENDIF
C
  423 CONTINUE
C*
C     4.3 -  CAS DE L'ARTICLE DOCUMENTAIRE, SI NECESSAIRE.
C-----------------------------------------------------------------------
C
      LLECRD=LMODIF(IRANG).OR.NBWRIT(IRANG).NE.0
C
      IF (LLECRD) THEN
C
C        AU PREALABLE, MISE A JOUR DE CET ARTICLE DOCUMENTAIRE.
C
        IAUXIL=IXM(JPNRES,IRANG)
        MDES1D(IAUXIL)=MDES1D(IAUXIL)+NREESP(IRANG)
        IAUXIL=IXM(JPNREC,IRANG)
        MDES1D(IAUXIL)=MDES1D(IAUXIL)+NREECO(IRANG)
        IAUXIL=IXM(JPNREL,IRANG)
        MDES1D(IAUXIL)=MDES1D(IAUXIL)+NREELO(IRANG)
        IAUXIL=IXM(JPNTRU,IRANG)
        MDES1D(IAUXIL)=MDES1D(IAUXIL)+NBTROU(IRANG)
        CALL LFIDAH (MDES1D(IXM(JPDDMG,IRANG)),
     S               MDES1D(IXM(JPHDMG,IRANG)))
        IREC=1
        INAPHY=IREC
        CALL LFIEDO (IREP,KNUMER,IREC,MDES1D(IXM(1,IRANG)),
     S               NBWRIT(IRANG),IFACTM,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C**
C     5.  -  FERMETURE EFFECTIVE (*CLOSE*) DU FICHIER.
C-----------------------------------------------------------------------
C
      INALDO=INBALO-MDES1D(IXM(JPNTRU,IRANG))
      INAPHY=0
C
      IF (LLSTTU) THEN
        CLOSE (UNIT=KNUMER,STATUS=CLSTTC,ERR=905,IOSTAT=IREP)
      ELSE
C
        IF (INALDO.EQ.0) THEN
C
C       SI ON SE RETROUVE AVEC UN FICHIER "VIDE" ET QUE L'ON N'A PAS DE
C       PARAMETRE "STATUS" POUR LE "CLOSE", ON VA ESSAYER DE RELACHER LE
C       FICHIER, AFIN DE NE PAS LAISSER TRAINER UN TEL FICHIER "ZOMBIE".
C             ( "VIDE" = SANS ARTICLE LOGIQUE DE DONNEES )
C       ON N'A PAS DE GARANTIE D'Y ARRIVER, DANS LA MESURE OU ON N'EST
C       PAS SUR D'AVOIR DES DROITS D'ACCES SUFFISANTS.
C
          CLOSE (UNIT=KNUMER,STATUS='DELETE',ERR=511)
          CLSTTC='DELETE'
          LLSTTU=.TRUE.
          GOTO 600
        ENDIF
C
  511   CONTINUE
C
        CLOSE (UNIT=KNUMER,ERR=905,IOSTAT=IREP)
C
      ENDIF
C
  600 CONTINUE
C**
C     6.  -  IMPRESSION EVENTUELLE DE STATISTIQUES D'UTILISATION.
C-----------------------------------------------------------------------
C
      NDEROP(IRANG)=9
      NDERCO(IRANG)=IREP
      LLIMST=NISTAG.EQ.2.OR.(NISTAG.EQ.1.AND.LISTAT(IRANG))
      IF (LLIMST) CALL LFIIST (IRANG,.TRUE.)
C**
C     7.  -  "NETTOYAGE" DES TABLES AYANT PERMIS DE GERER LE FICHIER.
C            ( AU MOINS CELLES AYANT UN CARACTERE "GLOBAL"; A NOTER
C              TOUTEFOIS QU'ON NE TOUCHE PAS AUX CARACTERISTIQUES DES
C              PAGES D'INDEX PREAFFECTEES )
C-----------------------------------------------------------------------
C
       IF (LMULTI) CALL LFIVER (VERGLA,'ON')
      LLVERG=LMULTI
C
      DO 702 J=2,MIN0 (INPPIM,JPNPIA)
      IRGPIM=MRGPIM(J,IRANG)
C
      DO 701 JR=IRGPIM,IRGPIM+IFACTM-1
      MRGPIF(JR)=JPNIL
  701 CONTINUE
C
  702 CONTINUE
C
      DO 704 J=JPNPIA+1,INPPIM
      IRGPIM=MRGPIM(J,IRANG)
C
      DO 703 JR=IRGPIM,IRGPIM+IFACTM-1
      MCOPIF(JR)=JPNIL
      MRGPIF(JR)=JPNIL
  703 CONTINUE
C
  704 CONTINUE
C
      NPISAF=NPISAF-MAX0 (0,(INPPIM-JPNPIA)*IFACTM)
C
      DO 705 JR=IRANG,IRANG+IFACTM-1
      NUMERO(JR)=JPNIL
  705 CONTINUE
C
      DO 706 J=1,NBFIOU
C
      IF (NUMIND(J).EQ.IRANG) THEN
        IPOSNU=J
        GOTO 707
      ENDIF
C
  706 CONTINUE
C
      IREP=-16
      GOTO 1001
C
  707 CONTINUE
C
      NBFIOU=NBFIOU-1
      NFACTM=NFACTM-IFACTM
C
      DO 708 J=IPOSNU,NBFIOU
      NUMIND(J)=NUMIND(J+1)
  708 CONTINUE
C*
C     7.1 -  ASPECTS SPECIFIQUES AUX TABLES D'IMPORT/EXPORT.
C-----------------------------------------------------------------------
C
      IF (NEXPOR(IRANG).GT.0.OR.NIMPOR(IRANG).GT.0) THEN
        IRANIE=MAX0 (NEXPOR(IRANG),NIMPOR(IRANG))
        INIMES=IXNIMS (IRANG)
C
        IF (INIMES.GE.1) THEN
          WRITE (UNIT=CLMESS,FMT='(''KNUMER='',I3,
     S           '', ATTENTION: IMPORT/EXPORT NON TERMINE'')') KNUMER
          CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
        ENDIF
C
        DO 711 J=1,NUIMEX
C
        IF (NINIEX(J).EQ.IRANIE) THEN
          IPOSNU=J
          GOTO 712
        ENDIF
C
  711   CONTINUE
C
        IREP=-16
        GOTO 1001
C
  712   CONTINUE
C
        MNUIEX(IRANG)=JPNIL
        NUIMEX=NUIMEX-1
C
        DO 713 J=IPOSNU,NUIMEX
        NINIEX(J)=NINIEX(J+1)
  713   CONTINUE
C
      ENDIF
C
       IF (LMULTI) THEN
         CALL LFIVER (VERRUE(IRANG),'OFF')
         CALL LFIVER (VERRUE(IRANG),'REL')
       ENDIF
C
      LLVERF=.FALSE.
      IREP=IREPX
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      CLACTI='READ'
      GOTO 909
C
  905 CONTINUE
      CLACTI='CLOSE'
C
  909 CONTINUE
      IF (INAPHY.NE.0) NUMAPH(IRANG)=INAPHY
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      IREP=IABS (IREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (LLFATA) THEN
        INIMES=2
      ELSE
        INIMES=IXNIMS (IRANG)
      ENDIF
C
       IF (LLVERF) CALL LFIVER (VERRUE(IRANG),'OFF')
       IF (LLVERG) CALL LFIVER (VERGLA,'OFF')
C
      IF (.NOT.LLFATA.AND.INIMES.EQ.0) RETURN
C
      IF (INIMES.EQ.2) THEN
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S         '', CDSTTC='''''',A,'''''''')')
     S      KREP,KNUMER,CLSTTC(:ILSTTU)
        CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
C       LA MESSAGERIE QUI SUIT N'EST PAS EMISE EN CAS D'ERREUR FATALE.
C
      IF (INIMES.GE.1.AND.(IREP.EQ.0.OR.IREP.EQ.-19)) THEN
        CLAUXI='   '
C
        IF (LFRANC) THEN
          WRITE (UNIT=CLMESS,FMT='(''Unite'',I3,
     S           '' traitee, Fichier'',A)')
     S            KNUMER,CLAUXI
        ELSE
          WRITE (UNIT=CLMESS,FMT='(''Unit'',I3,
     S           '' processed, File'',A)')
     S            KNUMER,CLAUXI
        ENDIF
C
        IDECAL=INDEX (CLMESS,CLAUXI)
C
        IF (INBALO.EQ.0) THEN
C
          IF (LFRANC) THEN
            CLMESS(IDECAL+1:)='*VIDE*'//CLAUXI
          ELSE
            CLMESS(IDECAL+1:)='*EMPTY*'//CLAUXI
          ENDIF
C
          IDECAL=IDECAL+INDEX (CLMESS(IDECAL+1:),CLAUXI)
        ENDIF
C
        IF (LFRANC) THEN
C
          IF (LNOUFI(IRANG)) THEN
            CLMESS(IDECAL+1:)='$CREE$ &'//CLAUXI
          ELSEIF (LLECRD) THEN
            CLMESS(IDECAL+1:)='$MODIFIE$ &'//CLAUXI
          ELSE
            CLMESS(IDECAL+1:)='non modifie &'//CLAUXI
          ENDIF
C
          IDECAL=IDECAL+INDEX (CLMESS(IDECAL+1:),CLAUXI)
C
          IF (.NOT.LLSTTU) THEN
            CLMESS(IDECAL+1:)='FERME'//CLAUXI
          ELSEIF (CLSTTC.EQ.'KEEP') THEN
            CLMESS(IDECAL+1:)='GARDE'//CLAUXI
          ELSE
            CLMESS(IDECAL+1:)='*RELACHE*'//CLAUXI
          ENDIF
C
          IF (LNOUFI(IRANG).OR.LLECRD) THEN
            IDECAL=IDECAL+INDEX (CLMESS(IDECAL+1:),CLAUXI)
            WRITE (UNIT=CLMESS(IDECAL+1:),FMT='(''a'',I9.6,''_'',I6.6,
     S       '','',I7,'' Articles de donnees,'',I9,'' mots en tout'')')
     S       MDES1D(IXM(JPDDMG,IRANG)),MDES1D(IXM(JPHDMG,IRANG)),
     S       INALDO,ILARPH*MDES1D(IXM(JPNAPH,IRANG))
          ENDIF
C
        ELSE
C
          IF (LNOUFI(IRANG)) THEN
            CLMESS(IDECAL+1:)='$CREATED$ &'//CLAUXI
          ELSEIF (LLECRD) THEN
            CLMESS(IDECAL+1:)='$MODIFIED$ &'//CLAUXI
          ELSE
            CLMESS(IDECAL+1:)='not modified &'//CLAUXI
          ENDIF
C
          IDECAL=IDECAL+INDEX (CLMESS(IDECAL+1:),CLAUXI)
C
          IF (.NOT.LLSTTU) THEN
            CLMESS(IDECAL+1:)='CLOSED'//CLAUXI
          ELSEIF (CLSTTC.EQ.'KEEP') THEN
            CLMESS(IDECAL+1:)='KEPT'//CLAUXI
          ELSE
            CLMESS(IDECAL+1:)='*RELEASED*'//CLAUXI
          ENDIF
C
          IF (LNOUFI(IRANG).OR.LLECRD) THEN
            IDECAL=IDECAL+INDEX (CLMESS(IDECAL+1:),CLAUXI)
            WRITE (UNIT=CLMESS(IDECAL+1:),FMT='(''at'',I9.6,''_'',
     S I6.6,'','',I7,'' data Records,'',I9,'' words for a whole'')')
     S       MDES1D(IXM(JPDDMG,IRANG)),MDES1D(IXM(JPHDMG,IRANG)),
     S       INALDO,ILARPH*MDES1D(IXM(JPNAPH,IRANG))
          ENDIF
C
        ENDIF
C
        CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
C
        IF (LFRANC) THEN
          INLNOM=MIN0 (NLNOMF(IRANG),JPLFIX,LEN (CLMESS)-6)
          CLMESS='Nom='''//CNOMFI(IRANG)(1:INLNOM)//''''
        ELSE
          INLNOM=MIN0 (NLNOMF(IRANG),JPLFIX,LEN (CLMESS)-7)
          CLMESS='Name='''//CNOMFI(IRANG)(1:INLNOM)//''''
        ENDIF
C
        CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
C
        IF (CNOMSY(IRANG)(1:NLNOMS(IRANG)).NE.
     S      CNOMFI(IRANG)(1:NLNOMF(IRANG))) THEN
C
          IF (LFRANC) THEN
            INLNOM=MIN0 (NLNOMS(IRANG),JPLFIX,LEN (CLMESS)-14)
            CLMESS='Nom SYSTEME='''//CNOMSY(IRANG)(1:INLNOM)//''''
          ELSE
            INLNOM=MIN0 (NLNOMS(IRANG),JPLFIX,LEN (CLMESS)-14)
            CLMESS='SYSTEM Name='''//CNOMSY(IRANG)(1:INLNOM)//''''
          ENDIF
C
          CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
        ENDIF
C
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIFMP ( KNUMER, KRANFM )
#include "lficomt.h"
C****
C        Sous-programme *INTERNE* du Logiciel de Fichiers Indexes LFI.
C     Calcule le rang de l'unite logique *KNUMER* dans la table des
C     Unites Logiques a Facteur Multiplicatif predefini;
C     si l'Unite Logique n'y est pas trouvee, le resultat est ZERO.
C
C        En mode Multi-Taches, il est necessaire de verrouiller
C     Globalement le code faisant appel a ce sous-programme.
C**
C       ARGUMENTS : KNUMER (Entree) ==> Numero d'unite logique cherche;
C                   KRANFM (Sortie) ==> Rang dans la table des unites
C                                       logiques a Facteur Multiplicatif
C                                       predefini (0 si pas trouve).
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KNUMER, KRANFM, J, IRANFM
C**
C     1.  -  RECHERCHE DIRECTE DANS LA TABLE *MULOFM*.
C-----------------------------------------------------------------------
C
      DO 101 J=1,NULOFM
C
      IF (KNUMER.EQ.MULOFM(J)) THEN
        IRANFM=J
        GOTO 102
      ENDIF
C
  101 CONTINUE
C
      IRANFM=0
C
  102 CONTINUE
      KRANFM=IRANFM
C
      RETURN
      END
      SUBROUTINE LFIINI ( KOPTIO )
#include "lficomt.h"
C****
C        CE SOUS-PROGRAMME EST CHARGE DES INITIALISATIONS DU LOGICIEL
C     DE FICHIERS INDEXES LFI .
C**
C        ARGUMENT : KOPTIO  ==> OPTION CONCERNANT LE MODE D'UTILISATION.
C                  (ENTREE)     (MULTI-TACHE OU NON)
C     VALEURS POSSIBLES : 0 ==> MODE MONO-TACHE PRESCRIT
C                         1 ==> MODE MULTI-TACHE PRESCRIT
C                         2 ==> UTILISATION DU MODE PAR DEFAUT SI C'EST
C                               LE PREMIER APPEL; SINON ON GARDE LE MODE
C                               PRESCRIT ANTERIEUREMENT .
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KOPTIO, JNPAGE, J, JRANG, IREP, INIMES, INUMER, IRGPIM
C
      LOGICAL LLPREA, LLDEFM, LLNMUL, LLASGN, LLREL
      SAVE LLPREA, LLDEFM
C
      DATA LLPREA /.TRUE./, LLDEFM /.FALSE./
C
      IF (LLPREA) THEN
C
C         C'EST LE PREMIER APPEL AU SOUS-PROGRAMME - INITIALISATIONS .
C
        NBFIOU=0
        NFACTM=0
        NULOFM=0
        NUIMEX=0
        NERFAG=1
        NISTAG=1
        NIMESG=1
        NPISAF=0
        LTAMLG=.FALSE.
        LTAMEG=.TRUE.
        LMISOP=.FALSE.
        LFRANC=.TRUE.
        LERFAT(0)=.TRUE.
        NIVMES(0)=0
C
C          L'indice zero dans MFACTU correspond au facteur multiplicatif
C     "par defaut" .
C
        MFACTU(0)=1
        MFACTM(0)=0
        NUMAPH(0)=JPNIL
C
        CFGMXD(0)='locale'
        NBMOSD(0)=JPNBIM
        NBCASD(0)=JPNBIC
        CFGMXD(1)='ieee'
        NBMOSD(1)=32
        NBCASD(1)=8
        CFGMXD(2)='ultrix'
        NBMOSD(2)=32
        NBCASD(2)=8
        CFGMXD(3)='ieee_dp'
        NBMOSD(3)=64
        NBCASD(3)=8
        CFGMXD(4)='ultrix_dp'
        NBMOSD(4)=64
        NBCASD(4)=8
        CTYPMX='ircdl'
C
        DO 101 JNPAGE=1,JPNXPI
        MCOPIF(JNPAGE)=JPNIL
        MRGPIF(JNPAGE)=JPNIL
        LECRPI(JNPAGE,1)=.FALSE.
        LECRPI(JNPAGE,2)=.FALSE.
  101   CONTINUE
C
        DO 103 J=1,JPNPIA
C
        DO 102 JRANG=1,JPNXFI
        IRGPIM=JRANG+(J-1)*JPNXFI
        MCOPIF(IRGPIM)=JRANG
        MRGPIM(J,JRANG)=IRGPIM
  102   CONTINUE
C
  103   CONTINUE
C
        DO 104 JRANG=1,JPNXFI
        MRGPIF(JRANG)=1
        NUMERO(JRANG)=JPNIL
        NUMAPH(JRANG)=JPNIL
  104   CONTINUE
C
        DO 105 J=1,JPNCPN
        CHINCO(J:J)='?'
  105   CONTINUE
C
        DO 106 J=1,JPIMEX
        MNUIEX(J)=JPNIL
        NREXPL(0,J)=0
  106   CONTINUE
C
        LLPREA=.FALSE.
        LLNMUL=(KOPTIO.EQ.1).OR.(KOPTIO.EQ.2.AND.LLDEFM)
        LLASGN=LLNMUL
        LLREL=.FALSE.
C
      ELSEIF (KOPTIO.EQ.2) THEN
C
C         CE N'EST PAS LE PREMIER APPEL, MAIS COMME L'ARGUMENT VAUT 2,
C         ON LAISSE LES CHOSES EN PLACE .
C
        LLNMUL=LMULTI
        LLASGN=.FALSE.
        LLREL =.FALSE.
      ELSE
C
C     CE N'EST PAS LE PREMIER APPEL ET LE MODE EST PASSE 'EXPLICITEMENT'
C
        LLNMUL=KOPTIO.EQ.1
        LLASGN=LLNMUL.AND.(.NOT.LMULTI)
        LLREL =(.NOT.LLNMUL).AND.LMULTI
C
        IF ((LLASGN.OR.LLREL).AND.NBFIOU.NE.0) THEN
          IREP=-4
          GOTO 1001
        ENDIF
C
      ENDIF
C
      LMULTI=LLNMUL
C
C        Le controle de coherence ci-dessous ne peut etre fait qu'apres
C     l'initialisation eventuelle des variables globales du logiciel.
C
      IF (KOPTIO.LT.0.OR.KOPTIO.GT.2) THEN
        IREP=-2
        GOTO 1001
      ENDIF
C
      IREP=0
C
      IF (LLASGN) THEN
        CALL LFIVER (VERGLA,'ASGN')
      ELSEIF (LLREL) THEN
        CALL LFIVER (VERGLA,'REL')
      ENDIF
C
 1001 CONTINUE
C
C        MESSAGERIE EVENTUELLE, AVEC ABORT SI NECESSAIRE .
C
      LLFATA=IREP.NE.0.AND.NERFAG.NE.2
C
      IF (LLFATA) THEN
        INIMES=2
      ELSEIF (IREP.NE.0) THEN
        INIMES=0
      ELSEIF (NIMESG.EQ.2.OR.(NIMESG.EQ.1.AND.KOPTIO.NE.2)) THEN
        INIMES=NIMESG
      ELSE
        RETURN
      ENDIF
C
      CLNSPR='LFIINI'
      INUMER=JPNIL
C
      IF (MAX0 (INIMES,NIMESG).EQ.2) THEN
C
        IF (LFRANC) THEN
          WRITE (UNIT=CLMESS,FMT='(''KOPTIO='',I5,'', CODE INTERNE='',
     S           I4)') KOPTIO,IREP
        ELSE
          WRITE (UNIT=CLMESS,FMT='(''KOPTIO='',I5,'', INTERNAL CODE='',
     S           I4)') KOPTIO,IREP
        ENDIF
C
        IF (INIMES.NE.2) CALL LFIEMS (INUMER,NIMESG,IREP,.FALSE.,CLMESS,
     S                                CLNSPR,CLACTI)
      ENDIF
C
      CALL LFIEMS (INUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      IF (INIMES.GE.1.AND.KOPTIO.NE.2) THEN
C
C        Cette messagerie de niveau 1 n'est pas emise en cas d'erreur,
C     meme non fatale.
C
        IF (LFRANC) THEN
C
          IF (KOPTIO.EQ.0) THEN
            CLMESS='$ Mode MONO-TACHE Prescrit explicitement... $'
          ELSE
            CLMESS='$ Mode MULTI-TACHE Prescrit explicitement... $'
          ENDIF
C
        ELSE
C
          IF (KOPTIO.EQ.0) THEN
            CLMESS='$ MONO-TASKING Mode explicitely Specified... $'
          ELSE
            CLMESS='$ MULTI-TASKING Mode explicitely Specified... $'
          ENDIF
C
        ENDIF
C
        CALL LFIEMS (INUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIIST ( KRANG, LDAPFE )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME IMPRIMANT LES STATISTIQUES D'UTILISATION D'UNE
C     UNITE LOGIQUE TRAITEE PAR LE LOGICIEL DE FICHIERS INDEXES LFI.
C     CE SOUS-PROGRAMME EST ***A USAGE INTERNE*** DU LOGICIEL; CELUI
C     A APPELER PAR L'UTILISATEUR QUI DESIRE AVOIR CES STATISTIQUES
C     AUTREMENT QU'A LA FERMETURE DU FICHIER EST *LFISTA* .
C**
C    ARGUMENTS : KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                LDAPFE (ENTREE) ==> VRAI SI L'APPEL EST FAIT LORS DE
C                                    LA FERMETURE (PAR *LFIFER*) .
C
C    Modifications:
C
C    02/06/97, Jean Clochard.
C
C              -Modification des impressions pour que l'annee puisse
C               etre imprimee avec 4 chiffres.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CLOPER*(JPLSPX)
C
#ifndef f77
      INTEGER (KIND=JPDBLE) IIDATE, IIHEUR
#else
      INTEGER IIDATE, IIHEUR
#endif
      INTEGER KRANG, INUMER, IREP, IMDESC, IDATEM, IHEURM, IANNEE, IMOIS
      INTEGER IJOUR, IHEURE, IMINUT, ISECON, IDECAL, IDERNI, INLNOM, J
      INTEGER IDEROP, IDERCO, IDERAP, INBPIR, INBALO, IFACTM, ILARPH
      INTEGER INALPP, ILONGF, ILDONN, INTRUA, INALDO, INPPIU, INUTIL
      INTEGER INTRUO, ILOMIN, ILOMAX, IREESP, IREECO, IREELO, INALIP
      INTEGER INAMAX, INMOUL, INMOUE, INMOUT, INMOLL, INMOLE, INMOLT
      INTEGER INLECT, INECRI, INRENO, INSUPP, INIMES, INTPPI
C
      LOGICAL LDAPFE
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL.
C-----------------------------------------------------------------------
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI) THEN
        INUMER=JPNIL
      ELSE
        INUMER=NUMERO(KRANG)
        IREP=0
      ENDIF
C
      IF (INUMER.EQ.JPNIL) THEN
        IREP=-14
        GOTO 1001
      ENDIF
C**
C     2.  -  IMPRESSION DES STATISTIQUES.
C-----------------------------------------------------------------------
C
      CALL LFIDAH (IIDATE,IIHEUR)
      IDATEM=IIDATE
      IHEURM=IIHEUR
      IANNEE=IDATEM/10000
      IJOUR =MOD (IDATEM,100)
      IMOIS =IDATEM/100-100*IANNEE
      IHEURE=IHEURM/10000
      ISECON=MOD (IHEURM,100)
      IMINUT=IHEURM/100-100*IHEURE
C
      IF (LFRANC) THEN
        PRINT 9010,INUMER,IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
C
        IF (LDAPFE) THEN
          PRINT 9020
        ELSEIF (LNOUFI(KRANG)) THEN
          PRINT 9025
        ENDIF
C
      ELSE
        PRINT 9011,INUMER,IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
C
        IF (LDAPFE) THEN
          PRINT 9021
        ELSEIF (LNOUFI(KRANG)) THEN
          PRINT 9026
        ENDIF
C
      ENDIF
C
      IF (.NOT.LDAPFE.OR.IXNIMS(KRANG).EQ.0) THEN
C
        IF (LFRANC) THEN
          CLMESS=' X NOM du Fichier='''
        ELSE
          CLMESS=' X File NAME='''
        ENDIF
C
        IDECAL=INDEX (CLMESS,'''')
        IDERNI=111
        INLNOM=MIN0 (NLNOMF(KRANG),JPLFIX,IDERNI-2-IDECAL)
        CLMESS(IDECAL+1:IDECAL+INLNOM+1)=CNOMFI(KRANG)(1:INLNOM)//''''
        CLMESS(IDERNI:IDERNI)='X'
        PRINT 9015,CLMESS
C
        IF (CNOMSY(KRANG).NE.CNOMFI(KRANG)) THEN
C
          IF (LFRANC) THEN
            CLMESS=' X NOM *SYSTEME*: '''
          ELSE
            CLMESS=' X SYSTEM NAME: '''
          ENDIF
C
          IDECAL=INDEX (CLMESS,'''')
          IDERNI=111
          INLNOM=MIN0 (NLNOMS(KRANG),JPLFIX,IDERNI-2-IDECAL)
          CLMESS(IDECAL+1:IDECAL+INLNOM+1)=CNOMSY(KRANG)(1:INLNOM)//''''
          CLMESS(IDERNI:IDERNI)='X'
          PRINT 9015,CLMESS
        ENDIF
C
      ENDIF
C
      IDEROP=NDEROP(KRANG)
C
      IF (IDEROP.EQ.0) THEN
        CLOPER='LFIOUV'
      ELSEIF (IDEROP.EQ.1) THEN
        CLOPER='LFIECR'
      ELSEIF (IDEROP.EQ.2) THEN
        CLOPER='LFILEC'
      ELSEIF (IDEROP.EQ.3) THEN
        CLOPER='LFIMST'
      ELSEIF (IDEROP.EQ.4) THEN
        CLOPER='LFIERF'
      ELSEIF (IDEROP.EQ.5) THEN
        CLOPER='LFINIM'
      ELSEIF (IDEROP.EQ.6) THEN
        CLOPER='LFITAM'
      ELSEIF (IDEROP.EQ.7) THEN
        CLOPER='LFINFO'
      ELSEIF (IDEROP.EQ.8) THEN
        CLOPER='LFISTA'
      ELSEIF (IDEROP.EQ.9) THEN
        CLOPER='LFIFER'
      ELSEIF (IDEROP.EQ.10) THEN
        CLOPER='LFILAS'
      ELSEIF (IDEROP.EQ.11) THEN
        CLOPER='LFICAS'
      ELSEIF (IDEROP.EQ.12) THEN
        CLOPER='LFINAF'
      ELSEIF (IDEROP.EQ.13) THEN
        CLOPER='LFIREN'
      ELSEIF (IDEROP.EQ.14) THEN
        CLOPER='LFIPOS'
      ELSEIF (IDEROP.EQ.15) THEN
        CLOPER='LFISUP'
      ELSEIF (IDEROP.EQ.16) THEN
        CLOPER='LFILAP'
      ELSEIF (IDEROP.EQ.17) THEN
        CLOPER='LFICAP'
      ELSEIF (IDEROP.EQ.18) THEN
        CLOPER='LFILAF'
      ELSEIF (IDEROP.EQ.19) THEN
        CLOPER='LFIOEF'
      ELSEIF (IDEROP.EQ.20) THEN
        CLOPER='LFIOSF'
      ELSEIF (IDEROP.EQ.21) THEN
        CLOPER='LFIOMF'
      ELSEIF (IDEROP.EQ.22) THEN
        CLOPER='LFIPXF'
      ELSE
        CLOPER=CHINCO(:JPLSPX)
      ENDIF
C
      IDERCO=NDERCO(KRANG)
      IDERAP=MDES1D(IXM(JPNAPH,KRANG))
      INBPIR=MDES1D(IXM(JPNPIR,KRANG))
      INBALO=MDES1D(IXM(JPNALO,KRANG))
      IFACTM=MFACTM(KRANG)
      ILARPH=JPLARD*IFACTM
      INALPP=JPNAPP*IFACTM
C
      IF (LMODIF(KRANG).AND..NOT.LDAPFE) THEN
C
C         Il faut inclure, dans la longueur totale du fichier,
C     les eventuels articles physiques (de donnees, mais aussi d'index)
C     qui n'auraient pas encore ete ecrits.
C
        DO 201 J=0,JPNPDF-1
        IDERAP=MAX0 (IDERAP,NUMAPD(J,KRANG))
  201   CONTINUE
C
        INTPPI=(INBALO-1+INALPP)/INALPP
C
        IF (INTPPI.GT.INBPIR) THEN
          IMDESC=MDES1D(IXM(ILARPH+1-INTPPI+INBPIR,KRANG))
          IDERAP=MAX0 (IDERAP,IMDESC+1)
        ENDIF
C
      ENDIF
C
      ILONGF=ILARPH*IDERAP
      ILDONN=MDES1D(IXM(JPLTAL,KRANG))
C
      IF (LDAPFE) THEN
        INTRUA=MDES1D(IXM(JPNTRU,KRANG))
      ELSE
        INTRUA=MDES1D(IXM(JPNTRU,KRANG))+NBTROU(KRANG)
      ENDIF
C
      INALDO=INBALO-INTRUA
C
C        NOMBRE DE P.P.I. "UTILES" (EN DECOMPTANT LES TROUS D'INDEX)
C
      INPPIU=(INALDO-1+INALPP)/INALPP
      INUTIL=ILONGF-ILDONN-ILARPH*(1+2*INPPIU)
      INTRUO=NBTROU(KRANG)
      ILOMIN=MDES1D(IXM(JPLNAL,KRANG))
      ILOMAX=MDES1D(IXM(JPLXAL,KRANG))
C
      IF (LFRANC) THEN
        PRINT 9030,CLOPER,IDERCO
        PRINT 9040,ILONGF,ILDONN,ILARPH,INUTIL
        PRINT 9050,INTRUA,INTRUO
C
        IF (LDAPFE.OR..NOT.LMIMAL(KRANG)) THEN
          PRINT 9060,INALDO,ILOMIN,ILOMAX
        ELSE
          PRINT 9070,INALDO,ILOMIN,ILOMAX
        ENDIF
C
      ELSE
        PRINT 9031,CLOPER,IDERCO
        PRINT 9041,ILONGF,ILDONN,ILARPH,INUTIL
        PRINT 9051,INTRUA,INTRUO
C
        IF (LDAPFE.OR..NOT.LMIMAL(KRANG)) THEN
          PRINT 9061,INALDO,ILOMIN,ILOMAX
        ELSE
          PRINT 9071,INALDO,ILOMIN,ILOMAX
        ENDIF
C
      ENDIF
C
      IF (LDAPFE) THEN
        IREESP=MDES1D(IXM(JPNRES,KRANG))-NREESP(KRANG)
        IREECO=MDES1D(IXM(JPNREC,KRANG))-NREECO(KRANG)
        IREELO=MDES1D(IXM(JPNREL,KRANG))-NREELO(KRANG)
      ELSE
        IREESP=MDES1D(IXM(JPNRES,KRANG))
        IREECO=MDES1D(IXM(JPNREC,KRANG))
        IREELO=MDES1D(IXM(JPNREC,KRANG))
      ENDIF
C
      IDATEM=MDES1D(IXM(JPDCRE,KRANG))
      IHEURM=MDES1D(IXM(JPHCRE,KRANG))
      IANNEE=IDATEM/10000
      IJOUR =MOD (IDATEM,100)
      IMOIS =IDATEM/100-100*IANNEE
      IHEURE=IHEURM/10000
      ISECON=MOD (IHEURM,100)
      IMINUT=IHEURM/100-100*IHEURE
C
      IF (LFRANC) THEN
        IF (.NOT.LNOUFI(KRANG))
     S     PRINT 9080,' AVANT',IREESP,IREECO,IREELO
        PRINT 9080,'DEPUIS',NREESP(KRANG),NREECO(KRANG),NREELO(KRANG)
        PRINT 9090,'CREATION du FICHIER (Premiere Ouverture)',
     S             IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
      ELSE
        IF (.NOT.LNOUFI(KRANG))
     S     PRINT 9081,'BEFORE',IREESP,IREECO,IREELO
        PRINT 9081,' SINCE',NREESP(KRANG),NREECO(KRANG),NREELO(KRANG)
        PRINT 9091,'FILE CREATION (Very First Opening)  ',
     S             IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
      ENDIF
C
      IF (.NOT.LNOUFI(KRANG).OR.LMODIF(KRANG)) THEN
        IDATEM=MDES1D(IXM(JPDMNG,KRANG))
        IHEURM=MDES1D(IXM(JPHMNG,KRANG))
        IANNEE=IDATEM/10000
        IJOUR =MOD (IDATEM,100)
        IMOIS =IDATEM/100-100*IANNEE
        IHEURE=IHEURM/10000
        ISECON=MOD (IHEURM,100)
        IMINUT=IHEURM/100-100*IHEURE
C
        IF (LFRANC) THEN
          PRINT 9090,'Premiere Modification "NON GARANTIE"    ',
     S               IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
        ELSE
          PRINT 9091,'First "not guaranteed" Modification  ',
     S               IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
        ENDIF
C
      ENDIF
C
      IF (LDAPFE.OR..NOT.LNOUFI(KRANG)) THEN
        IDATEM=MDES1D(IXM(JPDDMG,KRANG))
        IHEURM=MDES1D(IXM(JPHDMG,KRANG))
        IANNEE=IDATEM/10000
        IJOUR =MOD (IDATEM,100)
        IMOIS =IDATEM/100-100*IANNEE
        IHEURE=IHEURM/10000
        ISECON=MOD (IHEURM,100)
        IMINUT=IHEURM/100-100*IHEURE
C
        IF (LFRANC) THEN
          PRINT 9090,'Derniere FERMETURE apres Modification   ',
     S               IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
        ELSE
          PRINT 9091,'Last CLOSE made after a Modification',
     S               IANNEE,IMOIS,IJOUR,IHEURE,IMINUT,ISECON
        ENDIF
C
      ENDIF
C
      INALIP=INALPP*INBPIR
      INAMAX=INALIP+INALPP*(ILARPH-JPLDOC)
      INMOUL=NBMOLU(KRANG)
      INMOUE=NBMOEC(KRANG)
      INMOUT=INMOUL+INMOUE
      INMOLL=ILARPH*NBREAD(KRANG)
      INMOLE=ILARPH*NBWRIT(KRANG)
      INMOLT=INMOLL+INMOLE
      INLECT=NBLECT(KRANG)
      INECRI=NBNECR(KRANG)+NREESP(KRANG)+NREECO(KRANG)+NREELO(KRANG)
      INRENO=NBRENO(KRANG)
      INSUPP=NBSUPP(KRANG)
C
      IF (LFRANC) THEN
        PRINT 9100,INALIP,INAMAX
        PRINT 9110,'UTILISATEUR','EN LECTURE','EN ECRITURE',
     S             INMOUL,INMOUE,INMOUT
        PRINT 9110,' LOGICIEL  ','PAR "READ"','PAR "WRITE"',
     S             INMOLL,INMOLE,INMOLT
        PRINT 9120,INLECT,INECRI,INRENO,INSUPP
      ELSE
        PRINT 9101,INALIP,INAMAX
        PRINT 9111,'  USER  ',' For INPUT  ',' For OUTPUT  ',
     S             INMOUL,INMOUE,INMOUT
        PRINT 9111,'SOFTWARE','Through READ','Through WRITE',
     S             INMOLL,INMOLE,INMOLT
        PRINT 9121,INLECT,INECRI,INRENO,INSUPP
      ENDIF
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", ET ABORT EVENTUEL.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (IREP,KRANG)
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFIIST'
        WRITE (UNIT=CLMESS,FMT='(''IREP='',I4,'', KRANG='',I3,
     S         '', LDAPFE= '',L1)') IREP,KRANG,LDAPFE
        CALL LFIEMS (INUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
 9010 FORMAT (/,/,T2,110('X'),/,' X',T111,'X',/,' X',T15,
     S 'Statistiques d''Utilisation de l''Unite Logique Indexee',I4,
     S ' (le',I5.2,2('/',I2.2),' a',I3.2,2(':',I2.2),')',T111,'X',
     S /,' X',T15,42('- '),'-',T111,'X',/,' X',T111,'X')
C
 9011 FORMAT (/,/,T2,110('X'),/,' X',T111,'X',/,' X',T15,
     S 'Statistics of Use for LFI Indexed Logical Unit Number',I4,
     S ' (on',I5.2,2('/',I2.2),' at',I3.2,2(':',I2.2),')',T111,'X',
     S /,' X',T15,42('- '),'-',T111,'X',/,' X',T111,'X')
C
 9015 FORMAT (A,/,' X',T111,'X')
C
 9020 FORMAT (' X',T29,
     S '----- Cette Unite Logique est en cours de FERMETURE -----',
     S T111,'X',/,' X',T111,'X')
C
 9021 FORMAT (' X',T30,
     S '----- This Logical Unit is currently being CLOSED -----',
     S T111,'X',/,' X',T111,'X')
C
 9025 FORMAT (' X',T30,
     S '----- Cette Unite Logique est en mode "CREATION" -----',
     S T111,'X',/,' X',T111,'X')
C
 9026 FORMAT (' X',T31,
     S '----- This Logical Unit is in "CREATION" Mode -----',
     S T111,'X',/,' X',T111,'X')
C
 9030 FORMAT (' X  Dernier Sous-Programme utilise: "',A6,
     S '", Code-Reponse correspondant a cet appel:',I4,
     S T111,'X',/,' X',T111,'X')
C
 9031 FORMAT (' X  Name of Last Used SUBROUTINE: "',A6,
     S '", Response Code corresponding to this call:',I4,
     S T111,'X',/,' X',T111,'X')
C
 9040 FORMAT (' X  LONGUEUR TOTALE en mots: du FICHIER=',I9,
     S ', des DONNEES=',I9,', d''un Article "PHYSIQUE"=',I6,T111,'X',
     S /,' X',T111,'X',/,' X  Mots "PERDUS" par l''Utili',
     S 'sation (Articles d''Index inutiles, Trous, Fin du fichier) =',
     S I8,T111,'X',/,' X',T111,'X')
C
 9041 FORMAT (' X  TOTAL LENGTH in words: of FILE=',I9,
     S ', of DATA=',I9,', of a "PHYSICAL" Record=',I6,T111,'X',
     S /,' X',T111,'X',/,' X  Words currently "LOST" by previous ',
     S 'Usage (Unnecessary Index Records, Holes, End of file)=',
     S I8,T111,'X',/,' X',T111,'X')
C
 9050 FORMAT (' X  Nombre de TROUS REPERTORIES: Actuellement',I6,
     S ', dont',I6,' CREE(S) et NON RECYCLE(S) depuis OUVERTURE',
     S T111,'X',/,' X',T111,'X')
C
 9051 FORMAT (' X  Number of HOLES within INDEX: Currently',I6,
     S ', among which',I6,' CREATED and NOT RE-USED since OPENING',
     S T111,'X',/,' X',T111,'X')
C
 9060 FORMAT (' X  Nombre d''ARTICLES LOGIQUES de DONNEES=',I6,
     S ', Longueur Mini/Maxi=',I7,' /',I7,T111,'X',/,' X',T111,'X')
C
 9061 FORMAT (' X  Number of LOGICAL RECORDS of DATA=',I6,
     S ', Minimum/maximum length=',I7,' /',I7,T111,'X',/,' X',T111,'X')
C
 9070 FORMAT (' X  Nombre d''ARTICLES LOGIQUES de DONNEES=',I6,
     S ', Longueur Mini/Maxi (A PRIORI)=',I7,' /',I7,
     S T111,'X',/,' X',T111,'X')
C
 9071 FORMAT (' X  Number of LOGICAL RECORDS of DATA=',I6,
     S ', Minimum/Maximum Length (A PRIORI)=',I7,' /',I7,
     S T111,'X',/,' X',T111,'X')
C
 9080 FORMAT (' X  ',A6,' Ouverture, Nombre de REECRITURES Sur PLACE/',
     S 'Plus COURTES/Plus LONGUES=',I6,2(' /',I6),
     S T111,'X',/,' X',T111,'X')
C
 9081 FORMAT (' X  ',A6,' Opening, Number of RE-WRITE(s): In PLACE/',
     S 'SHORTER/LONGER=',I6,2(' /',I6),
     S T111,'X',/,' X',T111,'X')
C
 9090 FORMAT (' X  ',A40,' le',I5.2,2('/',I2.2),' a',I3.2,2(':',I2.2),
     S T111,'X',/,' X',T111,'X')
C
 9091 FORMAT (' X  ',A36,' on',I5.2,2('/',I2.2),' at',I3.2,2(':',I2.2),
     S T111,'X',/,' X',T111,'X')
C
 9100 FORMAT(' X  Nombre d''ARTICLES LOGIQUES gerables (TROUS compris)',
     S       ' SANS/AVEC DEBORDEMENT =',I7,' /',I7,
     S T111,'X',/,' X',T111,'X')
C
 9101 FORMAT(' X  Number of LOGICAL RECORDS STORE-able (HOLES included)'
     S       ,' WITHOUT/WITH OVERFLOW=',I7,' /',I7,
     S T111,'X',/,' X',T111,'X')
C
 9110 FORMAT (' X  Nombre de Mots ',A11,' demandes ',A10,'/',A11,
     S        '/AU TOTAL=',I9,2(' /',I9),T111,'X',/,' X',T111,'X')
C
 9111 FORMAT (' X  Number of ',A8,' Words requested ',A12,'/',A13,
     S        '/TOTAL=',I9,2(' /',I9),T111,'X',/,' X',T111,'X')
C
 9120 FORMAT (' X  Nombre d''ARTICLES LOGIQUES LUS/ECRITS/RENOMMES/',
     S        'SUPPRIMES depuis Ouverture=',I6,3(' /',I6),
     S T111,'X',/,' X',T111,'X',/,T2,110('X'),/)
C
 9121 FORMAT (' X  Number of LOGICAL RECORDS: READ/WRITTEN/RENAMED/',
     S        'SUPPRESSED since Opening = ',I6,3(' /',I6),
     S T111,'X',/,' X',T111,'X',/,T2,110('X'),/)
C
      END
      SUBROUTINE LFILAF ( KREP, KNUMER, LDTOUT )
#include "lficomt.h" 
C****
C        Sous-programme donnant, pour une unite logique ouverte au sens
C     du logiciel de fichiers indexes *LFI*, la Liste des Articles logi-
C     ques de donnees presents dans le Fichier, liste donnee toutefois
C     dans l'ordre PHYSIQUE ou ceux-ci figurent dans le fichier.
C        Sur option on donne aussi des renseignements sur les articles
C     (physiques) de gestion propres au logiciel, ainsi que sur les
C     trous repertories dans l'index.
C**
C    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
C                KNUMER (Entree) ==> Numero de l'unite logique;
C                LDTOUT (Entree) ==> Vrai si on doit donner les rensei-
C                                    gnements optionnels (qui ne concer-
C                                    nent pas directement les articles
C                                    logiques de donnees).
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP, KNUMER, IMDESC, IREP, IRANG, INTROU, INBPIR, INBALO
      INTEGER INALDO, IFACTM, ILARPH, INALPP, INTPPI, INPPIM, INIMES, J
      INTEGER INAGES, IRESER, INUTIL, IPERTE, IPOSFI, IPOSDE, INEXCE
      INTEGER INABAL, INALDI, INTROI, INPIMD, INPIMF, INPILE, JRGPIF
      INTEGER IRGPFS, IRGPIM, IRANGM, IRPIMS, INALPI, ILONGA, IRECPI
      INTEGER IDERPU, IREC, IRETIN
C
      LOGICAL LDTOUT
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IREP=0
      IRANG=0
      CLNSPR='LFILAF'
      CALL LFINUM (KNUMER,IRANG)
C
      IF (IRANG.EQ.0) THEN
        IREP=-1
        GOTO 1001
      ENDIF
C
      IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
      INTROU=MDES1D(IXM(JPNTRU,IRANG))+NBTROU(IRANG)
      INBPIR=MDES1D(IXM(JPNPIR,IRANG))
      INBALO=MDES1D(IXM(JPNALO,IRANG))
      INALDO=INBALO-INTROU
      IFACTM=MFACTM(IRANG)
      ILARPH=JPLARD*IFACTM
      INALPP=JPNAPP*IFACTM
      INTPPI=(INBALO-1+INALPP)/INALPP
      INPPIM=NPPIMM(IRANG)
C
C         Envoi d'une banniere.
C
      WRITE (UNIT=*,FMT='(///)')
C
      IF (LFRANC) THEN
        WRITE (UNIT=CLMESS,FMT='(''Catalogue de l''''Unite Logique LFI''
     S ,I3,'' dans l''''ordre *PHYSIQUE* (sequentiel) des articles'')')
     S     KNUMER
      ELSE
        WRITE (UNIT=CLMESS,FMT='(''Catalog of LFI Logical Unit'',I3,
     S         '' in *PHYSICAL* (sequential) record order'')') KNUMER
      ENDIF
C
      INIMES=2
      LLFATA=.FALSE.
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C**
C     2.  -  SUR OPTION, RENSEIGNEMENTS SUR LES ARTICLES "DE GESTION".
C            (ARTICLE DOCUMENTAIRE, PAIRES D'ARTICLES D'INDEX)
C-----------------------------------------------------------------------
C
      IF (LDTOUT) THEN
        INAGES=1+2*INBPIR
        IRESER=ILARPH*INAGES
C
        IF (LFRANC) THEN
          WRITE (UNIT=*,FMT='(//,TR1,I6,
     S           '' article(s) "physique(s)" de gestion,'',I6,
     S           '' mots chacun, occupant donc'',I7,'' mots; detail:'',
     S /,TR10,''Article documentaire de la position 1 a'',I6,/,TR10,I6,
     S'' paire(s) d''''articles d''''index prereserves, de la position''
     S           ,I6,'' a'',I7)')
     S         INAGES,ILARPH,IRESER,ILARPH,INBPIR,ILARPH+1,IRESER
        ELSE
          WRITE (UNIT=*,FMT='(//,TR1,I6,
     S           '' "physical" records for file handling,'',I6,
     S           '' words each, occupying then'',I7,'' words; detail:'',
     S /,TR10,''Documentary record from position 1 to'',I6,/,TR10,I6,
     S'' pair(s) of pre-reserved index records, from position''
     S           ,I6,'' to'',I7)')
     S         INAGES,ILARPH,IRESER,ILARPH,INBPIR,ILARPH+1,IRESER
        ENDIF
C
        IF (INTPPI.LT.INBPIR) THEN
          INUTIL=INBPIR-INTPPI
          IPERTE=ILARPH*INUTIL*2
C
          IF (LFRANC) THEN
            WRITE (UNIT=*,FMT='(/,TR10,5(''=''),''> Il y a'',I3,
     S '' paire(s) d''''articles d''''index inutilises, representant'',
     S             I8,'' mots'')') INUTIL,IPERTE
          ELSE
            WRITE (UNIT=*,FMT='(/,TR10,5(''=''),''> There is (are)'',I3,
     S '' pair(s) of unused index records, leading to a loss of'',
     S             I8,'' words'')') INUTIL,IPERTE
          ENDIF
C
        ELSEIF (INTPPI.EQ.INBPIR) THEN
C
          IF (LFRANC) THEN
            WRITE (UNIT=*,FMT='(TR15,5(''-''),TR3,''pas de paire '',
     S        ''d''''articles d''''index inutilises ni excedentaires'',
     S          TR3,5(''-''))')
          ELSE
            WRITE (UNIT=*,FMT='(TR15,5(''-''),TR3,''no pair of '',
     S        ''unused or overflow pages'',
     S          TR3,5(''-''))')
          ENDIF
C
        ELSEIF (INTPPI.EQ.(INBPIR+1)) THEN
          IPOSFI=ILARPH*(MDES1D(IXM(ILARPH,IRANG))+1)
          IPOSDE=IPOSFI-2*ILARPH+1
C
          IF (LFRANC) THEN
            WRITE (UNIT=*,FMT='(TR10,''une paire d''''articles '',
     S             ''d''''index excedentaires, de la position'',
     S             I9,'' a'',I9)')
     S      IPOSDE,IPOSFI
          ELSE
            WRITE (UNIT=*,FMT='(TR10,''one pair of overflow index '',
     S             ''pages ,from position'',
     S             I9,'' to'',I9)')
     S      IPOSDE,IPOSFI
          ENDIF
C
        ELSE
          INEXCE=INTPPI-INBPIR
C
          IF (LFRANC) THEN
            WRITE (UNIT=*,FMT='(TR10,I6,'' paires d''''articles '',
     S           ''d''''index excedentaires, des positions:'')') INEXCE
C
            DO 201 J=1,INEXCE
            IPOSFI=ILARPH*(MDES1D(IXM(ILARPH+1-J,IRANG))+1)
            IPOSDE=IPOSFI-2*ILARPH+1
            WRITE (UNIT=*,FMT='(TR20,I9,'' a'',I9)') IPOSDE,IPOSFI
  201       CONTINUE
C
          ELSE
            WRITE (UNIT=*,FMT='(TR10,I6,'' pairs of overflow index '',
     S           ''pages, from positions:'')') INEXCE
C
            DO 202 J=1,INEXCE
            IPOSFI=ILARPH*(MDES1D(IXM(ILARPH+1-J,IRANG))+1)
            IPOSDE=IPOSFI-2*ILARPH+1
            WRITE (UNIT=*,FMT='(TR20,I9,'' to'',I9)') IPOSDE,IPOSFI
  202       CONTINUE
C
          ENDIF
C
        ENDIF
C
      ENDIF
C
      WRITE (UNIT=*,FMT='(//)')
C**
C     3.  -  RENSEIGNEMENTS INDIVIDUALISES SUR LES ARTICLES LOGIQUES.
C            (DONNEES, ET SUR OPTION TROUS REPERTORIES DANS L'INDEX)
C-----------------------------------------------------------------------
C
      IF (LFRANC) THEN
C
        IF (INBALO.EQ.0) THEN
          WRITE (UNIT=*,FMT='(/,TR10,5(''=''),''> L''''unite logique'',
     S I3,'' ne contient AUCUN ARTICLE LOGIQUE (ni donnees, ni trous)'',
     S           //)') KNUMER
          GOTO 1001
        ELSEIF (INBALO.EQ.INTROU) THEN
          WRITE (UNIT=*,FMT='(/,TR10,5(''=''),''> L''''unite logique'',
     S I3,'' ne contient QUE DES TROUS, pas de donnees)'',//)') KNUMER
          IF (.NOT.LDTOUT) GOTO 1001
        ENDIF
C
      ELSE
C
        IF (INBALO.EQ.0) THEN
          WRITE (UNIT=*,FMT='(/,TR10,5(''=''),''> The logical unit'',I3,
     S '' contains NO LOGICAL RECORD AT ALL (neither data, nor holes)'',
     S           //)') KNUMER
          GOTO 1001
        ELSEIF (INBALO.EQ.INTROU) THEN
          WRITE (UNIT=*,FMT='(/,TR10,5(''=''),''> The logical unit'',I3,
     S '' contains ONLY HOLES, no dat)'',//)') KNUMER
          IF (.NOT.LDTOUT) GOTO 1001
        ENDIF
C
      ENDIF
C*
C     3.1 -  BALAYAGE DES PAIRES D'ARTICLES D'INDEX, PAR ORDRE CROISSANT
C-----------------------------------------------------------------------
C
      INABAL=0
      INALDI=0
      INTROI=0
      INPIMD=2
      INPIMF=INPPIM
      IF (NPODPI(IRANG).EQ.2) INPIMD=3
      IF (NPODPI(IRANG).EQ.INPPIM) INPIMF=INPPIM-1
      INPILE=2
C
      DO 319 JRGPIF=1,INTPPI
      IRGPFS=JRGPIF+1
C
C        On fait en sorte que la P.A.I. concernee, ainsi que sa suivante
C     eventuelle, soient toutes les deux en memoire.
C
      IF (JRGPIF.EQ.INTPPI) THEN
        IRGPIM=MRGPIM(NPODPI(IRANG),IRANG)
        GOTO 314
C
      ELSEIF (JRGPIF.NE.1) THEN
C
C       Recherche de la P.A.I. dans les Paires de Pages d'Index memoire.
C
        DO 311 J=INPIMD,INPIMF
        IRGPIM=MRGPIM(J,IRANG)
C
        IF (MRGPIF(IRGPIM).EQ.JRGPIF) THEN
C
          IF (.NOT.LPHASP(IRGPIM)) THEN
C
            CALL LFIPHA (IREP,IRANG,IRGPIM,IRETIN)
C
            IF (IRETIN.EQ.1) THEN
              GOTO 903
            ELSEIF (IRETIN.EQ.2) THEN
              GOTO 904
            ELSEIF (IRETIN.NE.0) THEN
              GOTO 1001
            ENDIF
C
          ENDIF
C
          GOTO 312
C
        ENDIF
C
  311   CONTINUE
C
C          Mise en memoire de la Paire d'Articles d'Index cherchee.
C
        CALL LFIPIM (IREP,IRANG,IRANGM,IRGPIM,JRGPIF,IRGPFS,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ELSEIF (IRANGM.GT.INPPIM) THEN
          INPPIM=IRANGM
          INPIMF=INPPIM
        ENDIF
C
      ELSE
        IRGPIM=MRGPIM(1,IRANG)
C
      ENDIF
C
  312 CONTINUE
C
      IF (IRGPFS.EQ.INTPPI) THEN
        IRPIMS=MRGPIM(NPODPI(IRANG),IRANG)
C
      ELSE
C
C       Recherche de la P.A.I. dans les Paires de Pages d'Index memoire.
C
        DO 313 J=INPIMD,INPIMF
        IRPIMS=MRGPIM(J,IRANG)
C
        IF (MRGPIF(IRPIMS).EQ.IRGPFS) THEN
C
          IF (.NOT.LPHASP(IRPIMS)) THEN
C
            CALL LFIPHA (IREP,IRANG,IRPIMS,IRETIN)
C
            IF (IRETIN.EQ.1) THEN
              GOTO 903
            ELSEIF (IRETIN.EQ.2) THEN
              GOTO 904
            ELSEIF (IRETIN.NE.0) THEN
              GOTO 1001
            ENDIF
C
          ENDIF
C
          GOTO 314
C
        ENDIF
C
  313   CONTINUE
C
C          Mise en memoire de la Paire d'Articles d'Index cherchee.
C
        CALL LFIPIM (IREP,IRANG,IRANGM,IRPIMS,IRGPFS,JRGPIF,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ELSEIF (IRANGM.GT.INPPIM) THEN
          INPPIM=IRANGM
          INPIMF=INPPIM
        ENDIF
C
      ENDIF
C
  314 CONTINUE
      INALPI=MIN0 (INALPP,INBALO-INABAL)
C
C        Balayage de la Paire d'Article d'Index concernee.
C
      DO 318 J=1,INALPI
C
      IF (CNOMAR(IXC(J,IRGPIM)).NE.' ') THEN
C
C              Il s'agit d'un article logique de donnees; en plus de ses
C         caracteristiques tabulees, on verifie s'il n'y a pas de la
C         place "perdue" juste derriere les donnees, place recuperable
C         eventuellement en cas de reecriture plus longue de l'article
C         logique.
C
        INALDI=INALDI+1
        ILONGA=MLGPOS(IXM(2*J-1,IRGPIM))
        IPOSDE=MLGPOS(IXM(2*J  ,IRGPIM))
        IPOSFI=IPOSDE+ILONGA-1
C
        IF (J.EQ.1.AND.JRGPIF.GT.INBPIR) THEN
C
C          Cas du premier article logique d'une P.A.I. excedentaire;
C     dans ce cas, la P.A.I. est situee derriere l'article logique,
C     en occupant deux articles physiques.
C
          IRECPI=MDES1D(IXM(ILARPH+1-(JRGPIF-INBPIR),IRANG))
          IDERPU=ILARPH*(IRECPI-1)
C
        ELSEIF (J.EQ.INALPI.AND.JRGPIF.EQ.INTPPI) THEN
C
C          Cas du dernier article logique du fichier, sans P.A.I. situee
C     derriere: la derniere position utilisable sans modifier le nombre
C     d'articles physiques du fichier correspond a la fin du dernier
C     article physique contenant des donnees, ou a la fin du dernier
C     article physique ecrit sur le fichier.
C
          IMDESC=MDES1D(IXM(JPNAPH,IRANG))
          IREC=MAX0 (1+(IPOSFI-1)/ILARPH,IMDESC)
          IDERPU=ILARPH*IREC
C
C          Si on arrive au test ci-dessous, on est sur que l'article lo-
C     gique n'est pas le dernier du fichier.
C
        ELSEIF (J.NE.INALPP) THEN
C
C          Cas general, ou l'article logique n'est pas le dernier de sa
C     (Paire de) Page(s) d'Index.
C
          IDERPU=MLGPOS(IXM(2*J+2,IRGPIM))-1
C
        ELSE
C
C          Cas particulier ou l'article logique est le dernier de sa
C     (Paire de) Page(s) d'Index.
C
          IDERPU=MLGPOS(IXM(2,IRPIMS))-1
        ENDIF
C
        IF (IDERPU.EQ.IPOSFI) THEN
C
          IF (LFRANC) THEN
            WRITE (UNIT=*,FMT='(I7,''-eme article de donnees: "'',A,
     S             ''",'',I7,'' mots, position'',I9,'' a'',I9)')
     S       INALDI,CNOMAR(IXC(J,IRGPIM)),ILONGA,IPOSDE,IPOSFI
          ELSE
            WRITE (UNIT=*,FMT='(I7,''-th data record: "'',A,''",'',I7,
     S             '' words, position'',I9,'' to'',I9)')
     S       INALDI,CNOMAR(IXC(J,IRGPIM)),ILONGA,IPOSDE,IPOSFI
          ENDIF
C
        ELSE
C
C           On visualise en plus la place "perdue" derriere l'article.
C
          IF (LFRANC) THEN
            WRITE (UNIT=*,FMT='(I7,''-eme article de donnees: "'',A,
     S             ''",'',I7,'' mots, position'',I9,'' a'',I9,'' <'',SP,
     S             I8,'' >'')')
     S   INALDI,CNOMAR(IXC(J,IRGPIM)),ILONGA,IPOSDE,IPOSFI,IDERPU-IPOSFI
          ELSE
            WRITE (UNIT=*,FMT='(I7,''-th data record: "'',A,''",'',I7,
     S             '' words, position'',I9,'' to'',I9,'' <'',SP,
     S             I8,'' >'')')
     S   INALDI,CNOMAR(IXC(J,IRGPIM)),ILONGA,IPOSDE,IPOSFI,IDERPU-IPOSFI
          ENDIF
C
        ENDIF
C
      ELSEIF (LDTOUT) THEN
        INTROI=INTROI+1
        ILONGA=MLGPOS(IXM(2*J-1,IRGPIM))
        IPOSDE=MLGPOS(IXM(2*J  ,IRGPIM))
        IPOSFI=IPOSDE+ILONGA-1
C
        IF (LFRANC) THEN
          WRITE (UNIT=*,FMT='(TR1,5(''=''),''>'',T10,I6,
     S ''-eme TROU repertorie dans l''''index, longueur reutilisable:'',
     S         I7,'' mots, position'',I9,'' a'',I9)')
     S   INTROI,ILONGA,IPOSDE,IPOSFI
        ELSE
          WRITE (UNIT=*,FMT='(TR1,5(''=''),''>'',T10,I6,
     S ''-th HOLE cataloged within index, re-usable length:'',
     S         I7,'' words, position'',I9,'' to'',I9)')
     S   INTROI,ILONGA,IPOSDE,IPOSFI
        ENDIF
C
      ENDIF
C
  318 CONTINUE
C
      INABAL=INABAL+INALPI
  319 CONTINUE
C*
C     3.2 -  ENVOI DE MESSAGES RECAPITULATIFS.
C-----------------------------------------------------------------------
C
      IF (LFRANC) THEN
C
        IF (LDTOUT) THEN
          WRITE (UNIT=*,FMT='(//,T5,8(''-''),TR3,I7,
     S           '' articles logiques de donnees et'',I6,
     S           '' trous repertories listes'',TR3,8(''-''),//)')
     S    INALDI,INTROI
        ELSE
          WRITE (UNIT=*,FMT='(//,T5,8(''-''),TR3,I7,
     S       '' articles logiques de donnees listes'',TR3,8(''-''),//)')
     S    INALDI
        ENDIF
C
      ELSE
C
        IF (LDTOUT) THEN
          WRITE (UNIT=*,FMT='(//,T5,8(''-''),TR3,I7,
     S           '' logical records of data and'',I6,
     S           '' holes within index listed'',TR3,8(''-''),//)')
     S    INALDI,INTROI
        ELSE
          WRITE (UNIT=*,FMT='(//,T5,8(''-''),TR3,I7,
     S       '' logical records of data listed'',TR3,8(''-''),//)')
     S    INALDI
        ENDIF
C
      ENDIF
C
      IF (INALDI.EQ.INALDO.AND.(.NOT.LDTOUT.OR.INTROI.EQ.INTROU)) THEN
C
        IF (LFRANC) THEN
          WRITE (UNIT=CLMESS,FMT=
     S     '(''Fin du catalogue de l''''Unite Logique'',I3,'' ---'',I7,
     S       '' Articles logiques en tout'')') KNUMER,INBALO
        ELSE
          WRITE (UNIT=CLMESS,FMT=
     S     '(''End of catalog of Logical Unit'',I3,'' ---'',I7,
     S       '' logical Records for whole file'')') KNUMER,INBALO
        ENDIF
C
        CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
        WRITE (UNIT=*,FMT='(///)')
      ELSE
        IREP=-16
      ENDIF
C
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      CLACTI='READ'
C
  909 CONTINUE
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      IREP=IABS (IREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (IRANG.NE.0) THEN
        NDEROP(IRANG)=18
        NDERCO(IRANG)=IREP
        IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'OFF')
      ENDIF
C
      IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
        INIMES=2
      ELSE
        RETURN
      ENDIF
C
      WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S    '', LDTOUT= '',L1)') KREP,KNUMER,LDTOUT
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      RETURN
      END
      SUBROUTINE LFILCC ( KREP, KNUMER, KREC, CDTAB, KNBLEC, KFACTM,
     S                    KRETIN )
#include "lficomt.h"
C****
C        Sous-programme charge des Lectures de Chaines de Caracteres
C     du logiciel LFI (articles d'index "noms").
C**
C     Arguments: KREP   (Sortie) ==> Code-reponse ( zero si OK; code-
C                                    reponse du "READ" FORTRAN sinon);
C                KNUMER (Entree) ==> NUMERo d'unite logique FORTRAN;
C                KREC   (Entree) ==> Numero d'enregistrement a lire;
C                KTAB   (Sortie) ==> Zone a lire, de Longueur
C                                    JPLARD*KFACTM *mots*;
C                KNBLEC (Entree) ==> Compteur de LECtures sur l'unite;
C                       +Sortie)
C                KFACTM (Entree) ==> FACteur Multiplicatif LFI de
C                                    l'unite logique;
C                KRETIN (Sortie) ==> Code-retour interne.
C
#include "lficom0.h"
C
      INTEGER KREP, KNUMER, KREC, KNBLEC, KFACTM, KRETIN
C
      CHARACTER CDTAB (JPNXNA*KFACTM)*(JPNCPN)
C
C        LECTURE .
C
      READ (UNIT=KNUMER,REC=KREC,ERR=901,IOSTAT=KREP) CDTAB
C
      IF (LMISOP) THEN
        PRINT *,'+++++ LFILCC - READ / ',KNUMER,', REC = ',KREC,
     S          ' +++++'
      ENDIF
C
      KNBLEC=KNBLEC+1
      KRETIN=0
      GOTO 1001
C
  901 CONTINUE
      KRETIN=2
C
 1001 CONTINUE
C
      RETURN
C
      END
      SUBROUTINE LFILDO ( KREP, KNUMER, KREC, KTAB, KNBLEC, KFACTM,
     S                    KRETIN )
#include "lficomt.h"
C****
C        Sous-programme charge des Lectures de DOnnees du logiciel LFI,
C     *SAUF* pour les articles d'index de TYPE caractere.
C**
C     Arguments: KREP   (Sortie) ==> Code-reponse ( zero si OK; code-
C                                    reponse du "READ" FORTRAN sinon);
C                KNUMER (Entree) ==> NUMERo d'unite logique FORTRAN;
C                KREC   (Entree) ==> Numero d'enregistrement a lire;
C                KTAB   (Sortie) ==> Zone a lire, de Longueur
C                                    JPLARD*KFACTM *mots*;
C                KNBLEC (Entree  ==> Compteur de LECtures sur l'unite;
C                       +Sortie)
C                KFACTM (Entree) ==> FACteur Multiplicatif LFI de
C                                    l'unite logique;
C                KRETIN (Sortie) ==> Code-retour interne.
C
#include "lficom0.h"
C
      INTEGER KREP, KNUMER, KREC, KNBLEC, KFACTM, KRETIN
#ifndef f77
#include "precision.h"
C
      INTEGER (KIND=JPDBLE)  KTAB (JPLARD*KFACTM)
#ifdef SWAPIO
      INTEGER (KIND=JPDBLE)  KTABTMP (JPLARD*KFACTM)
#endif
#else
      INTEGER KTAB (JPLARD*KFACTM)
#endif
C
C        LECTURE .
C
#if defined(SWAPIO) && !defined(f77)
      READ (UNIT=KNUMER,REC=KREC,ERR=901,IOSTAT=KREP) KTABTMP
      CALL SWAP8(KTAB,KTABTMP,JPLARD*KFACTM)
#else
      READ (UNIT=KNUMER,REC=KREC,ERR=901,IOSTAT=KREP) KTAB
#endif
C
      IF (LMISOP) THEN
        PRINT *,'+++++ LFILDO - READ / ',KNUMER,', REC = ',KREC,
     S          ' +++++'
      ENDIF
C
      KNBLEC=KNBLEC+1
      KRETIN=0
      GOTO 1001
C
  901 CONTINUE
      KRETIN=2
C
 1001 CONTINUE
C
      RETURN
C
      END
      SUBROUTINE LFILEC ( KREP, KNUMER, CDNOMA, KTAB, KLONG )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME DE LECTURE D'UN ARTICLE (DE DONNEES) PAR *NOM*
C     SUR UNE UNITE LOGIQUE OUVERTE POUR LE LOGICIEL DE FICHIERS INDEXES
C     *LFI*; L'ARTICLE EN SORTIE EST UN "BLOC" DE DONNEES ADJACENTES.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE;
C                CDNOMA (ENTREE) ==> NOM DE L'ARTICLE A RECHERCHER;
C                KTAB   (ENTREE) ==> PREMIER MOT A LIRE;
C                KLONG  (ENTREE) ==> LONGUEUR DE L'ARTICLE A LIRE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CDNOMA*(*), CLNOMA*(JPNCPN)
C
      INTEGER KREP, KNUMER, KLONG
#ifndef f77
      INTEGER (KIND=JPDBLE)  KTAB (KLONG)
#else
      INTEGER KTAB (KLONG)
#endif
      INTEGER IREP, IRANG, ILCLNO, IREPX, ILCDNO, IDECBL, IPOSBL, IARTEX
      INTEGER ILONEX, IRGPIM, IRGPIF, IPOSEX, IRETIN, INIMES, INBALO
C
      LOGICAL LLVERF
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
C        Appel legerement anticipe a LFINUM, garantissant l'initialisa-
C     tion des variables globales du logiciel a la 1ere utilisation.
C
      CALL LFINUM (KNUMER,IRANG)
      LLVERF=.FALSE.
      IREP=0
      IREPX=0
      ILCDNO=LEN (CDNOMA)
C
      IF (ILCDNO.LE.0) THEN
        IREP=-15
        CLNOMA=CHINCO(:JPNCPN)
        ILCLNO=JPNCPN
        GOTO 1001
      ELSEIF (CDNOMA.EQ.' ') THEN
        IREP=-18
        CLNOMA=' '
        ILCLNO=1
        GOTO 1001
      ENDIF
C
C        Recherche de la longueur "utile" du nom d'article specifie.
C        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
C
      IDECBL=0
C
  101 CONTINUE
      IPOSBL=IDECBL+INDEX (CDNOMA(IDECBL+1:),' ')
C
      IF (IPOSBL.LE.IDECBL) THEN
        ILCLNO=ILCDNO
      ELSEIF (CDNOMA(IPOSBL:).EQ.' ') THEN
        ILCLNO=IPOSBL-1
      ELSE
        IDECBL=IPOSBL
        GOTO 101
      ENDIF
C
      IF (ILCLNO.LE.JPNCPN) THEN
        CLNOMA=CDNOMA(:ILCLNO)
      ELSE
        CLNOMA=CDNOMA(:JPNCPN)
        ILCLNO=JPNCPN
        IREP=-15
        GOTO 1001
      ENDIF
C
      IF (KLONG.LE.0) THEN
        IREP=-14
        GOTO 1001
      ELSEIF (IRANG.EQ.0) THEN
        IREP=-1
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
      LLVERF=LMULTI
C
      IARTEX=0
      ILONEX=0
      INBALO=MDES1D(IXM(JPNALO,IRANG))
C
      IF (INBALO.NE.0) THEN
C**
C     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
C            A LA RECHERCHE DE L'ARTICLE LOGIQUE DEMANDE.
C-----------------------------------------------------------------------
C
        CALL LFIRAN (IREP,IRANG,CLNOMA(:ILCLNO),IRGPIM,IARTEX,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      IF (IARTEX.EQ.0) THEN
        IREP=-20
        CLACTI=CLNOMA(:ILCLNO)
        GOTO 1001
      ENDIF
C
C        ON COMPLETE LES CARACTERISTIQUES DE L'ARTICLE.
C
      IRGPIF=MRGPIF(IRGPIM)
C
      IF (.NOT.LPHASP(IRGPIM)) THEN
C
        CALL LFIPHA (IREP,IRANG,IRGPIM,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      ILONEX=MLGPOS(IXM(2*IARTEX-1,IRGPIM))
      IPOSEX=MLGPOS(IXM(2*IARTEX,IRGPIM))
C
C       CONTROLE CROISE ENTRE LONGUEURS DEMANDEE ET TROUVEE SUR FICHIER.
C
      IF (ILONEX.GT.KLONG) THEN
        IREP=-21
        LLFATA=LLMOER (IREP,IRANG)
C
        IF (LLFATA) THEN
          CLACTI=CLNOMA(:ILCLNO)
          GOTO 1001
        ENDIF
C
C        SI L'ERREUR (-21) N'A PAS ETE FATALE, ON VA LIRE SEULEMENT
C       LE DEBUT DE L'ARTICLE ( LECTURE PARTIELLE DE *KLONG* MOTS )
C
      ELSEIF (ILONEX.LT.KLONG) THEN
        IREP=-22
        CLACTI=CLNOMA(:ILCLNO)
        GOTO 1001
      ENDIF
C
      IREPX=IREP
C**
C     3.  -  LECTURE DES DONNEES PROPREMENT DITE.
C-----------------------------------------------------------------------
C
      CALL LFILED (IREP,IRANG,KTAB,KLONG,IRGPIM,IPOSEX,IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
      IREP=IREPX
C**
C     4.  -   MISE A JOUR DE STATISTIQUES ET DE TABLES.
C-----------------------------------------------------------------------
C
      NBLECT(IRANG)=NBLECT(IRANG)+1
      NBMOLU(IRANG)=NBMOLU(IRANG)+KLONG
      NDERGF(IRANG)=JPNAPP*MFACTM(IRANG)*(IRGPIF-1)+IARTEX
      CNDERA(IRANG)=CLNOMA(:ILCLNO)
      NSUIVF(IRANG)=JPNIL
      NPRECF(IRANG)=JPNIL
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      CLACTI='READ'
C
  909 CONTINUE
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      IREP=IABS (IREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (IRANG.NE.0) THEN
        NDEROP(IRANG)=2
        NDERCO(IRANG)=IREP
         IF (LLVERF) CALL LFIVER (VERRUE(IRANG),'OFF')
      ENDIF
C
      IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
        INIMES=2
      ELSE
        RETURN
      ENDIF
C
      CLNSPR='LFILEC'
      WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S       '', CDNOMA='''''',A,'''''', KLONG='',I7)')
     S     KREP,KNUMER,CLNOMA(:ILCLNO),KLONG
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      RETURN
      END
      SUBROUTINE LFILED ( KREP, KRANG, KTAB, KLONG, KRGPIM, KPOSEX,
     S                    KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     LECTURE DES DONNEES PROPREMENT DITES, UNE FOIS L'ARTICLE LOGIQUE
C     DEFINI (PAR NOM, OU PAR POSITION) .
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                KTAB   (ENTREE) ==> PREMIER MOT A LIRE;
C                KLONG  (ENTREE) ==> LONGUEUR DE L'ARTICLE A LIRE;
C                KRGPIM (ENTREE) ==> RANG DANS LES TABLES CNOMAR,MLGPOS,
C                                    ETC. DE LA P.P.I. OU FIGURE
C                                    L'ARTICLE;
C                KPOSEX (ENTREE) ==> POSITION ( DANS LE FICHIER ) OU
C                                    COMMENCER A LIRE L'ARTICLE;
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP, KRANG, KLONG, KRGPIM, KPOSEX, KRETIN
#ifndef f77
      INTEGER (KIND=JPDBLE)  KTAB (KLONG), IFOURT (JPLARX)
#else
      INTEGER KTAB (KLONG), IFOURT (JPLARX)
#endif
      INTEGER INUCPL (JPNPDF), INAPHY, INUMER, ILARPH, IPODEB, IPOFIN
      INTEGER IARDEB, IARFIN, IDCDEB, IDCFIN, ICPLTI, ICPLTF, ICPTTN
      INTEGER ICPTTX, INCPLT, INUMAP, J, JD, IDECDE, IPAREC, ITAMLI
      INTEGER INUMPJ, INUMPD, IARTIC, INPDRE, INPDTA, INPDIS, INDIK1
      INTEGER INDIK2, INDIC1, INDIC2, JI, IFACTM, IRETOU, INIMES
      INTEGER IRETIN
C
      LOGICAL LLADON, LLDERN
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IRETOU=0
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI.OR.KRGPIM.LE.0.OR.KPOSEX.EQ.0)
     S     THEN
        KREP=-16
        GOTO 1001
      ENDIF
C
C        ON COMPLETE LES CARACTERISTIQUES DE L'ARTICLE.
C
      INAPHY=0
C
      IF (.NOT.LPHASP(KRGPIM)) THEN
C
        CALL LFIPHA (KREP,KRANG,KRGPIM,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      INUMER=NUMERO(KRANG)
      IFACTM=MFACTM(KRANG)
      ILARPH=JPLARD*IFACTM
      KREP=0
C**
C     2.  -   LECTURE DES DONNEES .
C-----------------------------------------------------------------------
C*
C     2.1 - UTILISATION DES ARTICLES PHYSIQUES PRESENTS EN MEMOIRE,
C           ET QUE L'ON S'APPRETE A LIRE *EN ENTIER*;
C-----------------------------------------------------------------------
C
      IPODEB=KPOSEX
      IPOFIN=KPOSEX+KLONG-1
      IARDEB=1+(IPODEB-1)/ILARPH
      IARFIN=1+(IPOFIN-1)/ILARPH
      IDCDEB=MOD (IPODEB-1,ILARPH)
      IDCFIN=MOD (IPOFIN  ,ILARPH)
      LLDERN=IDCFIN.NE.0.AND.((IARFIN.NE.IARDEB)
     S                        .OR.(IARFIN.EQ.IARDEB.AND.IDCDEB.EQ.0))
      ICPLTI=IARDEB+(IDCDEB+ILARPH-1)/ILARPH
      ICPLTF=IARFIN-1+(ILARPH-IDCFIN)/ILARPH
      ICPTTN=ICPLTF+1
      ICPTTX=ICPLTI-1
      INCPLT=0
C
      IF (LMISOP) THEN
       PRINT *,'KPOSEX= ',KPOSEX,', IPODEB= ',IPODEB,', IPOFIN= ',IPOFIN
       PRINT *,'IARDEB= ',IARDEB,', IARFIN= ',IARFIN,', IDCDEB= ',IDCDEB
       PRINT *,'IDCFIN= ',IDCFIN,', ICPLTI= ',ICPLTI,', ICPLTF= ',ICPLTF
       PRINT *,'ICPTTN= ',ICPTTN,', ICPTTX= ',ICPTTX,', LLDERN= ',LLDERN
      ENDIF
C
      IF (ICPLTF.GE.ICPLTI) THEN
C
        DO 213 J=0,JPNPDF-1
        INUMAP=NUMAPD(J,KRANG)
C
        IF (INUMAP.GE.ICPLTI.AND.INUMAP.LE.ICPLTF) THEN
          INCPLT=INCPLT+1
          INUCPL(INCPLT)=INUMAP
          ICPTTN=MIN0 (ICPTTN,INUMAP)
          ICPTTX=MAX0 (ICPTTX,INUMAP)
          IDECDE=(INUMAP-IARDEB)*ILARPH-IDCDEB
C
          IF (NLONPD(J,KRANG).LT.ILARPH) THEN
C
            IF (INUMAP.GT.MDES1D(IXM(JPAXPD,KRANG)).OR.
     S          .NOT.LECRPD(J,KRANG)) THEN
              KREP=-16
              GOTO 1001
            ELSE
              INAPHY=INUMAP
              CALL LFILDO (KREP,INUMER,INUMAP,IFOURT,NBREAD(KRANG),
     S                     IFACTM,IRETIN)
C
              IF (IRETIN.NE.0) THEN
                GOTO 904
              ENDIF
C
              DO 211 JD=NLONPD(J,KRANG)+1,ILARPH
              MTAMPD(IXT(JD,J,KRANG))=IFOURT(JD)
  211         CONTINUE
C
            ENDIF
C
            NLONPD(J,KRANG)=ILARPH
          ENDIF
C
          DO 212 JD=1,ILARPH
          KTAB(IDECDE+JD)=MTAMPD(IXT(JD,J,KRANG))
  212     CONTINUE
C
          IF (INCPLT.GT.(ICPLTF-ICPLTI)) THEN
            GOTO 220
          ENDIF
C
        ENDIF
C
  213   CONTINUE
C
      ENDIF
C
  220 CONTINUE
C*
C     2.2 - TRAITEMENT DE LA PREMIERE PAGE DE DONNEES, SI L'ARTICLE
C           LOGIQUE NE COMMENCE PAS JUSTE EN DEBUT D'ARTICLE PHYSIQUE.
C           CETTE PAGE EST CONSERVEE... DES FOIS QUE L'ACCES
C           SUIVANT AU FICHIER SOIT POUR L'ARTICLE LOGIQUE IMMEDIATEMENT
C           DEVANT (CAS DE BALAYAGE INVERSE DU FICHIER, PAR EXEMPLE) .
C-----------------------------------------------------------------------
C
      IDECDE=0
C
      IF (IDCDEB.EQ.0) THEN
        IPAREC=0
        ITAMLI=JPNPDF
      ELSE
        IPAREC=MIN0 (ILARPH*IARDEB,IPOFIN)-KPOSEX+1
        ITAMLI=JPNPDF-1
C
C           L'ARTICLE DE DONNEES A LIRE NE COMMENCE PAS AU DEBUT D'UN
C         ARTICLE PHYSIQUE. IL FAUT DONC AVOIR CET ARTICLE PHYSIQUE
C         EN MEMOIRE POUR LE COMPLETER.
C
        DO 222 J=0,JPNPDF-1
        INUMPJ=MOD (NDERPD(KRANG)+J,JPNPDF)
C
        IF (NUMAPD(INUMPJ,KRANG).EQ.IARDEB) THEN
C
C           ARTICLE PHYSIQUE CHERCHE EN MEMOIRE.
C
          IF (NLONPD(INUMPJ,KRANG).LT.(IDCDEB+IPAREC)) THEN
C
            IF (IARDEB.GT.MDES1D(IXM(JPAXPD,KRANG))) THEN
              KREP=-16
              GOTO 1001
            ELSEIF (LECRPD(INUMPJ,KRANG)) THEN
              INAPHY=IARDEB
              CALL LFILDO (KREP,INUMER,IARDEB,IFOURT,
     S                     NBREAD(KRANG),IFACTM,IRETIN)
C
              IF (IRETIN.NE.0) THEN
                GOTO 904
              ENDIF
C
              DO 221 JD=NLONPD(INUMPJ,KRANG)+1,ILARPH
              MTAMPD(IXT(JD,INUMPJ,KRANG))=IFOURT(JD)
  221         CONTINUE
C
            ELSE
              NUMAPD(INUMPJ,KRANG)=JPNIL
              INAPHY=IARDEB
              CALL LFILDO (KREP,INUMER,IARDEB,
     S                     MTAMPD(IXT(1,INUMPJ,KRANG)),
     S                     NBREAD(KRANG),IFACTM,IRETIN)
C
              IF (IRETIN.NE.0) THEN
                GOTO 904
              ENDIF
C
              NUMAPD(INUMPJ,KRANG)=IARDEB
            ENDIF
C
            NLONPD(INUMPJ,KRANG)=ILARPH
          ENDIF
C
          INUMPD=INUMPJ
          GOTO 223
        ENDIF
C
  222   CONTINUE
C
C     ARTICLE PHYSIQUE CHERCHE PAS EN MEMOIRE... ON DOIT DONC LE LIRE.
C
        INUMPD=MOD (1+NDERPD(KRANG),JPNPDF)
        INAPHY=0
C
        IF (LECRPD(INUMPD,KRANG)) THEN
C
          CALL LFIVID (KREP,KRANG,INUMPD,IFOURT,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        NUMAPD(INUMPD,KRANG)=JPNIL
        INAPHY=IARDEB
        CALL LFILDO (KREP,INUMER,IARDEB,MTAMPD(IXT(1,INUMPD,KRANG)),
     S               NBREAD(KRANG),IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 904
        ENDIF
C
        NUMAPD(INUMPD,KRANG)=IARDEB
        NLONPD(INUMPD,KRANG)=ILARPH
C
  223   CONTINUE
C
C         TRANSFERT DE LA PARTIE UTILE DES DONNEES POUR CE DEBUT
C       D'ARTICLE LOGIQUE.
C
        DO 224 JD=1,IPAREC
        KTAB(JD)=MTAMPD(IXT(IDCDEB+JD,INUMPD,KRANG))
  224   CONTINUE
C
        NDERPD(KRANG)=INUMPD
      ENDIF
C*
C     2.3 - LECTURE DES ARTICLES PHYSIQUES COMPLETS NE TENANT PAS OU NE
C           DEVANT PAS ETRE STOCKES DANS LES PAGES DE DONNEES "TAMPON".
C-----------------------------------------------------------------------
C
      IF (.NOT.LTAMPL(KRANG)) THEN
        ITAMLI=0
      ELSEIF (LLDERN) THEN
        ITAMLI=ITAMLI-1
      ENDIF
C
      IARTIC=ICPLTI-1
      INPDRE=(KLONG-IPAREC-IDCFIN+ILARPH-1)/ILARPH-INCPLT
      INPDTA=MIN0 (INPDRE,ITAMLI)
      INPDIS=INPDRE-ITAMLI
      INDIK1=1
      INDIK2=INCPLT
      LLADON=.TRUE.
C
      DO 235 J=1,INPDIS
C
  231 CONTINUE
      IARTIC=IARTIC+1
      IF (LMISOP) PRINT *,
     S      'BOUCLE 235, J= ',J,', IARTIC= ',IARTIC,', IDECDE= ',IDECDE
C
      IF (IARTIC.GE.ICPTTN.AND.IARTIC.LE.ICPTTX) THEN
        IF (IARTIC.EQ.ICPTTN) ICPTTN=ICPTTN+1
        IF (IARTIC.EQ.ICPTTX) ICPTTX=ICPTTX-1
        INDIC1=INDIK1
        INDIC2=INDIK2
C
C          ON FILTRE LES ARTICLES PHYSIQUES DEJA STOCKES DANS DES PAGES
C        DE DONNEES LORS DE LA PARTIE 2.1 ...
C
        DO 232 JI=INDIC1,INDIC2
C
        IF (IARTIC.EQ.INUCPL(JI)) THEN
          IF (JI.EQ.INDIK1+1) INDIK1=INDIK1+1
          IF (JI.EQ.INDIK2-1) INDIK2=INDIK2-1
          GOTO 231
        ENDIF
C
  232   CONTINUE
C
      ENDIF
C
      IDECDE=(IARTIC-IARDEB)*ILARPH-IDCDEB
      INAPHY=IARTIC
      CALL LFILDO (KREP,INUMER,IARTIC,KTAB(IDECDE+1),
     S             NBREAD(KRANG),IFACTM,IRETIN)
C
      IF (IRETIN.NE.0) THEN
        GOTO 904
      ENDIF

  235 CONTINUE
C*
C     2.4 - LECTURE DES ARTICLES PHYSIQUES COMPLETS QUE L'ON PEUT STOC-
C           KER DANS LES PAGES DE DONNEES "TAMPON".
C           ( TOUT EN PRESERVANT LES EMPLACEMENTS DE LA PREMIERE ET/OU
C             DE LA DERNIERE PAGE DE DONNEES, SI INCOMPLETE(S) )
C-----------------------------------------------------------------------
C
      DO 246 J=1,INPDTA
      INUMPD=MOD (NDERPD(KRANG)+J,JPNPDF)
C
  241 CONTINUE
      IARTIC=IARTIC+1
C
      IF (IARTIC.GE.ICPTTN.AND.IARTIC.LE.ICPTTX) THEN
        IF (IARTIC.EQ.ICPTTN) ICPTTN=ICPTTN+1
        IF (IARTIC.EQ.ICPTTX) ICPTTX=ICPTTX-1
        INDIC1=INDIK1
        INDIC2=INDIK2
C
C          ON FILTRE LES ARTICLES PHYSIQUES DEJA STOCKES DANS DES PAGES
C        DE DONNEES LORS DE LA PARTIE 2.1 ...
C
        DO 242 JI=INDIC1,INDIC2
C
        IF (IARTIC.EQ.INUCPL(JI)) THEN
          IF (JI.EQ.INDIK1+1) INDIK1=INDIK1+1
          IF (JI.EQ.INDIK2-1) INDIK2=INDIK2-1
          GOTO 241
        ENDIF
C
  242   CONTINUE
C
      ENDIF
C
C         SI NECESSAIRE, "VIDAGE" SUR FICHIER DE LA PAGE A UTILISER.
C
      INAPHY=0
C
      IF (LECRPD(INUMPD,KRANG)) THEN
C
        CALL LFIVID (KREP,KRANG,INUMPD,IFOURT,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
C         LECTURE SUR FICHIER DE LA PAGE DE DONNEES TAMPON.
C
      NUMAPD(INUMPD,KRANG)=JPNIL
      INAPHY=IARTIC
      CALL LFILDO (KREP,INUMER,IARTIC,MTAMPD(IXT(1,INUMPD,KRANG)),
     S             NBREAD(KRANG),IFACTM,IRETIN)
C
      IF (IRETIN.NE.0) THEN
        GOTO 904
      ENDIF
C
      NUMAPD(INUMPD,KRANG)=IARTIC
      NLONPD(INUMPD,KRANG)=ILARPH
      IDECDE=(IARTIC-IARDEB)*ILARPH-IDCDEB
C
C         TRANSFERT DANS LA ZONE UTILISATEUR.
C
      DO 245 JD=1,ILARPH
      KTAB(IDECDE+JD)=MTAMPD(IXT(JD,INUMPD,KRANG))
  245 CONTINUE
C
  246 CONTINUE
C
      NDERPD(KRANG)=MOD (NDERPD(KRANG)+INPDTA,JPNPDF)
C*
C     2.5 - TRAITEMENT DE LA DERNIERE PAGE DE DONNEES SI ELLE EST
C           INCOMPLETE, ET SI ON EST DANS L'UN DES 2 CAS SUIVANTS
C           SOIT ELLE DIFFERE DE LA PREMIERE, SOIT C'EST LA MEME QUE LA
C           PREMIERE ET ELLE COMMENCE JUSTE EN DEBUT D'ARTICLE.
C           CETTE PAGE EST CONSERVEE... CAR ON ESPERE QUE L'ACCES
C           SUIVANT AU FICHIER SERA POUR L'ARTICLE LOGIQUE IMMEDIATEMENT
C           DERRIERE ( LECTURE SEQUENTIELLE DU FICHIER, PAR EXEMPLE ) .
C-----------------------------------------------------------------------
C
      IF (LLDERN) THEN
C
        DO 252 J=1,JPNPDF
        INUMPJ=MOD (NDERPD(KRANG)+J,JPNPDF)
C
        IF (NUMAPD(INUMPJ,KRANG).EQ.IARFIN) THEN
C
C           ARTICLE PHYSIQUE CHERCHE EN MEMOIRE.
C
          IF (NLONPD(INUMPJ,KRANG).LT.IDCFIN) THEN
C
            IF (IARFIN.GT.MDES1D(IXM(JPAXPD,KRANG))) THEN
              KREP=-16
              GOTO 1001
            ELSEIF (LECRPD(INUMPJ,KRANG)) THEN
              INAPHY=IARFIN
              CALL LFILDO (KREP,INUMER,IARFIN,IFOURT,
     S                     NBREAD(KRANG),IFACTM,IRETIN)
C
              IF (IRETIN.NE.0) THEN
                GOTO 904
              ENDIF
C
              DO 251 JD=NLONPD(INUMPJ,KRANG)+1,ILARPH
              MTAMPD(IXT(JD,INUMPJ,KRANG))=IFOURT(JD)
  251         CONTINUE
C
            ELSE
              NUMAPD(INUMPJ,KRANG)=JPNIL
              INAPHY=IARFIN
              CALL LFILDO (KREP,INUMER,IARFIN,
     S                     MTAMPD(IXT(1,INUMPJ,KRANG)),
     S                     NBREAD(KRANG),IFACTM,IRETIN)
C
              IF (IRETIN.NE.0) THEN
                GOTO 904
              ENDIF
C
              NUMAPD(INUMPJ,KRANG)=IARFIN
            ENDIF
C
            NLONPD(INUMPJ,KRANG)=ILARPH
          ENDIF
C
          INUMPD=INUMPJ
          GOTO 253
        ENDIF
C
  252   CONTINUE
C
C           ARTICLE PHYSIQUE CHERCHE PAS EN MEMOIRE...
C
        INUMPD=MOD (1+NDERPD(KRANG),JPNPDF)
        INAPHY=0
C
        IF (LECRPD(INUMPD,KRANG)) THEN
C
          CALL LFIVID (KREP,KRANG,INUMPD,IFOURT,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        IF (IARFIN.LE.MDES1D(IXM(JPAXPD,KRANG))) THEN
          NUMAPD(INUMPD,KRANG)=JPNIL
          INAPHY=IARFIN
          CALL LFILDO (KREP,INUMER,IARFIN,MTAMPD(IXT(1,INUMPD,KRANG)),
     S                 NBREAD(KRANG),IFACTM,IRETIN)
C
          IF (IRETIN.NE.0) THEN
            GOTO 904
          ENDIF
C
          NLONPD(INUMPD,KRANG)=ILARPH
        ELSE
          NLONPD(INUMPD,KRANG)=0
        ENDIF
C
        NUMAPD(INUMPD,KRANG)=IARFIN
C
  253   CONTINUE
        IDECDE=(IARFIN-IARDEB)*ILARPH-IDCDEB
C
C         COMPLEMENT DE LA PAGE DE DONNEES ASSOCIEE AU DERNIER ARTICLE
C       PHYSIQUE OU DOIVENT ETRE STOCKEES LES DONNEES A ECRIRE.
C
        DO 254 JD=1,IDCFIN
        KTAB(IDECDE+JD)=MTAMPD(IXT(JD,INUMPD,KRANG))
  254   CONTINUE
C
        NDERPD(KRANG)=INUMPD
      ENDIF
C
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
      KREP=IABS (KREP)
      IF (INAPHY.NE.0) NUMAPH(KRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFILED'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I3,
     S  '', KLONG='',I7,'', KRGPIM='',I3,'', KPOSEX='',I8,
     S  '', KRETIN='',I2)') KREP,KRANG,KLONG,KRGPIM,KPOSEX,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIMOD ( KREP, KRANG, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     MODIFICATION DE L'ARTICLE DOCUMENTAIRE, LIMITEE A 3 ELEMENTS,
C     LORSQUE LE FICHIER A SUBI SA PREMIERE MODIFICATION DEPUIS LA
C     DERNIERE OUVERTURE.
C
C     APPELE PAR LFIECR, LFIREN, LFISUP.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
#ifndef f77
      INTEGER (KIND=JPDBLE) IDESCR (JPLARX)
#else
      INTEGER IDESCR (JPLARX)
#endif
      INTEGER KREP, KRANG, KRETIN, INUMER, IFACTM, IREC
      INTEGER IRANG, INAPHY, IRETOU, INIMES, IRETIN
C
#include "lficom2.h"
C**
C     1. -  CONTROLES DES PARAMETRES D'APPEL ET INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IRETOU=0
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI) THEN
        KREP=-16
        GOTO 1001
      ENDIF
C
      IRANG=KRANG
      KREP=0
      INUMER=NUMERO(IRANG)
      IFACTM=MFACTM(IRANG)
      IREC=1
C**
C     2. -  LECTURE/MODIFICATION/REECRITURE DE L'ARTICLE DOCUMENTAIRE.
C-----------------------------------------------------------------------
C
      INAPHY=IREC
      CALL LFILDO (KREP,INUMER,IREC,IDESCR(1),
     S             NBREAD(IRANG),IFACTM,IRETIN)
C
      IF (IRETIN.NE.0) THEN
        GOTO 904
      ENDIF
C
      IDESCR(JPFEAM)=1
      CALL LFIDAH (IDESCR(JPDMNG),IDESCR(JPHMNG))
      MDES1D(IXM(JPDMNG,IRANG))=IDESCR(JPDMNG)
      MDES1D(IXM(JPHMNG,IRANG))=IDESCR(JPHMNG)
      CALL LFIEDO (KREP,INUMER,IREC,IDESCR(1),
     S             NBWRIT(IRANG),IFACTM,IRETIN)
C
      IF (IRETIN.NE.0) THEN
        GOTO 903
      ENDIF
C
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
      KREP=IABS (KREP)
      NUMAPH(IRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INUMER=NUMERO(KRANG)
        INIMES=2
        CLNSPR='LFIMOD'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I3,
     S  '', KRETIN='',I2)')
     S    KREP,KRANG,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFINAF ( KREP, KNUMER, KNALDO, KNTROU, KNARES, KNAMAX )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME DONNANT DES NOMBRES D'ARTICLES LOGIQUES DIVERS
C     ( DE DONNEES, "TROUS", POSSIBLE, MAXIMUM ) POUR UNE UNITE LOGIQUE
C     OUVERTE POUR LE LOGICIEL DE FICHIERS INDEXES *LFI* .
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE;
C                KNALDO (SORTIE) ==> NOMBRE D'ARTICLES LOGIQUES
C                                  *DE DONNEES* (TROUS EXCLUS) PRESENTS;
C                KNTROU (SORTIE) ==> NOMBRE D'ARTICLES LOGIQUES QUI SONT
C                                    DEVENUS DES "TROUS", PAR SUITE DE
C                                    REECRITURES D'ARTICLES PLUS LONGUES
C                                    QU'INITIALEMENT, ET QUI N'ONT PAS
C                                    PU ETRE (ENCORE) RECYCLES;
C                KNARES (SORTIE) ==> NOMBRE D'ARTICLES LOGIQUES POUVANT
C                                    ETRE ECRITS DANS LA PARTIE "PRERER-
C                                    VEE" DE L'INDEX (TROUS COMPRIS);
C                KNAMAX (SORTIE) ==> NOMBRE D'ARTICLES LOGIQUES MAXIMUM
C                                    POUVANT ETRE ECRITS SUR L'UNITE
C                                    LOGIQUE, EN "DEBORDANT" AU MAXIMUM
C                                   DE LA PARTIE PRERESERVEE DE L'INDEX.
C                                    ( TROUS COMPRIS )
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP, KNUMER, KNALDO, KNTROU, KNARES, KNAMAX
      INTEGER IRANG, IREP, IFACTM, ILARPH, INALPP, INIMES
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DU PARAMETRE D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      CALL LFINUM (KNUMER,IRANG)
C
      IF (IRANG.EQ.0) THEN
        KNTROU=0
        KNALDO=0
        KNARES=0
        KNAMAX=0
        IREP=-1
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
C**
C     2.  -  CALCUL DIRECT DES ARGUMENTS DE SORTIE DU SOUS-PROGRAMME.
C-----------------------------------------------------------------------
C
      IFACTM=MFACTM(IRANG)
      ILARPH=JPLARD*IFACTM
      INALPP=JPNAPP*IFACTM
      KNTROU=MDES1D(IXM(JPNTRU,IRANG))+NBTROU(IRANG)
      KNALDO=MDES1D(IXM(JPNALO,IRANG))-KNTROU
      KNARES=INALPP*MDES1D(IXM(JPNPIR,IRANG))
      KNAMAX=KNARES+INALPP*(ILARPH-JPLDOC)
      IREP=0
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (IRANG.NE.0) THEN
        NDEROP(IRANG)=12
        NDERCO(IRANG)=IREP
         IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'OFF')
      ENDIF
C
      IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
        INIMES=2
      ELSE
        RETURN
      ENDIF
C
      CLNSPR='LFINAF'
      WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S       '', KNALDO='',I6,'', KNTROU='',I6,'', KNARES='',I6,
     S       '', KNAMAX='',I6)') KREP,KNUMER,KNALDO,KNTROU,KNARES,KNAMAX
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      RETURN
      END
      SUBROUTINE LFINFO ( KREP, KNUMER, CDNOMA, KLONG, KPOSEX )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME CHARGE DE RENSEIGNER SUR EXISTENCE ET CARACTERI-
C     STIQUES ( LONGUEUR, POSITION ) D'UN ARTICLE LOGIQUE, POUR UNE
C     UNITE LOGIQUE OUVERTE PAR LE LOGICIEL DE FICHIERS INDEXES *LFI*.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE;
C                CDNOMA (ENTREE) ==> NOM DE L'ARTICLE A CHERCHER;
C                KLONG  (SORTIE) ==> LONGUEUR DE L'ARTICLE;
C                KPOSEX (SORTIE) ==> POSITION ( DANS LE FICHIER, DU PRE-
C                                    MIER MOT ) DE L'ARTICLE SUIVANT.
C
C       Noter que si l'unite logique est ouverte pour le logiciel LFI et
C     que l'article demande n'y est pas trouve, KREP, KLONG et KPOSEX
C     sont retournes a ZERO.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CDNOMA*(*), CLNOMA*(JPNCPN)
C
      INTEGER KREP, KNUMER, KLONG, KPOSEX, IREP, IRANG, ILCLNO, ILCDNO
      INTEGER IDECBL, IPOSBL, IARTEX, IRGPIM, INIMES, INBALO, IRETIN
C
      LOGICAL LLVERF
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
C        Appel legerement anticipe a LFINUM, garantissant l'initialisa-
C     tion des variables globales du logiciel a la 1ere utilisation.
C
      CALL LFINUM (KNUMER,IRANG)
      LLVERF=.FALSE.
      ILCDNO=LEN (CDNOMA)
      KLONG=0
      KPOSEX=0
C
      IF (ILCDNO.LE.0) THEN
        IREP=-15
        CLNOMA=CHINCO(:JPNCPN)
        ILCLNO=JPNCPN
        GOTO 1001
      ELSEIF (CDNOMA.EQ.' ') THEN
        IREP=-18
        CLNOMA=' '
        ILCLNO=1
        GOTO 1001
      ENDIF
C
C        Recherche de la longueur "utile" du nom d'article specifie.
C        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
C
      IDECBL=0
C
  101 CONTINUE
      IPOSBL=IDECBL+INDEX (CDNOMA(IDECBL+1:),' ')
C
      IF (IPOSBL.LE.IDECBL) THEN
        ILCLNO=ILCDNO
      ELSEIF (CDNOMA(IPOSBL:).EQ.' ') THEN
        ILCLNO=IPOSBL-1
      ELSE
        IDECBL=IPOSBL
        GOTO 101
      ENDIF
C
      IF (ILCLNO.LE.JPNCPN) THEN
        CLNOMA=CDNOMA(:ILCLNO)
      ELSE
        CLNOMA=CDNOMA(:JPNCPN)
        ILCLNO=JPNCPN
        IREP=-15
        GOTO 1001
      ENDIF
C
      IF (IRANG.EQ.0) THEN
        IREP=-1
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
      LLVERF=LMULTI
C
      INBALO=MDES1D(IXM(JPNALO,IRANG))
C
      IF (INBALO.NE.0) THEN
C**
C     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
C            A LA RECHERCHE DE L'ARTICLE LOGIQUE DEMANDE.
C-----------------------------------------------------------------------
C
        CALL LFIRAN (IREP,IRANG,CLNOMA(:ILCLNO),IRGPIM,IARTEX,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ELSE
        IARTEX=0
        IREP=0
      ENDIF
C
      IF (IARTEX.EQ.0) THEN
        KLONG=0
        KPOSEX=0
      ELSE
C
C        ON COMPLETE LES CARACTERISTIQUES DE L'ARTICLE.
C
        IF (.NOT.LPHASP(IRGPIM)) THEN
C
          CALL LFIPHA (IREP,IRANG,IRGPIM,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        KLONG=MLGPOS(IXM(2*IARTEX-1,IRGPIM))
        KPOSEX=MLGPOS(IXM(2*IARTEX,IRGPIM))
C
C        On met a jour ce qui a trait aux acces pseudo-sequentiels...
C     ceci surtout pour ne pas faire 2 recherches dans l'index lors
C     d'un appel a LFILEC qui suivrait l'appel a LFINFO.
C
        NDERGF(IRANG)=JPNAPP*MFACTM(IRANG)*(MRGPIF(IRGPIM)-1)+IARTEX
        CNDERA(IRANG)=CLNOMA(:ILCLNO)
        NSUIVF(IRANG)=JPNIL
        NPRECF(IRANG)=JPNIL
      ENDIF
C
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      CLACTI='READ'
C
  909 CONTINUE
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      IREP=IABS (IREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (IRANG.NE.0) THEN
        NDEROP(IRANG)=7
        NDERCO(IRANG)=IREP
         IF (LLVERF) CALL LFIVER (VERRUE(IRANG),'OFF')
      ENDIF
C
      IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
        INIMES=2
      ELSE
        RETURN
      ENDIF
C
      CLNSPR='LFINFO'
      WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S       '', CDNOMA='''''',A,'''''', KLONG='',I7,'', KPOSEX='',I8)')
     S     KREP,KNUMER,CLNOMA(:ILCLNO),KLONG,KPOSEX
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      RETURN
      END
      SUBROUTINE LFINUM ( KNUMER, KRANG )
#include "lficomt.h"
C****
C        CE SOUS-PROGRAMME CALCULE LE RANG DU NUMERO D'UNITE LOGIQUE
C     *KNUMER* DANS LA TABLE DES UNITES LOGIQUES *NUMERO*;
C     S'IL N'Y EST PAS TROUVE, LE RESULTAT EST ZERO.
C        CE SOUS-PROGRAMME, APPELE PAR *TOUS* LES SOUS-PROGRAMMES NON
C     GLOBAUX DU LOGICIEL DE FICHIERS INDEXES LFI, SE CHARGE LORS DE SON
C     PREMIER APPEL D'APPELER LE SOUS-PROGRAMME PREPARATOIRE LFIINI.
C**
C       ARGUMENTS : KNUMER (ENTREE) ==> NUMERO D'UNITE LOGIQUE CHERCHE;
C                   KRANG  (SORTIE) ==> RANG DANS LA TABLE DES FICHIERS
C                                       DU LOGICIEL LFI (0 SI ABSENT).
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KNUMER, KRANG, J, IRESUL, IREP, INIMES
C
      LOGICAL LLPREA
      SAVE LLPREA
C
      DATA LLPREA/ .TRUE. /
C
      IF (LLPREA) THEN
        CALL LFIINI (2)
        LLPREA=.FALSE.
      ENDIF
C
C          VERROUILLAGE GLOBAL (A CAUSE DE L'UTILISATION DE NBFIOU )
C
       IF (LMULTI) CALL LFIVER (VERGLA,'ON')
C
      DO 10 J=1,NBFIOU
C
      IF (KNUMER.EQ.NUMERO(NUMIND(J))) THEN
        IRESUL=NUMIND(J)
        GOTO 20
      ENDIF
C
   10 CONTINUE
C
      IRESUL=0
C
   20 CONTINUE
C
C          DEVERROUILLAGE GLOBAL
C
       IF (LMULTI) CALL LFIVER (VERGLA,'OFF')
      KRANG=IRESUL
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
      IF (LMISOP) THEN
        IREP=0
        INIMES=2
        CLNSPR='LFINUM'
        WRITE (UNIT=CLMESS,FMT='(''KNUMER='',I3,'', KRANG='',I3)')
     S    KNUMER,KRANG
        CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIOUV ( KREP, KNUMER, LDNOMM, CDNOMF, CDSTTO, LDERFA,
     S                    LDIMST, KNIMES, KNBARP, KNBARI )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME D'OUVERTURE D'UNE UNITE LOGIQUE DEVANT ETRE
C     TRAITEE COMME UN FICHIER INDEXE, PAR LE LOGICIEL LFI.
C**
C     ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                 KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE;
C                 LDNOMM (ENTREE) ==> VRAI SI L'UNITE LOGIQUE DOIT ETRE
C                                     ASSOCIEE A UN NOM DE FICHIER EXP-
C                                     LICITE LORS DE L'"OPEN" FORTRAN;
C                 CDNOMF (ENTREE) ==> NOM DE FICHIER EXPLICITE, SI
C                                     *LDNOMM* EST VRAI - MEME SI CE
C                                     N'EST PAS LE CAS, CE *DOIT* ETRE
C                                     UN OBJET DE TYPE "CHARACTER" .
C                 CDSTTO (ENTREE) ==> "STATUS" POUR L'"OPEN" FORTRAN
C                                     ('OLD','NEW','UNKNOWN','SCRATCH')
C                                     PAR DEFAUT, METTRE 'UNKNOWN';
C                 LDERFA (ENTREE) ==> OPTION D'ERREUR FATALE;
C                 LDIMST (ENTREE) ==> OPTION IMPRESSION DE STATISTIQUES
C                                     AU MOMENT DE LA FERMETURE;
C                 KNIMES (ENTREE) ==> NIVEAU DE LA MESSAGERIE (0,1 OU 2)
C                                     ( 0==>RIEN, 2==>TOUT )
C                 KNBARP (ENTREE) ==> NOMBRE D'ARTICLES LOGIQUES PREVUS,
C                                     CE QUI N'EST UTILISE QUE LORS DE
C                                     LA CREATION DU FICHIER,
C                                     ET QUI N'EMPECHE QUAND MEME PAS
C                                     D'AVOIR PLUS D'ARTICLES LOGIQUES;
C                 KNBARI (SORTIE) ==> NOMBRE D'ARTICLES LOGIQUES DE DON-
C                                     NEES SUR LE FICHIER, INITIALEMENT.
C                                     (ZERO SI CREATION)
      INTEGER JPNBST
C
      PARAMETER ( JPNBST=5 )
C
      CHARACTER CPNOMD*(*)
      PARAMETER ( CPNOMD='%%%%% FICHIER SANS NOM %%%%%' )
C
C    Modifications:
C
C    02/06/97, Jean Clochard.
C
C              -Modification des impressions pour que l'annee puisse
C               etre imprimee avec 4 chiffres.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP, KNUMER, KNIMES, KNBARP, KNBARI
#ifndef f77
      INTEGER (KIND=JPDBLE) IDATE, IHEURE
#else
      INTEGER IDATE, IHEURE
#endif
      INTEGER ILSTTU, IREPX, IRANG, IRANMS, INBARI, IDECBL, IPOSBL, J
      INTEGER ILNOMF, INLNOM, INIMES, IREP, ILNOMS, IFACTM, ILSTTO, IJ
      INTEGER IRANFM, ILACTI, ICOMPT, ITAILS, ICRITS, IPOFIN, ICRITG
      INTEGER ICRITD, ICRITR, IPOSCA, INREAD, INWRIT, IBASE, ILOREC
      INTEGER INAPHY, JREC, ILARPH, INALPP, IFACPH, IFACPP, INBPIR
      INTEGER IRANGD, IREC, INBALO, ILUTIL, IRGPIF, IRETIN
C
      LOGICAL LDNOMM, LDERFA, LDIMST, LLEXFI, LLNOUF, LLNOMS
      LOGICAL LLVERG, LLEXUL
C
      CHARACTER CDNOMF*(*), CDSTTO*(*)
      CHARACTER*(JPLSTX) CLSTEX (JPNBST), CLSTTO
      CHARACTER*(JPLFTX) CLNOMF, CLNOMS
C
      SAVE CLSTEX
C
#include "lficom2.h"
C
C      DATA CLSTEX /'OLD', 'NEW', 'UNKNOWN', 'SCRATCH'/
      CLSTEX(1) = 'OLD'
      CLSTEX(2) = 'NEW' 
      CLSTEX(3) = 'UNKNOWN'
      CLSTEX(4) = 'SCRATCH'
      CLSTEX(5) = 'REPLACE'
C**
C     1.  -  CONTROLES DIVERS, ET INITIALISATIONS.
C-----------------------------------------------------------------------
C*
C     1.0 - PARTIE "ELEMENTAIRE".
C-----------------------------------------------------------------------
C
      ILSTTU=MIN0 (LEN (CLSTTO), LEN (CDSTTO))
      IREPX=0
      IRANG=0
      IRANMS=0
      INBARI=0
      LLVERG=.FALSE.
CJUAN
      CLACTI='UNKNOWN'      

C
C        Appel legerement anticipe a LFINUM, permettant une initialisa-
C     tion des variables globales du logiciel a la 1ere utilisation.
C
      CALL LFINUM (KNUMER,IRANG)
C
      IF (LDNOMM) THEN
C
C        Recherche de la longueur "utile" du nom de fichier specifie.
C        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
C
        IDECBL=0
C
  101   CONTINUE
        IPOSBL=IDECBL+INDEX (CDNOMF(IDECBL+1:),' ')
C
        IF (IPOSBL.LE.IDECBL) THEN
          ILNOMF=LEN (CDNOMF)
        ELSEIF (CDNOMF(IPOSBL:).EQ.' ') THEN
          ILNOMF=MAX0 (IPOSBL-1,1)
        ELSE
          IDECBL=IPOSBL
          GOTO 101
        ENDIF
C
        IF (ILNOMF.GT.JPLFTX) THEN
          INLNOM=JPLFTX
          INIMES=NIMESG
C
          IF (INIMES.GE.1) THEN
C
C        Message preventif, car le controle de non ouverture d'un meme
C     fichier via deux unites logiques differentes risque de "sauter"
C     artificiellement... et pas forcement a cet appel.
C
C        Le code-reponse ci-dessous est bidon, mais permet de mettre
C     en relief le message via LFIEMS.
C
            IREP=JPNIL
            CLNSPR='LFIOUV'
C
            IF (LFRANC) THEN
              WRITE (UNIT=CLMESS,FMT=
     S               '(''ATTENTION: NOM DE FICHIER TRONQUE A'',I4,
     S                 '' CARACTERES...'')') JPLFTX
            ELSE
              WRITE (UNIT=CLMESS,FMT=
     S               '(''WARNING: FILE NAME TRUNCATED TO ONLY'',I4,
     S                 '' CHARACTERS...'')') JPLFTX
            ENDIF
C
            CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,
     S                   CLACTI)
          ENDIF
C
        ELSE
          INLNOM=ILNOMF
        ENDIF
C
        CLNOMF=CDNOMF(:INLNOM)
      ELSE
        ILNOMF=LEN (CPNOMD)
        CLNOMF=CPNOMD
        INLNOM=ILNOMF
      ENDIF
C
C       Ci-dessous, initialisations destinees a forcer l'impression
C     du nom du fichier en cas de problemes.
C
      CLNOMS=CLNOMF
      ILNOMS=INLNOM
      IFACTM=0
C
C        Controle de validite FORTRAN du Numero d'Unite Logique.
C
      INQUIRE (UNIT=KNUMER,EXIST=LLEXUL,ERR=901,IOSTAT=IREP)
C
      IF (.NOT.LLEXUL) THEN
        IREP=-30
        GOTO 1001
      ENDIF
C
C        CONTROLE DE L'ARGUMENT D'APPEL "KNIMES"
C
      IF (KNIMES.LT.0.OR.KNIMES.GT.2) THEN
        IREP=-2
        GOTO 1001
      ENDIF
C
C        CONTROLE DE L'ARGUMENT D'APPEL "CDSTTO"
C
      DO 103 J=1,JPNBST
      IF (CDSTTO.EQ.CLSTEX(J)) GOTO 104
  103 CONTINUE
C
      ILACTI=MIN0 (LEN (CDSTTO),LEN (CLACTI))
      CLACTI=CDSTTO(:ILACTI)
      IREP=-7
      GOTO 1001
C
  104 CONTINUE
      ILSTTO=INDEX (CDSTTO,' ')-1
      IF (ILSTTO.GT.0) ILSTTU=ILSTTO
      CLSTTO=CDSTTO(:ILSTTU)
C
C               CONTROLE DE NON-OUVERTURE PREALABLE.
C
      IF (IRANG.NE.0) THEN
        IREP=-5
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERGLA,'ON')
      LLVERG=LMULTI
C
C        Recherche d'un eventuel facteur multiplicatif predefini pour
C     l'unite logique en question.
C
      CALL LFIFMP (KNUMER,IRANFM)
      IFACTM=MFACTU(IRANFM)
C
      IF (LDNOMM) THEN
C
C        SI LE FICHIER EST NOMME, ON VERIFIE QU'IL N'A PAS ETE
C        DEJA OUVERT POUR UNE AUTRE UNITE LOGIQUE.
C
        DO 105 J=1,NBFIOU
        IJ=NUMIND(J)
C
        IF (CLNOMF.EQ.CNOMFI(IJ)(:MIN0 (JPLFTX,NLNOMF(IJ)))) THEN
          ILACTI=MIN0(LEN (CLNOMF),LEN (CLACTI))
          CLACTI=CLNOMF(:ILACTI)
          IRANMS=IJ
          IREP=-13
          GOTO 1001
        ENDIF
C
  105   CONTINUE
C
      ENDIF
C
  110 CONTINUE
C*
C     1.1 - RECHERCHE D'UN EMPLACEMENT DISPONIBLE DANS LA TABLE DES
C           NUMEROS D'UNITES LOGIQUES *NUMERO* .
C           (Il faut IFACTM emplacements CONSECUTIFS)
C-----------------------------------------------------------------------
C
      IF ((NFACTM+IFACTM).GT.JPNXFI) THEN
        IREP=-6
        GOTO 1001
      ENDIF
C
      ICOMPT=0
      ITAILS=JPNXFI+1
      ICRITS=0
C
      DO 111 J=1,JPNXFI
C
      IF (NUMERO(J).EQ.JPNIL) THEN
        ICOMPT=ICOMPT+1
        IF (J.NE.JPNXFI.OR.ICOMPT.LT.IFACTM.OR.ICOMPT.GT.ITAILS)GOTO 111
        IPOFIN=JPNXFI
      ELSEIF (ICOMPT.LT.IFACTM.OR.ICOMPT.GT.ITAILS) THEN
        ICOMPT=0
C
        IF ((JPNXFI-J).LT.IFACTM) THEN
          GOTO 112
        ELSE
          GOTO 111
        ENDIF
C
      ELSE
        IPOFIN=J-1
      ENDIF
C
C       Les lignes qui suivent sont atteintes si on a trouve un espace
C     contigu suffisant dans la table NUMERO, et de taille inferieure
C     ou egale a ce qu'on aurait pu trouver precedemment.
C       On calcule alors un critere de cadrage (a gauche ou a droite)
C     dans cet espace, en privilegiant une occupation decentree.
C
      ICRITG=IABS (JPNXFI+1-2*(IPOFIN-ICOMPT+1))
      ICRITD=IABS (JPNXFI+1-2*IPOFIN)
C
      IF (ICRITG.GE.ICRITD) THEN
        ICRITR=ICRITG
        IPOSCA=IPOFIN-ICOMPT+1
      ELSE
        ICRITR=ICRITD
        IPOSCA=IPOFIN-IFACTM+1
      ENDIF
C
C       On retient l'espace trouve s'il est plus petit que ce qu'on
C     avait pu trouver precedemment, ou en cas d'egalite de taille
C     s'il est plus decentre.
C
      IF (ICOMPT.LT.ITAILS.OR.ICRITR.GT.ICRITS) THEN
        ITAILS=ICOMPT
        IRANG=IPOSCA
        ICRITS=ICRITR
      ENDIF
C
      ICOMPT=0
      IF ((JPNXFI-J).LT.IFACTM) GOTO 112
C
  111 CONTINUE
C
  112 CONTINUE
C
      IF (ITAILS.GT.JPNXFI) THEN
C
C         On n'a pas trouve d'espace ad hoc.
C
        IF (IFACTM.GT.1) THEN
          IREP=-27
        ELSE
          IREP=-16
        ENDIF
C
        GOTO 1001
C
      ENDIF
C
      IRANMS=IRANG
      IF (LMISOP) PRINT *,'====> LFIOUV - IRANG = ',IRANG,
     S            ', IFACTM = ',IFACTM
      LERFAT(IRANG)=LDERFA
      NIVMES(IRANG)=KNIMES
      INREAD=0
      INWRIT=0
C
C        CETTE INITIALISATION QUI PEUT PARAITRE BIEN COMPLIQUEE SERT
C     DE PARADE AU MAUVAIS COMPORTEMENT DU "READ" SUR UN FICHIER VIDE,
C     sur CRAY-2 sous UNICOS 4.0 et 5.0... ( Debut )
C
      CALL LFIDAH (IDATE,IHEURE)
      IBASE=IHEURE+JPNIL
C
      DO 113 J=1,JPLDOC
      MDES1D(IXM(J,IRANG))=IBASE-J
  113 CONTINUE
C**
C     2.  -  OUVERTURE DU FICHIER AU SENS FORTRAN DU TERME (*OPEN*).
C-----------------------------------------------------------------------
C
      ILOREC=JPRECL*IFACTM
C
      IF (LDNOMM) THEN
C*
C     2.1 - CAS OU L'UNITE LOGIQUE DOIT ETRE ASSOCIEE A UN FICHIER
C           DONT LE NOM EST EXPLICITEMENT DONNE.
C-----------------------------------------------------------------------
C
        INQUIRE (FILE=CDNOMF,EXIST=LLEXFI,IOSTAT=IREP,ERR=901)
C
        IF (LLEXFI.AND.CLSTTO.EQ.'NEW'
     S      .OR..NOT.LLEXFI.AND.CLSTTO.EQ.'OLD') THEN
          CLACTI=CLSTTO
          IREP=-9
          IRANG=0
          IRANMS=0
          GOTO 1001
        ENDIF
C
        LLNOUF=CLSTTO.EQ.'NEW'.OR.CLSTTO.EQ.'SCRATCH'.OR..NOT.LLEXFI
C
C     APRES TOUS CES CONTROLES DE BASE, ON TENTE L'"OPEN" DU FICHIER .
C
        OPEN (UNIT=KNUMER,FILE=CDNOMF,STATUS=CLSTTO,ERR=902,
     S       FORM='UNFORMATTED',ACCESS='DIRECT',RECL=ILOREC,IOSTAT=IREP)
C
      ELSE
C*
C     2.2 - CAS OU L'UNITE LOGIQUE N'A PAS DE NOM DE FICHIER ASSOCIE
C           EXPLICITE; ON TENTE DIRECTEMENT L'"OPEN" .
C-----------------------------------------------------------------------
C
        IF (CLSTTO.NE.'OLD'.AND.CLSTTO.NE.'NEW') THEN
          OPEN (UNIT=KNUMER,STATUS=CLSTTO,FORM='UNFORMATTED',
     S          ACCESS='DIRECT',RECL=ILOREC,ERR=902,IOSTAT=IREP)
        ELSE
          OPEN (UNIT=KNUMER,FORM='UNFORMATTED',
     S          ACCESS='DIRECT',RECL=ILOREC,ERR=902,IOSTAT=IREP)
        ENDIF
C
        LLNOUF=CLSTTO.EQ.'SCRATCH'
C
      ENDIF
C*
C     2.3 - L'"OPEN" S'EST BIEN PASSE... ON ESSAIE DE RECUPERER LE NOM
C           *SYSTEME* EVENTUEL ASSOCIE A L'UNITE LOGIQUE.
C-----------------------------------------------------------------------
C
      INQUIRE (UNIT=KNUMER,NAMED=LLNOMS,NAME=CLNOMS,ERR=901,
     S         IOSTAT=IREP)
C
      IF (LLNOMS) THEN
C
C        Recherche de la longueur "utile" du nom systeme du fichier.
C        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
C
        IDECBL=0
C
  231   CONTINUE
        IPOSBL=IDECBL+INDEX (CLNOMS(IDECBL+1:),' ')
C
        IF (IPOSBL.LE.IDECBL) THEN
          ILNOMS=LEN (CLNOMS)
        ELSEIF (CLNOMS(IPOSBL:).EQ.' ') THEN
          ILNOMS=MAX0 (IPOSBL-1,1)
        ELSE
          IDECBL=IPOSBL
          GOTO 231
        ENDIF
C
        IF (.NOT.LDNOMM) THEN
          ILNOMF=ILNOMS
          INLNOM=ILNOMS
          CLNOMF=CLNOMS
        ENDIF
C
        DO 233 J=1,NBFIOU
        IJ=NUMIND(J)
C
        IF (CLNOMS.EQ.CNOMSY(IJ)(:NLNOMS(IJ))) THEN
          ILACTI=MIN0(LEN (CLNOMS),LEN (CLACTI))
          CLACTI=CLNOMS(:ILACTI)
          IREP=-13
          IRANG=0
          IRANMS=0
          GOTO 1001
        ENDIF
C
  233   CONTINUE
C
      ELSE
        ILNOMS=LEN (CPNOMD)
        CLNOMS=CPNOMD
      ENDIF
C
      IF (CLSTTO.EQ.'OLD'.OR..NOT.LLNOUF) THEN
C**
C     3.  -  DANS LE CAS OU LE FICHIER DEVAIT OU POUVAIT EXISTER AVANT
C            OUVERTURE, ON ESSAIE DE LIRE LES PREMIERS ARTICLES.
C-----------------------------------------------------------------------
C        ( L'ARTICLE DOCUMENTAIRE ET UNE PAIRE D'ARTICLES D'INDEX;
C          ON COMMENCE PAR L'ARTICLE NO. 3 CAR IL Y A PLUS DE CHANCES
C          D'AVOIR UNE MAUVAISE LECTURE POUR CELUI-CI )
C
C          DANS LE CAS DU "STATUS" 'UNKNOWN', IL S'AGIT DE LEVER
C       L'AMBIGUITE: FICHIER DEJA ECRIT PAR LE LOGICIEL, OU DEVANT ETRE
C       CREE PAR LUI ?
C
        DO 301 JREC=3,1,-2
        INAPHY=JREC
        CALL LFILDO (IREP,KNUMER,JREC,MDES1D(IXM(1,IRANG)),INREAD,
     S               IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 302
        ENDIF
C
  301   CONTINUE
C
  302   CONTINUE
C
        IF (IREP.EQ.0) THEN
C
C           LECTURE OK... ON CONTROLE QUELQUES VALEURS "DOCUMENTAIRES"
C
C            Fin de la parade sur CRAY2, sous UNICOS 4.0 et 5.0 .
C
          DO 303 J=1,JPLDOC
          IF (MDES1D(IXM(J,IRANG)).NE.(IBASE-J)) GOTO 304
  303     CONTINUE
C
          LLNOUF=.TRUE.
          GOTO 390
C
  304     CONTINUE
          LLNOUF=.FALSE.
          ILARPH=MDES1D(IXM(JPLPAR,IRANG))
          INALPP=MDES1D(IXM(JPXAPI,IRANG))
          IFACPH=ILARPH/JPLARD
          IFACPP=INALPP/JPNAPP
C
          IF (MIN0 (ILARPH,INALPP).LE.0.OR.MOD (ILARPH,JPLARD).NE.0
     S        .OR.MDES1D(IXM(JPLMNA,IRANG)).NE.JPNCPN
     S        .OR.MDES1D(IXM(JPLLDO,IRANG)).NE.JPLDOC
     S        .OR.MOD (INALPP,JPNAPP).NE.0.OR.IFACPP.NE.IFACPH) THEN
            IREP=-10
            IRANG=0
            IRANMS=0
            GOTO 1001
          ELSEIF (MDES1D(IXM(JPFEAM,IRANG)).NE.0) THEN
            IREP=-11
            LLFATA=LLMOER (IREP,IRANG)
C
            IF (LLFATA) THEN
              IRANG=0
              IRANMS=0
              GOTO 1001
            ENDIF
C
C        SI L'ERREUR (-11) N'A PAS ETE FATALE, ON DONNE LA POSSIBILITE
C       DE TRAITER LE FICHIER DONT LA DERNIERE MODIFICATION N'A PAS ETE
C       "ENREGISTREE" . MAIS SANS AUCUNE GARANTIE ...
C
          ENDIF
C
          IF (IFACPH.NE.IFACTM) THEN
C
C     Messagerie de Niveau 1 pour prevenir de l'incident...
C
            INIMES=IXNIMS (IRANMS)
C
            IF (INIMES.GE.1) THEN
              CLNSPR='LFIOUV'
C
              IF (LFRANC) THEN
                WRITE (UNIT=CLMESS,FMT='(''Unite logique'',I3,
     S '', facteur multiplicatif lu sur fichier='',I3,'', attendu='',
     S                 I3)')KNUMER,IFACPH,IFACTM
              ELSE
                WRITE (UNIT=CLMESS,FMT='(''Logical Unit'',I3,
     S '', multiply factor read on file='',I3,'', expected='',I3)')
     S          KNUMER,IFACPH,IFACTM
              ENDIF
C
              IREPX=IREP
              IREP=0
              CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,
     S                     CLACTI)
C
              IF (LFRANC) THEN
                ILUTIL=MIN0 (INLNOM,JPLFIX,LEN (CLMESS)-6)
                CLMESS='Nom='''//CLNOMF(:ILUTIL)//''''
              ELSE
                ILUTIL=MIN0 (INLNOM,JPLFIX,LEN (CLMESS)-7)
                CLMESS='Name='''//CLNOMF(:ILUTIL)//''''
              ENDIF
C
              CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,
     S                     CLACTI)
C
              IF (LDNOMM.AND.CLNOMS.NE.CLNOMF) THEN
C
                IF (LFRANC) THEN
                  ILUTIL=MIN0 (ILNOMS,JPLFIX,LEN (CLMESS)-14)
                  CLMESS='Nom SYSTEME='''//CLNOMS(:ILUTIL)//''''
                ELSE
                  ILUTIL=MIN0 (ILNOMS,JPLFIX,LEN (CLMESS)-14)
                  CLMESS='SYSTEM Name='''//CLNOMS(:ILUTIL)//''''
                ENDIF
C
                CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,
     S                       CLACTI)
              ENDIF
C
              IF (LFRANC) THEN
                CLMESS='On essaie de s''adapter au facteur '
     S               //'multiplicatif lu sur le fichier...'
              ELSE
                CLMESS='One tries to adapt to multiply '
     S               //'factor read on the file...'
              ENDIF
C
              CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,
     S                     CLACTI)
              IREP=IREPX
            ENDIF
C
C        On va essayer de traiter le fichier avec la longueur d'Article
C     Physique lue sur le fichier. Pour cela, on doit d'abord le fermer,
C     puis on va recommencer le traitement depuis le paragraphe 1.1 .
C
            IRANG=0
            IRANMS=0
            CLOSE (UNIT=KNUMER,STATUS='KEEP',ERR=905,IOSTAT=IREP)
C
            IF (IFACPH.GT.JPFACX) THEN
              IREP=-28
              GOTO 1001
            ENDIF
C
            IFACTM=IFACPH
            GOTO 110
          ENDIF
C
        ELSEIF (CLSTTO.EQ.'OLD') THEN
          IREP=-12
          IRANG=0
          IRANMS=0
          GOTO 1001
        ELSE
          IREP=0
          LLNOUF=.TRUE.
        ENDIF
C
      ENDIF
C
  390 CONTINUE
C
C         Controle ultime avant le paragraphe suivant, dans la mesure
C     ou, contrairement au FORTRAN, on autorise les "STATUS" 'OLD'
C     et 'NEW' pour une unite logique sans nom de fichier explicite...
C     puisque le logiciel a sa propre mecanique de discrimination entre
C     un fichier "existant" ou "en mode creation".
C
      IF (LLNOUF.AND.CLSTTO.EQ.'OLD'
     S    .OR..NOT.LLNOUF.AND.CLSTTO.EQ.'NEW') THEN
        CLACTI=CLSTTO
        IREP=-9
        IRANG=0
        IRANMS=0
        GOTO 1001
      ENDIF
C**
C     4.  -  L'OUVERTURE FORTRAN EST OK, ON SAIT SI ON EST EN MODE
C            CREATION DU FICHIER INDEXE OU NON... ON COMMENCE A GARNIR
C            LES VARIABLES EN COMMON, MAIS SANS INCREMENTER *NBFIOU*
C            CAR ON PEUT ENCORE AVOIR DE (MAUVAISES) SURPRISES.
C-----------------------------------------------------------------------
C
      IREPX=IREP
      CNOMFI(IRANG)=CLNOMF
      NLNOMF(IRANG)=ILNOMF
      CNOMSY(IRANG)=CLNOMS
      NLNOMS(IRANG)=ILNOMS
      NDEROP(IRANG)=0
      CSTAOP(IRANG)=CLSTTO
      LNOUFI(IRANG)=LLNOUF
      LMODIF(IRANG)=.FALSE.
      NDERCO(IRANG)=IREP
      NTRULZ(IRANG)=0
      NRFPTZ(IRANG)=0
      NRFDTZ(IRANG)=0
      NBMOLU(IRANG)=0
      NBMOEC(IRANG)=0
      NDERGF(IRANG)=JPNIL
      CNDERA(IRANG)=' '
      MFACTM(IRANG)=IFACTM
      NSUIVF(IRANG)=JPNIL
      NPRECF(IRANG)=JPNIL
C
C     N.B.: LES PAGES D'INDEX DE RANG "IRANG" SONT AUTOMATIQUEMENT
C        "AFFECTEES" A L'UNITE LOGIQUE AYANT CE RANG, ET SERVENT
C        A Y STOCKER LA PREMIERE P.A.I. EN RANG DANS LE FICHIER.
C
C     ( LES PAGES D'INDEX DE RANG "IRANG+(J-1)*JPNXFI" OU J VARIE
C       DE 1 A JPNPIA, SONT AUTOMATIQUEMENT AFFECTEES A L'UNITE
C       LOGIQUE DE RANG "IRANG" )
C
      NBLECT(IRANG)=0
      NBNECR(IRANG)=0
      NREESP(IRANG)=0
      NREECO(IRANG)=0
      NREELO(IRANG)=0
      NBTROU(IRANG)=0
      NBRENO(IRANG)=0
      NBSUPP(IRANG)=0
      LISTAT(IRANG)=LDIMST
      LMIMAL(IRANG)=.FALSE.
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ASGN')
C
      IF (LLNOUF) THEN
C*
C     4.1 - CAS DE CREATION DU FICHIER INDEXE - INITIALISATIONS DIVERSES
C-----------------------------------------------------------------------
C
        ILARPH=JPLARD*IFACTM
        INALPP=JPNAPP*IFACTM
C
        DO 412 J=1,ILARPH
        MLGPOS(IXM(J,IRANG))=0
  412   CONTINUE
C
        DO 413 J=1,JPNXNA
        CNOMAR(IXC(J,IRANG))=' '
  413   CONTINUE
C
        DO 414 J=1,ILARPH
        MDES1D(IXM(J,IRANG))=0
  414   CONTINUE
C
C         NOMBRE DE PAIRES D'ARTICLES D'INDEX RESERVES,
C         (ELLES OCCUPERONT LES ARTICLES 2 A (2*INBPIR+1) DU FICHIER)
C         ET REMPLISSAGE DE CERTAINS MOTS DE L'ARTICLE DOCUMENTAIRE.
C
        INBPIR=MAX0 (1,MIN0 (JPNXPR,1+(KNBARP-1)/INALPP))
        MDES1D(IXM(JPNPIR,IRANG))=INBPIR
        MDES1D(IXM(JPNAPH,IRANG))=1+2*INBPIR
        MDES1D(IXM(JPLPAR,IRANG))=ILARPH
        MDES1D(IXM(JPLMNA,IRANG))=JPNCPN
        MDES1D(IXM(JPLLDO,IRANG))=JPLDOC
        MDES1D(IXM(JPXAPI,IRANG))=INALPP
        MDES1D(IXM(JPFEAM,IRANG))=1
        NPODPI(IRANG)=1
        NALDPI(IRANG)=0
        NPPIMM(IRANG)=1
        IRANGD=IRANG
        CALL LFIDAH (MDES1D(IXM(JPDCRE,IRANG)),
     S               MDES1D(IXM(JPHCRE,IRANG)))
C
C          ECRITURE DU PREMIER ARTICLE (DESCRIPTIF)
C
        IREC=1
        INAPHY=IREC
        CALL LFIEDO (IREP,KNUMER,IREC,MDES1D(IXM(1,IRANG)),INWRIT,
     S               IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 904
        ENDIF
C
C
C     Remise a zero du descripteur en vue d'une fermeture normale.
C
        MDES1D(IXM(JPFEAM,IRANG))=0
C
C          ECRITURE DES ARTICLES CONTENANT LES PAIRES D'ARTICLES D'INDEX
C          "RESERVES".
C
        DO 415 J=1,INBPIR
        IREC=IREC+1
        INAPHY=IREC
        CALL LFIECC (IREP,KNUMER,IREC,CNOMAR(IXC(1,IRANG)),INWRIT,
     S               IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 903
        ENDIF
C
        IREC=IREC+1
        INAPHY=IREC
        CALL LFIEDO (IREP,KNUMER,IREC,MLGPOS(IXM(1,IRANG)),INWRIT,
     S               IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 904
        ENDIF
C
  415   CONTINUE
C
      ELSE
C*
C     4.2 - LE FICHIER EXISTAIT DEJA... ON LIT LA 1ERE PAIRE D'ARTICLES
C           D'INDEX ( + LA DERNIERE S'IL Y EN A AU MOINS 2 *UTILISEES* )
C-----------------------------------------------------------------------
C
        INBALO=MDES1D(IXM(JPNALO,IRANG))
        INBPIR=MDES1D(IXM(JPNPIR,IRANG))
        IREC=2
        INAPHY=IREC
        CALL LFILCC (IREP,KNUMER,IREC,CNOMAR(IXC(1,IRANG)),INREAD,
     S               IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 904
        ENDIF
C
        IREC=3
        INAPHY=IREC
        CALL LFILDO (IREP,KNUMER,IREC,MLGPOS(IXM(1,IRANG)),INREAD,
     S               IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 904
        ENDIF
C
        IF (INBALO.LE.INALPP) THEN
          NALDPI(IRANG)=INBALO
          NPODPI(IRANG)=1
          NPPIMM(IRANG)=1
          IRANGD=IRANG
        ELSE
C
C          CAS OU IL Y A AU MOINS 2 PAIRES D'ARTICLES D'INDEX UTILISEES.
C
          IRGPIF=1+(INBALO-1)/INALPP
          CALL LFIREC (IRGPIF,IRANG,IREC)
          IRANGD=IRANG+JPNXFI
          INAPHY=IREC
          CALL LFILCC (IREP,KNUMER,IREC,CNOMAR(IXC(1,IRANGD)),
     S                 INREAD,IFACTM,IRETIN)
C
          IF (IRETIN.NE.0) THEN
            GOTO 904
          ENDIF
C
          IREC=IREC+1
          INAPHY=IREC
          CALL LFILDO (IREP,KNUMER,IREC,MLGPOS(IXM(1,IRANGD)),
     S                 INREAD,IFACTM,IRETIN)
C
          IF (IRETIN.NE.0) THEN
            GOTO 904
          ENDIF
C
          NALDPI(IRANG)=1+MOD (INBALO-1,INALPP)
          NPODPI(IRANG)=2
          NPPIMM(IRANG)=2
          MRGPIM(2,IRANG)=IRANGD
          MRGPIF(IRANGD)=IRGPIF
        ENDIF
C
      ENDIF
C**
C     5.  -  L'OUVERTURE AU SENS DU LOGICIEL DE FICHIERS INDEXES LFI
C            EST COMPLETE; ON MET DONC A JOUR LES DERNIERES VARIABLES
C            EN COMMON, DONT *NBFIOU*.
C-----------------------------------------------------------------------
C
C           REMARQUE: LA PREMIERE ET LA DERNIERE P.P.I. SONT TOUJOURS
C                     "PHASEES".
C
      DO 501 J=IRANG,IRANGD,JPNXFI
      LECRPI(J,1)=.FALSE.
      LECRPI(J,2)=.FALSE.
      LPHASP(J)=.TRUE.
  501 CONTINUE
C
      DO 502 J=0,JPNPDF-1
      NUMAPD(J,IRANG)=JPNIL
      NLONPD(J,IRANG)=0
      LECRPD(J,IRANG)=.FALSE.
  502 CONTINUE
C
      DO 503 J=1,IFACTM
      NUMERO(IRANG+J-1)=KNUMER
  503 CONTINUE
C
      NDERPD(IRANG)=JPNPDF-1
      NBFIOU=NBFIOU+1
      NFACTM=NFACTM+IFACTM
      NUMIND(NBFIOU)=IRANG
      INBARI=MDES1D(IXM(JPNALO,IRANG))-MDES1D(IXM(JPNTRU,IRANG))
      NBREAD(IRANG)=INREAD
      NBWRIT(IRANG)=INWRIT
      LTAMPL(IRANG)=LTAMLG
      LTAMPE(IRANG)=LTAMEG
      NEXPOR(IRANG)=JPNIL
      NIMPOR(IRANG)=JPNIL
C
      IREP=IREPX
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  901 CONTINUE
      CLACTI='INQUIRE'
      INAPHY=0
      GOTO 909
C
  902 CONTINUE
      CLACTI='OPEN'
      IRANG=0
      IRANMS=0
      INAPHY=0
      GOTO 909
C
  903 CONTINUE
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      CLACTI='READ'
      GOTO 909
C
  905 CONTINUE
      CLACTI='CLOSE'
      INAPHY=0
C
  909 CONTINUE
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      IREP=IABS (IREP)
      NUMAPH(IRANG)=INAPHY
      IF (IRANG.EQ.0) MFACTM(0)=IFACTM
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      KNBARI=INBARI
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (LLFATA) THEN
        INIMES=2
      ELSE
        INIMES=IXNIMS (IRANMS)
      ENDIF
C
       IF (LMULTI.AND.LLVERG) CALL LFIVER (VERGLA,'OFF')
C
      IF (.NOT.LLFATA.AND.INIMES.EQ.0) RETURN
C
      CLNSPR='LFIOUV'
C
      IF (INIMES.GE.1) THEN
C
C           Impression du nom du fichier.
C
        IF (LFRANC) THEN
          ILUTIL=MIN0 (INLNOM,JPLFIX,LEN (CLMESS)-6)
          CLMESS='Nom='''//CLNOMF(:ILUTIL)//''''
        ELSE
          ILUTIL=MIN0 (INLNOM,JPLFIX,LEN (CLMESS)-7)
          CLMESS='Name='''//CLNOMF(:ILUTIL)//''''
        ENDIF
C
        CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
C
        IF (LDNOMM.AND.CLNOMS(:ILNOMS).NE.CLNOMF(:INLNOM)) THEN
C
          IF (LFRANC) THEN
            ILUTIL=MIN0 (ILNOMS,JPLFIX,LEN (CLMESS)-14)
            CLMESS='Nom SYSTEME='''//CLNOMS(:ILUTIL)//''''
          ELSE
            ILUTIL=MIN0 (ILNOMS,JPLFIX,LEN (CLMESS)-14)
            CLMESS='SYSTEM Name='''//CLNOMS(:ILUTIL)//''''
          ENDIF
C
          CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
        ENDIF
C
      ENDIF
C
      IF (INIMES.EQ.2) THEN
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,
     S     '', LDNOMM= '',L1,'', CDSTTO='''''',A,'''''', LDERFA= '',L1,
     S     '',  LDIMST= '',L1,
     S         '', KNIMES='',I2,'', KNBARP='',I6,'' KNBARI='',I6)')
     S   KREP,KNUMER,LDNOMM,CDSTTO(:ILSTTU),LDERFA,LDIMST,KNIMES,KNBARP,
     S   KNBARI
        CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
C        LA MESSAGERIE QUI SUIT N'EST PAS EMISE EN CAS D'ERREUR FATALE.
C
      IF (INIMES.GE.1.AND.(IREP.EQ.0.OR.IREP.EQ.-11)) THEN
C
        IF (LLNOUF) THEN
C
          IF (LFRANC) THEN
            WRITE (UNIT=CLMESS,FMT='(''Unite'',I3,
     S   '' OUVERTE, CREATION de Fichier,'',I7,'' Articles prevus,'',I7,
     S   '' Articles gerables sans debordement'')')
     S      KNUMER,KNBARP,INALPP*INBPIR
          ELSE
            WRITE (UNIT=CLMESS,FMT='(''Unit'',I3,
     S   '' OPENED, File CREATION,'',I7,'' expected Records,'',I7,
     S   '' Records may be handled without overflow'')')
     S      KNUMER,KNBARP,INALPP*INBPIR
          ENDIF
C
        ELSE
C
          IF (LFRANC) THEN
            WRITE (UNIT=CLMESS,FMT='(''Unite'',I3,
     S       '' OUVERTE, derniere Modification OK a'',I9.6,''_'',I6.6,
     S       '','',I7,'' Articles de donnees,'',I9,'' mots en tout'')')
     S     KNUMER,MDES1D(IXM(JPDDMG,IRANG)),MDES1D(IXM(JPHDMG,IRANG)),
     S            KNBARI,ILARPH*MDES1D(IXM(JPNAPH,IRANG))
          ELSE
            WRITE (UNIT=CLMESS,FMT='(''Unit'',I3,
     S       '' OPENED, last Modification OK at'',I9.6,''_'',I6.6,
     S       '','',I7,'' data Records,'',I9,'' words in file'')')
     S     KNUMER,MDES1D(IXM(JPDDMG,IRANG)),MDES1D(IXM(JPHDMG,IRANG)),
     S            KNBARI,ILARPH*MDES1D(IXM(JPNAPH,IRANG))
          ENDIF
C
        ENDIF
C
        CALL LFIEMS (KNUMER,INIMES,IREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIPHA ( KREP, KRANG, KRGPIM, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     PHASAGE D'UNE PAGE D'INDEX "LONGUEUR/POSITION"
C     AVEC LA PAGE D'INDEX "NOMS" CORRESPONDANTE.
C        IL EST ABSOLUMENT NECESSAIRE QUE LA PAGE D'INDEX "NOMS" SOIT
C     EFFECTIVEMENT ALIMENTEE AVANT L'APPEL DE CE SOUS-PROGRAMME...
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DE LA LECTURE DE PAGE;
C                KRANG  (ENTREE) ==> RANG DE L'UNITE LOGIQUE CONCERNEE;
C                KRGPIM (ENTREE) ==> NUMERO DE LA PAGE CONCERNEE;
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP, KRANG, KRGPIM, KRETIN, INUMER, IREC, INAPHY, INIMES
      INTEGER IRETOU, IRETIN
C
#include "lficom2.h"
C
      IRETOU=0
      INUMER=NUMERO(KRANG)
      CALL LFIREC (MRGPIF(KRGPIM),KRANG,IREC)
      INAPHY=IREC+1
      CALL LFILDO (KREP,INUMER,IREC+1,MLGPOS(IXM(1,KRGPIM)),
     S             NBREAD(KRANG),MFACTM(KRANG),IRETIN)
C
      IF (IRETIN.NE.0) THEN
        GOTO 904
      ENDIF
C
      LPHASP(KRGPIM)=.TRUE.
      GOTO 1001
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C
      KREP=IABS (KREP)
      NUMAPH(KRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFIPHA'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I3,
     S         '', KRGPIM='',I3,'', KRETIN='',I2)')
     S    KREP,KRANG,KRGPIM,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIPIM ( KREP ,KRANG, KRANGM, KRGPIM, KRGPIF, KRGFOR,
     S                    KNPILE, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     GESTION DES REQUETES D'ALLOCATION D'UNE PAIRE DE PAGES D'INDEX
C     SUPPLEMENTAIRE ( APPELS PAR LFIECR, LFILEC... ), ET LECTURE
C     EVENTUELLE SUR FICHIER D'ARTICLE(S) D'INDEX CORRESPONDANT(S) .
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                KRANGM (SORTIE) ==> RANG ( DANS LA TABLE *MRGPIM* )
C                                    DE LA P.P.I. AFFECTEE;
C                                    ( ZERO SI PAS DE P.P.I. ALLOUEE )
C                KRGPIM (SORTIE) ==> RANG ( DANS LES TABLES DECRIVANT
C                                    LES PAIRES DE PAGES D'INDEX ) DE
C                                    LA P.P.I. SUPPLEMENTAIRE ALLOUEE,
C                                    ZERO SI PAS DE P.P.I. ALLOUEE;
C                KRGPIF (ENTREE) ==> RANG ( DANS LE FICHIER ) DE LA
C                                    P.P.I. SUPPLEMENTAIRE;
C                KRGFOR (ENTREE) ==> RANG ( DANS LE FICHIER ) D'UNE
C                                    EVENTUELLE P.P.I. A CONSERVER;
C                KNPILE (ENTREE) ==> NOMBRE D'ARTICLES D'INDEX A LIRE
C                                    ( 0==>RIEN, 1==>NOMS, 2==>LES 2 );
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
C     SI L'ON NE TROUVE PLUS DE P.P.I. LIBRE, ON "RECYCLE" LA P.P.I.
C     ASSOCIEE AU PLUS GRAND RANG DANS LA TABLE *MRGPIM*,
C         EXCEPTION FAITE DE LA PREMIERE, DE LA DERNIERE, ET DE CELLE
C     DE RANG *KRGFOR* DANS LE FICHIER,
C     CECI POUR ASSURER QUE LORS D'UNE EXPLORATION DES P.P.I.,
C     ON NE REUTILISE PAS L'EMPLACEMENT D'UNE P.P.I. QU'ON A DEJA
C     EXPLOREE, OU QU'ON DOIT GARDER POUR LA LOGIQUE DU TRAITEMENT.
C        LE "FORCAGE" N'EST EFFECTIF QUE SI LE RANG DANS LE FICHIER EST
C     BIEN CELUI D'UNE P.P.I, MAIS NI LA PREMIERE NI LA DERNIERE
C     EN RANG DANS LE FICHIER.
C*
C         LE VERROUILLAGE EVENTUEL DE L'UNITE LOGIQUE DE RANG *KRANG*
C     DOIT AVOIR ETE FAIT EN AMONT, AVANT L'APPEL A CE SOUS-PROGRAMME.
C
C        Noter que la P.P.I. peut etre "multiple", et qu'elle occupe
C     autant de P.P.I. "elementaires" (de longueur JPLARD par page) ,
C     ces P.P.I. "elementaires" etant necessairement consecutives...
C        Dans ce cas KRGPIM designe le rang de la PREMIERE P.P.I. ele-
C     mentaire concernee.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP ,KRANG, KRANGM, KRGPIM, KRGPIF, KRGFOR, KNPILE
      INTEGER IRANG, INUMER, INPPIM, IFACTM, IRGPIM, IRANGM, ICOMPT, J
      INTEGER JR, IREC, INAPHY, IRETOU, INIMES, KRETIN, IRETIN
C
      LOGICAL LLAUX1, LLAUX2, LLADON
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      KRANGM=0
      KRGPIM=0
      IRETOU=0
      INAPHY=0
      LLADON=.FALSE.
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI.OR.KRGPIF.LE.0.OR.
     S    KNPILE.LT.0.OR.KNPILE.GT.2) THEN
        KREP=-16
        GOTO 1001
      ELSE
        IRANG=KRANG
        INUMER=NUMERO(KRANG)
C
        IF (INUMER.LT.0) THEN
          KREP=-16
          GOTO 1001
        ENDIF
C
      ENDIF
C
      INPPIM=NPPIMM(IRANG)
      IFACTM=MFACTM(IRANG)
C**
C     2.  -  RECHERCHE D'UNE P.P.I. SUPPLEMENTAIRE .
C-----------------------------------------------------------------------
C
      IF (INPPIM.LE.0) THEN
        KREP=-16
        GOTO 1001
      ELSEIF (INPPIM.LT.JPNPIA) THEN
C*
C     2.1 - CAS OU L'UNE DES P.P.I. PREALLOUEES AU FICHIER EST
C           DISPONIBLE.
C-----------------------------------------------------------------------
C
        IRGPIM=IRANG+INPPIM*JPNXFI
        INPPIM=INPPIM+1
        IRANGM=INPPIM
        NPPIMM(IRANG)=INPPIM
        GOTO 300
      ELSEIF (JPNPIS.GT.0) THEN
C*
C     2.2 - PLUS DE P.P.I. PREALLOUEE LIBRE; RECHERCHE DANS
C           LES P.P.I. ALLOUABLES DYNAMIQUEMENT.
C-----------------------------------------------------------------------
C
C           VERROUILLAGE EVENTUEL POUR L'UTILISATION DE *NPISAF*
C
         IF (LMULTI) CALL LFIVER (VERGLA,'ON')
C
        IF (NPISAF.LT.JPNPIS) THEN
          ICOMPT=0
C
          DO 221 J=JPNPIA*JPNXFI+1,JPNXPI
C
          IF (MCOPIF(J).EQ.JPNIL) THEN
            ICOMPT=ICOMPT+1
C
            IF (ICOMPT.EQ.IFACTM) THEN
              IRGPIM=J+1-IFACTM
              GOTO 222
            ENDIF
C
          ELSE
            ICOMPT=0
          ENDIF
C
  221     CONTINUE
C
C              Chou blanc... on deverrouille globalement.
C
           IF (LMULTI) CALL LFIVER (VERGLA,'OFF')
          IF (IFACTM.GT.1) GOTO 230
C
C              CAS D'INCOHERENCE DES TABLES DU LOGICIEL !
C
          KREP=-16
          GOTO 1001
C
  222     CONTINUE
C
C            UNE P.P.I. "LIBRE", eventuellement Multiple, A ETE TROUVEE.
C
          NPISAF=NPISAF+IFACTM
C
          DO 223 JR=IRGPIM,IRGPIM+IFACTM-1
          MCOPIF(JR)=IRANG
  223     CONTINUE
C
C         ON DEVERROUILLE "GLOBALEMENT", CAR CE QUI SUIT ALORS
C         NE CONCERNE PLUS QUE LE FICHIER.
C
           IF (LMULTI) CALL LFIVER (VERGLA,'OFF')
          INPPIM=INPPIM+1
          IRANGM=INPPIM
          NPPIMM(IRANG)=INPPIM
          MRGPIM(INPPIM,IRANG)=IRGPIM
          GOTO 300
C
        ELSE
C
C            CAS OU IL N'Y A PLUS DE P.P.I. "LIBRE" .
C         ON DEVERROUILLE "GLOBALEMENT", CAR CE QUI SUIT ALORS
C         NE CONCERNE PLUS QUE LE FICHIER.
C
           IF (LMULTI) CALL LFIVER (VERGLA,'OFF')
        ENDIF
C
      ENDIF
C
  230 CONTINUE
C*
C     2.3 - PLUS DE P.P.I. ( PREALLOUEE OU NON ) LIBRE.
C-----------------------------------------------------------------------
C
C         ON VA DONC RECYCLER LA P.P.I. ALLOUEE AU FICHIER
C       QUI SOIT ASSOCIEE AU PLUS GRAND RANG DANS LA TABLE *MRGPIM*,
C       TOUT EN N'ETANT NI LA PREMIERE, NI LA DERNIERE, NI CELLE DE
C       RANG *KRGFOR* DANS LE FICHIER .
C        C'est pour etre sur de trouver une telle page que l'on a besoin
C     d'avoir JPNPIA superieur ou egal a 4.
C
      IRANGM=INPPIM
C
  231 CONTINUE
C
      IF (IRANGM.EQ.NPODPI(IRANG).OR.
     S    MRGPIF(MRGPIM(IRANGM,IRANG)).EQ.KRGFOR) THEN
        IRANGM=IRANGM-1
        GOTO 231
      ENDIF
C
      IRGPIM=MRGPIM(IRANGM,IRANG)
      LLAUX1=LECRPI(IRGPIM,1)
      LLAUX2=LECRPI(IRGPIM,2).AND.LPHASP(IRGPIM)
C
C          SI NECESSAIRE, ON REECRIT SUR LE FICHIER
C       LA OU LES PAGES D'INDEX qu'on va reutiliser.
C
      IF (LLAUX1.OR.LLAUX2) THEN
        CALL LFIREC (MRGPIF(IRGPIM),IRANG,IREC)
C
        IF (LLAUX1) THEN
          INAPHY=IREC
          CALL LFIECC (KREP,INUMER,IREC,CNOMAR(IXC(1,IRGPIM)),
     S                 NBWRIT(IRANG),IFACTM,IRETIN)
C
          IF (IRETIN.NE.0) THEN
            GOTO 903
          ENDIF
C
          INAPHY=0
        ENDIF
C
        IF (LLAUX2) THEN
          CALL LFIECX (KREP,IRANG,IREC+1,MLGPOS(IXM(1,IRGPIM)),LLADON,
     S                 IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
      ENDIF
C
  300 CONTINUE
C**
C     3.  -  MISE A JOUR DE TABLES, NE NECESSITANT PAS LA PROTECTION DU
C            VERROU GLOBAL; A PARTIR DU MOMENT OU *MCOPIF* A ETE MIS A
C            JOUR, LE SIMPLE VERROUILLAGE DE L'UNITE LOGIQUE SUFFIT.
C             ( ET EST CENSE AVOIR ETE FAIT DANS LE SOUS-PROGRAMME
C               APPELANT, EN MODE MULTI )
C-----------------------------------------------------------------------
C
      LECRPI(IRGPIM,1)=.FALSE.
      LECRPI(IRGPIM,2)=.FALSE.
      LPHASP(IRGPIM)=.FALSE.
      MRGPIF(IRGPIM)=KRGPIF
C**
C     4.  -  MISE EN MEMOIRE EVENTUELLE D'ARTICLE(S) D'INDEX
C            CORRESPONDANT A LA NOUVELLE P.P.I.
C-----------------------------------------------------------------------
C
      IF (KNPILE.NE.0) THEN
        CALL LFIREC (KRGPIF,IRANG,IREC)
        INAPHY=IREC
        CALL LFILCC (KREP,INUMER,IREC,CNOMAR(IXC(1,IRGPIM)),
     S               NBREAD(IRANG),IFACTM,IRETIN)
C
        IF (IRETIN.NE.0) THEN
          GOTO 904
        ENDIF
C
        IF (KNPILE.EQ.2) THEN
C
C             PHASAGE DIRECT, SANS APPEL AU SOUS-PROGRAMME "LFIPHA" .
C
          INAPHY=IREC+1
          CALL LFILDO (KREP,INUMER,IREC+1,MLGPOS(IXM(1,IRGPIM)),
     S                 NBREAD(IRANG),IFACTM,IRETIN)
C
          IF (IRETIN.NE.0) THEN
            GOTO 904
          ENDIF
C
          LPHASP(IRGPIM)=.TRUE.
C
        ENDIF
C
      ENDIF
C
      KREP=0
      KRANGM=IRANGM
      KRGPIM=IRGPIM
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
C
C        "DESALLOCATION" DE LA P.P.I. SUITE A ERREUR EN LECTURE
C     DE L'ARTICLE D'INDEX "NOMS".
C
      IF (INPPIM.GT.JPNPIA) THEN
         IF (LMULTI) CALL LFIVER (VERGLA,'ON')
        NPISAF=NPISAF-IFACTM
C
        DO 906 JR=IRGPIM,IRGPIM+IFACTM-1
        MCOPIF(JR)=JPNIL
  906   CONTINUE
C
         IF (LMULTI) CALL LFIVER (VERGLA,'OFF')
      ENDIF
C
      NPPIMM(IRANG)=INPPIM-1
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
C
C       ON FORCE LE CODE-REPONSE A ETRE POSITIF.
C
      KREP=IABS (KREP)
      IF (INAPHY.NE.0) NUMAPH(IRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFIPIM'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I5,'', KRANG='',I3,
     S       '', KRANGM='',I3,'', KRGPIM='',I3,'', KRGPIF='',I4,
     S       '', KRGFOR='',I4,'', KNPILE='',I2,'', KRETIN='',I2)')
     S    KREP,KRANG,KRANGM,KRGPIM,KRGPIF,KRGFOR,KNPILE,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIPOS ( KREP, KNUMER )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME REMETTANT A LA VALEUR INITIALE LE "POINTEUR" DU
C     FICHIER, QUI SERT AUX ACCES "PSEUDO-SEQUENTIELS" SUR UNE UNITE
C     LOGIQUE OUVERTE POUR LE LOGICIEL DE FICHIERS INDEXES *LFI* .
C        APRES APPEL A CE SOUS-PROGRAMME, LE PREMIER APPEL SUIVANT A
C     *LFICAS* OU *LFILAS* D'UNE PART, OU BIEN A *LFICAP* OU *LFILAP*
C     D'AUTRE PART, CONCERNERA LE PREMIER (RESPECTIVEMENT LE DERNIER)
C     ARTICLE LOGIQUE DE DONNEES PRESENT (EN POSITION) DANS LE FICHIER,
C     SI L'ON N'APPELLE PAS *LFILEC* ENTRETEMPS.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KNUMER (ENTREE) ==> NUMERO DE L'UNITE LOGIQUE.
C
C

#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
C
      INTEGER KREP, KNUMER, IREP, IRANG, INIMES
C
C
C       FONCTION SERVANT A RENDRE FATALE OU NON UNE ERREUR DETECTEE,
C       A L'AIDE DU CODE-REPONSE COURANT, DU NIVEAU DE FILTRAGE GLOBAL,
C       ET DE L'OPTION D'ERREUR FATALE PROPRE AU FICHIER.
C       S'IL N'Y A PAS DE FICHIER (I5678=0, D'OU DIMENSIONNEMENT DE
C          *LERFAT*), LE NIVEAU DE FILTRAGE JOUE LE ROLE PRINCIPAL.
C
      INTEGER IXNIMS, I1234, I5678, I3456, IXC, IXM, IXT, IABCDE, IFGHIJ
      INTEGER IKLMNO, IPQRST, IUVWXY, IZABCD, IEFGHI
C
      LOGICAL LLMOER
C
      LLMOER (I1234,I5678)=I1234.EQ.-16.OR.
     S (I1234.NE.0.AND.(NERFAG.EQ.0.OR.(NERFAG.EQ.1.AND.LERFAT(I5678))))
C
C       FONCTION DONNANT LE PLUS HAUT NIVEAU DE MESSAGERIE ACCEPTABLE
C       POUR L'UNITE LOGIQUE DE RANG "I3456" .
C       (UTILISATION DES NIVEAUX DE MESSAGERIE GLOBAL ET PROPRE AU
C        FICHIER - MEME REMARQUE QUE CI-DESSUS SI I3456=0, POUR NIVMES)
C
      IXNIMS (I3456)=MIN0 (2,2*NIMESG,MAX0 (2*NIMESG-2,NIVMES(I3456)))
C
C       Fonctions servant a l'adressage 1D dans les tableaux CNOMAR,
C     MLGPOS et MDES1D, MTAMPD.
C
      IXC (IABCDE,IFGHIJ) = IABCDE + JPNXNA * ( IFGHIJ - 1 )
      IXM (IKLMNO,IPQRST) = IKLMNO + JPLARD * ( IPQRST - 1 )
      IXT (IUVWXY,IZABCD,IEFGHI) = IUVWXY + JPLARD *
     S ( MFACTM(IEFGHI) * IZABCD + JPNPDF * ( IEFGHI - 1 ) )
C
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IREP=0
      CALL LFINUM (KNUMER,IRANG)
C
      IF (IRANG.EQ.0) THEN
        IREP=-1
        GOTO 1001
      ENDIF
C
       IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'ON')
C**
C     2.  -  REINITIALISATION DU "POINTEUR" ET DES VALEURS "SUIVANTE"
C            ET "PRECEDENTE" .
C-----------------------------------------------------------------------
C
      NDERGF(IRANG)=JPNIL
      CNDERA(IRANG)=' '
      NSUIVF(IRANG)=JPNIL
      NPRECF(IRANG)=JPNIL
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
C            VIA LE SOUS-PROGRAMME "LFIEMS" .
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      KREP=IREP
      LLFATA=LLMOER (IREP,IRANG)
C
      IF (IRANG.NE.0) THEN
        NDEROP(IRANG)=14
        NDERCO(IRANG)=IREP
         IF (LMULTI) CALL LFIVER (VERRUE(IRANG),'OFF')
      ENDIF
C
      IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
        INIMES=2
      ELSE
        RETURN
      ENDIF
C
      CLNSPR='LFIPOS'
      WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3)')
     S     KREP,KNUMER
      CALL LFIEMS (KNUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
C
      RETURN
      END
      SUBROUTINE LFIRAN ( KREP, KRANG, CDNOMA, KRGPIM, KARTEX, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     RECHERCHE D'UN ARTICLE LOGIQUE PAR NOM, DANS UNE UNITE LOGIQUE.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                CDNOMA (ENTREE) ==> NOM DE L'ARTICLE A RECHERCHER;
C                KRGPIM (SORTIE) ==> RANG DANS LES TABLES CNOMAR,MLGPOS,
C                                    ETC. DE LA P.P.I OU FIGURE
C                                    L'ARTICLE ( 0 SI PAS TROUVE );
C                KARTEX (SORTIE) ==> RANG ( DANS LA PAGE D'INDEX ) DE L'
C                                    ARTICLE S'IL EXISTE ( 0 SINON );
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CDNOMA*(*), CLNOMA*(JPNCPN)
C
      INTEGER KREP, KRANG, KRGPIM, KARTEX, ILCDNO, IRANG, IFACTM, INALPP
      INTEGER INBALO, INTPPI, IRANGF, IRGPIF, J, ILFORC, INPILE, IRANGM
      INTEGER IRGPIM, IARTIC, INPIME, IRPIFN, INPPIM, IDEBEX, INUMER
      INTEGER JNPAGE, INALPI, IRETOU, INIMES, INBVAL, KRETIN, IRETIN
      INTEGER IEXPLO (JPNPIA+JPNPIS), INDICE (JPNAPX)
C
#include "lficom2.h"
C**
C     1.  -  PREAMBULES.
C-----------------------------------------------------------------------
C*
C     1.1 - CONTROLES DES PARAMETRES D'APPEL ET INITIALISATIONS.
C-----------------------------------------------------------------------
C
      ILCDNO=LEN (CDNOMA)
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI.OR.
     S    ILCDNO.LE.0.OR.ILCDNO.GT.JPNCPN.OR.CDNOMA.EQ.' ') THEN
        KREP=-16
        GOTO 1001
      ENDIF
C
      IRANG=KRANG
      KREP=0
      IFACTM=MFACTM(IRANG)
      INALPP=JPNAPP*IFACTM
      INBALO=MDES1D(IXM(JPNALO,IRANG))
      INTPPI=(INBALO-1+INALPP)/INALPP
      IF (LMISOP) PRINT *,'LFIRAN - INBALO= ',INBALO,', INTPPI= ',INTPPI
C*
C     1.2 - CAS "ELEMENTAIRES" OU CHANCEUX.
C-----------------------------------------------------------------------
C
      IF (INBALO.EQ.0) THEN
C
C          Fichier vide ou depourvu d'articles logiques de donnees.
C
        GOTO 300
C
      ELSEIF (NDERGF(IRANG).NE.JPNIL.AND.CNDERA(IRANG).EQ.CDNOMA) THEN
C
C          Le dernier article demande via LFINFO (cas le plus probable)
C     ou LFILAS/LFILAP/LFICAS/LFICAP etait celui cherche !
C
        IRANGF=NDERGF(IRANG)
        IRGPIF=1+(IRANGF-1)/INALPP
C
        IF (IRANGF.LE.INALPP) THEN
          IRGPIM=MRGPIM(1,IRANG)
        ELSEIF (IRANGF.GT.INALPP*(INTPPI-1)) THEN
          IRGPIM=MRGPIM(NPODPI(IRANG),IRANG)
        ELSE
C
          DO 121 J=2,NPPIMM(IRANG)
          IRGPIM=MRGPIM(J,IRANG)
          IF (MRGPIF(IRGPIM).EQ.IRGPIF) GOTO 122
  121     CONTINUE
C
C           MISE EN MEMOIRE DE L'ARTICLE D'INDEX "NOMS" CHERCHE.
C
          ILFORC=1
          INPILE=1
          CALL LFIPIM (KREP,IRANG,IRANGM,IRGPIM,IRGPIF,ILFORC,INPILE,
     S                 IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
  122   CONTINUE
        IARTIC=IRANGF-INALPP*(IRGPIF-1)
C
        IF (CNOMAR(IXC(IARTIC,IRGPIM)).EQ.CDNOMA) THEN
          KRGPIM=IRGPIM
          KARTEX=IARTIC
        ELSE
          KREP=-16
        ENDIF
C
        GOTO 1001
C
      ENDIF
C
      INPIME=0
      IRPIFN=1
      INPPIM=NPPIMM(IRANG)
      IF (LPRECH) CLNOMA=CDNOMA
C
      IF (NPODPI(IRANG).EQ.2) THEN
        IDEBEX=3
      ELSE
        IDEBEX=2
      ENDIF
C**
C     2.  -  EXPLORATION DES PAGES ET ARTICLES D'INDEX "NOMS",
C            A LA RECHERCHE DE L'ARTICLE LOGIQUE. ( ON COMMENCE
C            PAR EXPLORER LES PAGES D'INDEX )
C-----------------------------------------------------------------------
C
      DO 205 JNPAGE=1,INTPPI
C
      IF (JNPAGE.LE.INPPIM) THEN
C
C           IL S'AGIT D'UNE EXPLORATION EN MEMOIRE ( PAGE D'INDEX ).
C
        IRGPIM=MRGPIM(JNPAGE,IRANG)
        IRGPIF=MRGPIF(IRGPIM)
        INPIME=INPIME+1
        IEXPLO(INPIME)=IRGPIF
        IF (IRGPIF.EQ.(IRPIFN+1)) IRPIFN=IRGPIF
      ELSE
C
C           IL S'AGIT D'UNE EXPLORATION "HORS MEMOIRE";
C         ON CHERCHE LA PROCHAINE P.A.I. NON EXPLOREE .
C
        IF (JNPAGE.EQ.INPPIM+1) IRGPIF=IRPIFN
C
  201   CONTINUE
        IRGPIF=IRGPIF+1
C
        DO 202 J=IDEBEX,INPIME
        IF (IEXPLO(J).EQ.IRGPIF) GOTO 201
  202   CONTINUE
C
        ILFORC=1
        INPILE=1
        CALL LFIPIM (KREP,IRANG,IRANGM,IRGPIM,IRGPIF,ILFORC,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
      ENDIF
C
      INALPI=MIN0 (INALPP,INBALO-(IRGPIF-1)*INALPP)
C
      IF (LPRECH) THEN
        CALL LFIRAC (CNOMAR(IXC(1,IRGPIM)),INALPI,CLNOMA,INDICE,INBVAL)
C
        IF (INBVAL.NE.0) THEN
          KRGPIM=IRGPIM
          KARTEX=INDICE(1)
          GOTO 1001
        ENDIF
C
      ELSE
C
        DO 204 J=1,INALPI
C
        IF (CNOMAR(IXC(J,IRGPIM)).EQ.CDNOMA) THEN
          KRGPIM=IRGPIM
          KARTEX=J
          GOTO 1001
        ENDIF
C
  204   CONTINUE
C
      ENDIF
C
  205 CONTINUE
C
  300 CONTINUE
C**
C     3.  -  CAS OU L'ARTICLE N'A PAS ETE TROUVE.
C-----------------------------------------------------------------------
C
      KRGPIM=0
      KARTEX=0
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
      KREP=IABS (KREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INUMER=NUMERO(KRANG)
        INIMES=2
        CLNSPR='LFIRAN'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I3,
     S  '', CDNOMA='''''',A,'''''', KRGPIM='',I3,'', KARTEX='',I5,
     S  '', KRETIN='',I2)')
     S    KREP,KRANG,CDNOMA,KRGPIM,KARTEX,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIREC ( KRGPIF, KRANG, KREC )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     DETERMINATION DU NUMERO D'ENREGISTREMENT D'UNE PAIRE D'ARTICLES
C     D'INDEX ( NUMERO DE L'ARTICLE "NOMS", EN FAIT ) .
C**
C    ARGUMENTS : KRGPIF (ENTREE) ==> RANG DE LA P.P.I. DANS LE FICHIER;
C                KRANG  (ENTREE) ==> RANG DE L'UNITE DANS NUMERO.
C                KREC   (SORTIE) ==> NUMERO D'ENREGISTREMENT DE LA P.A.I
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KRGPIF, KRANG, KREC, INBPIR, INBALO, IFACTM, INALPP
      INTEGER ILARPH, INTPPI, IREP, INIMES, INUMER
C
#include "lficom2.h"
C
      INBPIR=MDES1D(IXM(JPNPIR,KRANG))
      INBALO=MDES1D(IXM(JPNALO,KRANG))
      IFACTM=MFACTM(KRANG)
      INALPP=JPNAPP*IFACTM
      ILARPH=JPLARD*IFACTM
      INTPPI=(INBALO-1+INALPP)/INALPP
C
      IF (KRGPIF.LE.INBPIR) THEN
        KREC=2*KRGPIF
      ELSEIF (KRGPIF.LE.INTPPI) THEN
C
C     CAS OU LES ARTICLES D'INDEX "RESERVES" A LA CREATION DU FICHIER
C     N'ONT PAS SUFFI A STOCKER TOUS LES DESCRIPTEURS D'ARTICLES LOGI-
C     QUES: L'EMPLACEMENT DES PAIRES D'ARTICLES D'INDEX EXCEDENTAIRES
C     EST ALORS STOCKE DANS L'ARTICLE DOCUMENTAIRE, APRES LES VALEURS
C     "UTILES" (JPLDOC MOTS), EN COMMENCANT PAR LA FIN DE CET ARTICLE.
C       ( CECI POUR MENAGER UNE EVENTUELLE AUGMENTATION DE *JPLDOC*,
C         EN CAS D'EVOLUTION DU LOGICIEL )
C
        KREC=MDES1D(IXM(ILARPH+1-(KRGPIF-INBPIR),KRANG))
      ELSE
C
C          CAS OU IL Y A INCOHERENCE ENTRE TABLES ET ARGUMENTS D'APPEL
C
        KREC=0
        IREP=-16
C
C        MESSAGERIE EVENTUELLE, AVEC ABORT SI NECESSAIRE .
C
        LLFATA=LLMOER (IREP,KRANG)
C
        IF (LLFATA.OR.NIMESG.NE.0) THEN
          INIMES=2
          CLNSPR='LFIREC'
          INUMER=NUMERO(KRANG)
C
          IF (LFRANC) THEN
            WRITE (UNIT=CLMESS,FMT='(''KRGPIF='',I4,'', KRANG='',I3,
     S             '', KREC='',I6,'', CODE "INTERNE"='',I4)')
     S        KRGPIF,KRANG,KREC,IREP
          ELSE
            WRITE (UNIT=CLMESS,FMT='(''KRGPIF='',I4,'', KRANG='',I3,
     S             '', KREC='',I6,'', "INTERNAL" CODE='',I4)')
     S        KRGPIF,KRANG,KREC,IREP
          ENDIF
C
          CALL LFIEMS (INUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
        ENDIF
C
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIREE ( KREP, KRANG, CDNOMA, KLONG, KRPIEX, KARTEX,
     S                    KLONEX, KRPIEC, KARTEC, KPOSEC, KDTROU,
     S                    KLONUT, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     RECHERCHE D'UN EMPLACEMENT OU ECRIRE UN ARTICLE LOGIQUE, DANS
C     L'UNITE LOGIQUE CONCERNEE.
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
C                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *NUMERO* )
C                                    DE L'UNITE LOGIQUE CONCERNEE;
C                CDNOMA (ENTREE) ==> NOM DE L'ARTICLE A RECHERCHER;
C                KLONG  (ENTREE) ==> LONGUEUR DE L'ARTICLE A ECRIRE;
C                KRPIEX (SORTIE) ==> RANG ( DANS LE FICHIER ) DE L'ARTI-
C                                    CLE S'IL EXISTAIT DEJA ( 0 SINON );
C                KARTEX (SORTIE) ==> RANG ( DANS LA PAGE D'INDEX ) DE L'
C                                    ARTICLE S'IL EXISTAIT ( 0 SINON );
C                KLONEX (SORTIE) ==> LONGUEUR DE L'ARTICLE S'IL EXISTAIT
C                                    DEJA ( 0 SINON );
C                KRPIEC (SORTIE) ==> RANG ( DANS LE FICHIER ) DE L'ARTI-
C                                    CLE A ECRIRE;
C                KARTEC (SORTIE) ==> RANG ( DANS LA PAGE D'INDEX ) DE L'
C                                    ARTICLE A ECRIRE;
C                KPOSEC (SORTIE) ==> POSITION ( DANS LE FICHIER ) OU
C                                    COMMENCER A ECRIRE L'ARTICLE;
C                KDTROU (SORTIE) ==> VARIATION DU NOMBRE DE TROUS DANS
C                                    L'INDEX, DUE A CETTE ECRITURE;
C                KLONUT (SORTIE) ==> SI L'ON VA CREER UN TROU DANS L'IN-
C                                    DEX, LONGUEUR TOTALE UTILISABLE DE
C                                    CE TROU;
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C*
C    METHODE: SI L'ARTICLE EXISTE DEJA DANS LE FICHIER, ON ESSAIE AUTANT
C             QUE POSSIBLE DE "REECRIRE" SUR PLACE, CE QUI EST POSSIBLE
C             SI L'ON A UNE LONGUEUR D'ARTICLE INFERIEURE OU EGALE A
C             CELLE EXISTANTE, MAIS EST AUSSI POSSIBLE PAR RECYCLAGE
C             DE "TROUS" DE 2 CATEGORIES: EN FIN D'ARTICLE EXISTANT
C             ( AVANT L'ARTICLE LOGIQUE OU L'ARTICLE D'INDEX SUIVANT ),
C             ET/OU S'IL EXISTE UN "TROU" REPERTORIE DANS L'INDEX CORRE-
C             SPONDANT A UN ARTICLE LOGIQUE JUSTE DERRIERE CELUI EXIS-
C             TANT.
C                SI LA REECRITURE N'EST PAS POSSIBLE, ON ESSAIE ALORS DE
C             REUTILISER UN EVENTUEL "TROU" REPERTORIE DANS L'INDEX;
C             EN DESESPOIR DE CAUSE, ON ECRIT EN FIN DE FICHIER.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CDNOMA*(*), CLNOMA*(JPNCPN), CLBLAN*(JPNCPN)
C
      INTEGER KREP, KRANG, KLONG, KRPIEX, KARTEX, KLONEX, KRPIEC, KARTEC
      INTEGER KPOSEC, KDTROU, KLONUT, ILCDNO, IRANG, ILTSUF, INTTRU, J
      INTEGER INBALO, INBPIR, IFACTM, ILARPH, INALPP, INTPPI, IRNGSU
      INTEGER INPPIM, INPIME, INTROU, INPPI1, IDEBEX, IARTIC, IRGPIF
      INTEGER INALPI, INPAGE, IRGPIM, IRPIFN, ILFORC, INBVAL, IPOSEX
      INTEGER IPOSDX, IRECPI, ILSUIV, IPOSUI, IRGPI, IRPIMS, INPILE
      INTEGER IRNGMS, INTRPI, ILTROU, IPTROU, IRPITR, IARTTR, IPOSTR
      INTEGER IRPIMD, IRPIFD, INALDP, IRETOU, INIMES, INUMER, IRANGM
      INTEGER IEXPLO (JPNPIA+JPNPIS+1), INDICE (JPNAPX), KRETIN, IRETIN
C
      LOGICAL LLTSUF, LLTOPT, LLTTRU, LLRCHA
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES DES PARAMETRES D'APPEL ET INITIALISATIONS.
C-----------------------------------------------------------------------
C
      ILCDNO=LEN (CDNOMA)
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI.OR.KLONG.LE.0.OR.
     S    ILCDNO.LE.0.OR.ILCDNO.GT.JPNCPN.OR.CDNOMA.EQ.' ') THEN
        KREP=-16
        GOTO 1001
      ENDIF
C
      IRANG=KRANG
      KREP=0
      LLTSUF=.FALSE.
      LLTOPT=.FALSE.
      KARTEX=0
      KARTEC=0
      KRPIEC=0
      KRPIEX=0
      KLONEX=0
      KLONUT=JPNIL
      IRETOU=0
      ILTSUF=0
      INTTRU=MDES1D(IXM(JPNTRU,IRANG))+NBTROU(IRANG)
      INBALO=MDES1D(IXM(JPNALO,IRANG))
      INBPIR=MDES1D(IXM(JPNPIR,IRANG))
      LLTTRU=INTTRU.EQ.0
      IFACTM=MFACTM(IRANG)
      ILARPH=JPLARD*IFACTM
      INALPP=JPNAPP*IFACTM
      INTPPI=(INBALO-1+INALPP)/INALPP
      IF (LMISOP) PRINT *,
     S        'INBALO= ',INBALO,', INTTRU= ',INTTRU,', INTPPI= ',INTPPI,
     S        ', INBPIR= ',INBPIR
C
      IF (INBALO.EQ.0) GOTO 240
C
      IRNGSU=0
      IRPIFN=1
      INPPIM=NPPIMM(IRANG)
      INPIME=0
      INTROU=0
C
      IF (LPRECH) THEN
        CLNOMA=CDNOMA
        CLBLAN=' '
      ENDIF
C**
C     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
C            A LA RECHERCHE DE L'ARTICLE ET/OU D'UN "TROU" DANS L'INDEX,
C            SUFFISANT POUR Y "CASER" L'ARTICLE. ( ON COMMENCE
C            PAR EXPLORER LES PAGES D'INDEX )
C-----------------------------------------------------------------------
C
      INPPI1=INPPIM
      LLRCHA=.TRUE.
C
      IF (NPODPI(IRANG).EQ.2) THEN
        IDEBEX=3
      ELSE
        IDEBEX=2
      ENDIF
C
      IF (LLTTRU) THEN
C
        CALL LFIRAN (KREP,IRANG,CDNOMA,IRGPIM,IARTIC,IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ELSEIF (IARTIC.NE.0) THEN
C
C         ARTICLE TROUVE.
C
          IRGPIF=MRGPIF(IRGPIM)
          INALPI=MIN0 (INALPP,INBALO-(IRGPIF-1)*INALPP)
C
C         La ligne ci-dessous sert a eviter les ennuis entre les
C         etiquettes 213 et 215.
C
          INPAGE=INTPPI+1
          GOTO 212
        ELSE
C
C         IL VA FALLOIR CREER UN ARTICLE SUPPLEMENTAIRE.
C
          GOTO 240
        ENDIF
C
      ENDIF
C
C     ... DEBUT D'UNE STRUCTURE DE TYPE "BOUCLE" SUR INPAGE,
C         QUI NE PEUT PAS (PLUS) ETRE UNE BOUCLE "DO" A PARTIR DU
C         MOMENT OU ON VEUT UTILISER, DES QUE POSSIBLE, "LFIRAN"
C         POUR UNE RECHERCHE D'ARTICLE MOINS COUTEUSE, SURTOUT LORSQUE
C         L'ARTICLE QUE L'ON CHERCHE ETAIT LE DERNIER TRAITE ...
C
      INPAGE=1
C
  201 CONTINUE
C
      IF (INPAGE.LE.INPPI1) THEN
C
C           IL S'AGIT D'UNE EXPLORATION EN MEMOIRE ( PAGES D'INDEX ) .
C
        IRGPIM=MRGPIM(INPAGE,IRANG)
        IRGPIF=MRGPIF(IRGPIM)
        INPIME=INPIME+1
        IEXPLO(INPIME)=IRGPIF
        IF (IRGPIF.EQ.(IRPIFN+1)) IRPIFN=IRGPIF
      ELSE
C
C           IL S'AGIT D'UNE EXPLORATION "HORS MEMOIRE";
C         ON CHERCHE LA PROCHAINE P.A.I. NON EXPLOREE .
C
        IF (INPAGE.EQ.INPPI1+1) THEN
C
          IF (IRNGSU.EQ.0) THEN
            IRGPIF=IRPIFN
          ELSE
C
C          Cas ou il y a eu, dans la recherche "en memoire",
C        recyclage d'une P.P.I. que l'on avait exploree precedemment.
C          Cette P.P.I. est restee sur place, n'a pas ete exploree,
C        et il serait bete de l'oublier, au risque de la dupliquer...
C
            IRGPIM=MRGPIM(IRNGSU,IRANG)
            IRGPIF=MRGPIF(IRGPIM)
            INPIME=INPIME+1
            IEXPLO(INPIME)=IRGPIF
            IF (IRGPIF.EQ.(IRPIFN+1)) IRPIFN=IRGPIF
            GOTO 210
          ENDIF
C
        ENDIF
C
  202   CONTINUE
        IRGPIF=IRGPIF+1
C
        DO 203 J=IDEBEX,INPIME
        IF (IEXPLO(J).EQ.IRGPIF) GOTO 202
  203   CONTINUE
C
        ILFORC=1
        INPILE=1
        CALL LFIPIM (KREP,IRANG,IRANGM,IRGPIM,IRGPIF,ILFORC,INPILE,
     S               IRETIN)
C
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
C
        INPPIM=MAX0 (INPPIM,IRANGM)
      ENDIF
C*
C     2.1 -  "BOUCLE" DE RECHERCHE SUR LES ARTICLES PRESENTS DANS
C             LA (PAIRE DE) PAGE D'INDEX DE RANG IRGPIF DANS LE FICHIER.
C-----------------------------------------------------------------------
C
  210 CONTINUE
      INALPI=MIN0 (INALPP,INBALO-(IRGPIF-1)*INALPP)
      IARTIC=0
C
      IF (LLRCHA) THEN
C
        IF (LPRECH) THEN
          CALL LFIRAC (CNOMAR(IXC(1,IRGPIM)),INALPI,CLNOMA,INDICE,
     S                 INBVAL)
          IF (INBVAL.NE.0) IARTIC=INDICE(1)
        ELSE
C
          DO 211 J=1,INALPI
C
          IF (CNOMAR(IXC(J,IRGPIM)).EQ.CDNOMA) THEN
            IARTIC=J
            GOTO 212
          ENDIF
C
  211     CONTINUE
C
        ENDIF
C
      ENDIF
C
  212 CONTINUE
C
      IF (IARTIC.NE.0) THEN
C
C        ON A TROUVE DANS LE FICHIER UN ARTICLE DE MEME NOM QUE CELUI A
C        ECRIRE.
C
        LLRCHA=.FALSE.
C
        IF (.NOT.LPHASP(IRGPIM)) THEN
C
          CALL LFIPHA (KREP,IRANG,IRGPIM,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        KRPIEX=IRGPIF
        KLONEX=MLGPOS(IXM(2*IARTIC-1,IRGPIM))
        IPOSEX=MLGPOS(IXM(2*IARTIC,IRGPIM))
        KARTEX=IARTIC
C
        IF (KLONG.LE.KLONEX) THEN
C
C       L'ARTICLE TROUVE EST AU MOINS AUSSI LONG QUE CELUI QUE L'ON VEUT
C       ECRIRE: UNE ECRITURE AU MEME EMPLACEMENT EST DONC POSSIBLE.
C
          KRPIEC=IRGPIF
          KARTEC=IARTIC
          KPOSEC=IPOSEX
          GOTO 240
        ELSE
C
C     CAS DE REECRITURE + LONGUE QUE L'ARTICLE EXISTANT SUR LE FICHIER.
C
          IPOSDX=MLGPOS(IXM(2*IARTIC,IRGPIM))+KLONG-1
C
          IF (IARTIC.EQ.1.AND.IRGPIF.GT.INBPIR) THEN
C
C            IL Y A EU DEBORDEMENT DES P.A.I. PREALLOUEES, ET IL Y A
C        EN OUTRE UNE P.A.I. SUR LE FICHIER, JUSTE DERRIERE L'ARTICLE
C        LOGIQUE AUQUEL ON S'INTERESSE. ON REGARDE S'IL Y A ASSEZ DE
C        PLACE AVANT LA P.A.I. POUR UNE REECRITURE AU MEME ENDROIT.
C        ( P.A.I. = PAIRE D'ARTICLES D'INDEX )
C
            IRECPI=MDES1D(IXM(ILARPH+1-(IRGPIF-INBPIR),IRANG))
            KLONUT=ILARPH*(IRECPI-1)-IPOSEX+1
C
            IF (KLONG.LE.KLONUT) THEN
              KRPIEC=IRGPIF
              KARTEC=IARTIC
              KPOSEC=IPOSEX
              GOTO 240
            ELSE
              GOTO 216
            ENDIF
C
          ELSEIF (IARTIC.EQ.INALPI.AND.IRGPIF.EQ.INTPPI) THEN
C
C           CAS OU L'ARTICLE TROUVE EST LE DERNIER ARTICLE LOGIQUE DE
C        DONNEES, SANS P.A.I. JUSTE DERRIERE. IL Y A DE LA PLACE DONC...
C
            KRPIEC=IRGPIF
            KARTEC=IARTIC
            KPOSEC=IPOSEX
            GOTO 240
          ENDIF
C
        ENDIF
C
C            EN ARRIVANT ICI, ON EST DONC SUR QUE L'ARTICLE TROUVE
C          N'EST PAS LE DERNIER ARTICLE LOGIQUE.
C
C     ON VA REGARDER SI, PAR CHANCE, L'ARTICLE LOGIQUE SUIVANT N'EST
C     PAS UN TROU SUFFISANT POUR "CASER" L'EXCEDENT DE DONNEES,
C     OU S'IL N'Y A PAS UN TROU DE DONNEES ( NON ASSOCIE A UN TROU DANS
C     LA PARTIE "NOMS" DE L'INDEX ) SUFFISANT EN FIN D'ARTICLE EXISTANT,
C     AVANT L'ARTICLE LOGIQUE SUIVANT...
C
        IF (IARTIC.NE.INALPI) THEN
C
C             L'ARTICLE SUIVANT EST DANS LA MEME PAGE D'INDEX...
C
          ILSUIV=MLGPOS(IXM(2*IARTIC+1,IRGPIM))
          IPOSUI=MLGPOS(IXM(2*IARTIC+2,IRGPIM))
          KLONUT=IPOSUI-IPOSEX
C
          IF (KLONG.LE.KLONUT) THEN
C
C     ... ET IL Y A UN "TROU" SUFFISANT AVANT CET ARTICLE POUR POUVOIR
C         ECRIRE LES DONNEES EXCEDENTAIRES.
C
            KRPIEC=IRGPIF
            KARTEC=IARTIC
            KPOSEC=IPOSEX
            GOTO 240
C
          ELSEIF (CNOMAR(IXC(IARTIC+1,IRGPIM)).EQ.' '
     S            .AND.KLONG.LE.(KLONUT+ILSUIV)) THEN
C
C     ... ET C'EST UN TROU QUI PERMET, AVEC L'AIDE EVENTUELLE
C         D'UNE ZONE DE DONNEES "MORTE" ENTRE LES 2 ARTICLES,
C         DE MENAGER UNE PLACE SUFFISANTE POUR L'EXCES DE DONNEES.
C
            MLGPOS(IXM(2*IARTIC+1,IRGPIM))=IPOSUI+ILSUIV-(IPOSDX+1)
            MLGPOS(IXM(2*IARTIC+2,IRGPIM))=IPOSDX+1
            LECRPI(IRGPIM,2)=.TRUE.
            KRPIEC=IRGPIF
            KARTEC=IARTIC
            KPOSEC=IPOSEX
C
            IF (MLGPOS(IXM(2*IARTIC+1,IRGPIM)).EQ.0) THEN
              GOTO 230
            ELSE
              GOTO 240
            ENDIF
C
          ENDIF
C
C     ... L'ARTICLE SUIVANT N'EST PAS EXPLOITABLE POUR ECRIRE L'EXCES
C         DE DONNEES.
C
          GOTO 216
        ELSE
C
C     L'ARTICLE TROUVE EST CERTES TROP COURT, MAIS IL EST EN PLUS EN FIN
C     DE PAGE D'INDEX...
C
          DO 213 J=2,INPPIM
          IRGPI=MRGPIM(J,IRANG)
C
          IF (MRGPIF(IRGPI).EQ.(IRGPIF+1)) THEN
C
            IRPIMS=IRGPI
C
            IF (.NOT.LPHASP(IRPIMS)) THEN
C
              CALL LFIPHA (KREP,IRANG,IRPIMS,IRETIN)
C
              IF (IRETIN.EQ.1) THEN
                GOTO 903
              ELSEIF (IRETIN.EQ.2) THEN
                GOTO 904
              ELSEIF (IRETIN.NE.0) THEN
                GOTO 1001
              ENDIF
C
            ENDIF
C
            GOTO 215
C
          ENDIF
C
  213     CONTINUE
C
C             LA P.A.I. SUIVANTE (EN RANG DANS LE FICHIER) N'EST PAS
C          EN MEMOIRE; DECIDEMENT, CELA SE GATE ! ... ON L'Y MET.
C
C             Noter que ce cas de figure ne peut se presenter q'une
C          seule fois par exploration de l'index.
C
          INPILE=2
          CALL LFIPIM (KREP,IRANG,IRNGMS,IRPIMS,IRGPIF+1,IRGPIF,INPILE,
     S                 IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
          IF (INPAGE.LE.INPPIM) THEN
C
C               On est dans le cadre d'une exploration "en memoire"...
C
            IF (IRNGMS.GT.INPPIM) THEN
C
C               ... et il y aura une P.P.I. a explorer en plus,
C                   a la fin du balayage "en memoire".
C
              INPPI1=INPPI1+1
            ELSEIF (IRNGMS.LT.INPAGE) THEN
C
C               ... et il y aura une P.P.I. a explorer en plus,
C                   mais apres le balayage "en memoire".
C
              IRNGSU=IRNGMS
            ENDIF
C
          ENDIF
C
          INPPIM=MAX0 (INPPIM,IRNGMS)
C
  215     CONTINUE
C
C            LA PAIRE D'ARTICLES D'INDEX SUIVANTE EST EN MEMOIRE.
C
          ILSUIV=MLGPOS(IXM(1,IRPIMS))
          IPOSUI=MLGPOS(IXM(2,IRPIMS))
          KLONUT=IPOSUI-IPOSEX
C
          IF (KLONG.LE.KLONUT) THEN
C
C     ... ET IL Y A UN "TROU" SUFFISANT AVANT CETTE PAIRE POUR POUVOIR
C         ECRIRE LES DONNEES EXCEDENTAIRES.
C
            KRPIEC=IRGPIF
            KARTEC=IARTIC
            KPOSEC=IPOSEX
            GOTO 240
C
          ELSEIF (CNOMAR(IXC(1,IRPIMS)).EQ.' '
     S           .AND.KLONG.LE.(KLONUT+ILSUIV)) THEN
C
C     ... ET C'EST UN TROU QUI PERMET, AVEC L'AIDE EVENTUELLE
C         D'UNE ZONE DE DONNEES "MORTE" ENTRE LES 2 ARTICLES,
C         DE MENAGER UNE PLACE SUFFISANTE POUR L'EXCES DE DONNEES.
C
            MLGPOS(IXM(1,IRPIMS))=IPOSUI+ILSUIV-(IPOSDX+1)
            MLGPOS(IXM(2,IRPIMS))=IPOSDX+1
            LECRPI(IRPIMS,2)=.TRUE.
            KRPIEC=IRGPIF
            KARTEC=IARTIC
            KPOSEC=IPOSEX
C
            IF (MLGPOS(IXM(1,IRPIMS)).EQ.0) THEN
              GOTO 230
            ELSE
              GOTO 240
            ENDIF
C
          ENDIF
C
C              SI ON ARRIVE ICI, IL FAUT PASSER A LA PAGE SUIVANTE .
C
        ENDIF
C
      ENDIF
C
  216 CONTINUE
C
C        RECHERCHE EVENTUELLE DE TROUS D'INDEX DE LONGUEUR ADEQUATE.
C
      IF (LLTTRU.OR.LLTOPT) THEN
C
        IF (.NOT.LLRCHA) THEN
          GOTO 240
        ELSE
          GOTO 229
        ENDIF
C
      ELSEIF (LPRECH) THEN
        CALL LFIRAC (CNOMAR(IXC(1,IRGPIM)),INALPI,CLBLAN,INDICE,INTRPI)
      ELSE
        INTRPI=0
C
        DO 217 J=1,INALPI
C
        IF (CNOMAR(IXC(J,IRGPIM)).EQ.' ') THEN
          INTRPI=INTRPI+1
          INDICE(INTRPI)=J
        ENDIF
C
  217   CONTINUE
C
      ENDIF
C
      IF (INTRPI.NE.0) THEN
C
        IF (.NOT.LPHASP(IRGPIM)) THEN
C
          CALL LFIPHA (KREP,IRANG,IRGPIM,IRETIN)
C
          IF (IRETIN.EQ.1) THEN
            GOTO 903
          ELSEIF (IRETIN.EQ.2) THEN
            GOTO 904
          ELSEIF (IRETIN.NE.0) THEN
            GOTO 1001
          ENDIF
C
        ENDIF
C
        DO 218 J=1,INTRPI
        IARTIC=INDICE(J)
        ILTROU=MLGPOS(IXM(2*IARTIC-1,IRGPIM))
        IPTROU=MLGPOS(IXM(2*IARTIC,IRGPIM))
C
        IF (ILTROU.GE.KLONG) THEN
C
C             "TROU" D'INDEX DE LONGUEUR SUFFISANTE POUR L'ARTICLE.
C
          IF (.NOT.LLTSUF) THEN
            LLTSUF=.TRUE.
            ILTSUF=ILTROU+1
          ENDIF
C
          IF (ILTROU.LT.ILTSUF) THEN
            ILTSUF=ILTROU
            IRPITR=IRGPIF
            IARTTR=IARTIC
            IPOSTR=IPTROU
          ENDIF
C
          LLTOPT=ILTSUF.EQ.KLONG
        ENDIF
C
  218   CONTINUE
C
        INTROU=INTROU+INTRPI
        LLTTRU=INTROU.EQ.INTTRU
      ENDIF
C
C      SI L'ARTICLE A ETE TROUVE PRECEDEMMENT DANS LE FICHIER MAIS TROP
C     COURT, ET SI ON A EXPLORE TOUS LES TROUS REFERENCES DANS L'INDEX,
C     ON ARRETE L'EXPLORATION DE L'INDEX.
C
      IF (LLTTRU.AND.KARTEX.NE.0) GOTO 240
C
C     .... FIN DE "BOUCLE", ON REMONTE POUR UNE EVENTUELLE SUITE ...
C
  229 CONTINUE
      INPAGE=INPAGE+1
C
      IF (INPAGE.LE.INTPPI) THEN
        GOTO 201
      ELSE
        GOTO 240
      ENDIF
C
  230 CONTINUE
C*
C     2.3 - CAS OU L'ON A CREE UN TROU DE LONGUEUR NULLE DANS L'INDEX
C           ON STOCKE DE QUOI S'EN OCCUPER PLUS TARD, A LA FERMETURE.
C-----------------------------------------------------------------------
C
      IF (NTRULZ(IRANG).EQ.0) THEN
        NRFPTZ(IRANG)=IPOSEX
        NRFDTZ(IRANG)=IPOSEX
      ELSE
        NRFPTZ(IRANG)=MIN0 (NRFPTZ(IRANG),IPOSEX)
        NRFDTZ(IRANG)=MAX0 (NRFDTZ(IRANG),IPOSEX)
      ENDIF
C
      NTRULZ(IRANG)=NTRULZ(IRANG)+1
C
  240 CONTINUE
      IF (LMISOP) PRINT *,'LFIREE - APRES ETIQUETTE 240'
C*
C     2.4 - CALCUL DE LA VARIATION DU NOMBRE DE TROUS REFERENCES
C           DANS L'INDEX.
C-----------------------------------------------------------------------
C
      IF (KARTEX.NE.0.AND.KARTEC.EQ.0.AND..NOT.LLTSUF) THEN
        KDTROU=1
      ELSEIF (KARTEX.EQ.0.AND.LLTSUF) THEN
        KDTROU=-1
      ELSE
        KDTROU=0
      ENDIF
C*
C     2.5  -   QUAND AUCUN EMPLACEMENT CONVENABLE N'A ETE TROUVE,
C              IL RESTE A DEFINIR LE RANG DE L'ARTICLE DANS LE FICHIER,
C              AINSI QUE LA POSITION DU PREMIER MOT DE DONNEES A ECRIRE.
C-----------------------------------------------------------------------
C
      IF (KARTEC.EQ.0) THEN
C
        IF (LLTSUF) THEN
          KRPIEC=IRPITR
          KARTEC=IARTTR
          KPOSEC=IPOSTR
        ELSE
          KRPIEC=1+INBALO/INALPP
          KARTEC=INBALO+1-INALPP*(KRPIEC-1)
C
          IF (NALDPI(IRANG).EQ.INALPP
     S        .AND.INTPPI.EQ.(INBPIR+ILARPH-JPLDOC)) THEN
            KREP=-17
            GOTO 1001
          ENDIF
C
C     DEFINITION DE LA POSITION OU ECRIRE, DANS LE CAS D'UN ARTICLE
C     LOGIQUE SUPPLEMENTAIRE.
C
          IF (INBALO.EQ.0) THEN
            KPOSEC=(1+2*INBPIR)*ILARPH+1
          ELSE
            IRPIMD=MRGPIM(NPODPI(IRANG),IRANG)
            INALDP=NALDPI(IRANG)
            KPOSEC=MLGPOS(IXM(2*INALDP,IRPIMD))
     S             +MLGPOS(IXM(2*INALDP-1,IRPIMD))
C
            IF (INTPPI.GT.INBPIR) THEN
              IRPIFD=MDES1D(IXM(ILARPH+1-(INTPPI-INBPIR),IRANG))+1
              KPOSEC=MAX0 (KPOSEC,1+ILARPH*IRPIFD)
            ENDIF
C
          ENDIF
C
        ENDIF
C
      ENDIF
C
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
      KREP=IABS (KREP)
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFIREE'
        WRITE (UNIT=CLMESS,FMT='(''ARGUMENTS='',I4,'','',I2,'','''''',
     S         A,'''''','',I7,'','',I4,'','',I4,'','',I7,'','',I4,'','',
     S         I4,'','',I9,'','',SP,I2,SS,'','',I7,'','',I2)')
     S  KREP,KRANG,CDNOMA,KLONG,KRPIEX,KARTEX,KLONEX,
     S  KRPIEC,KARTEC,KPOSEC,KDTROU,KLONUT,KRETIN
        INUMER=NUMERO(KRANG)
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
      SUBROUTINE LFIVER ( PVEROU, CDSENS )
#include "lficomt.h"
C****
C        CE S/P EST CHARGE, EN MODE MULTI-TASKING, DE TOUTES LES
C        ACTIONS CONCERNANT LES "VERROUS" .
C**
C     ARGUMENTS : PVEROU ==> VERROU CONCERNE;
C                 CDSENS ==> SUFFIXE DE L'ACTION SOUHAITEE.
C                            ('ASGN','ON','OFF','REL')
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      CHARACTER CDSENS*(*)
C
      INTEGER INUMER, IREP, INIMES
C
      REAL PVEROU
C
      IF (CDSENS.EQ.'OFF') THEN
        CALL LOCKOFF (PVEROU)
      ELSEIF (CDSENS.EQ.'ON') THEN
        CALL LOCKON (PVEROU)
      ELSEIF (CDSENS.EQ.'REL') THEN
        CALL LOCKREL (PVEROU)
      ELSEIF (CDSENS.EQ.'ASGN') THEN
        CALL LOCKASGN (PVEROU)
      ELSE
        INUMER=JPNIL
        INIMES=0
        IREP=-3
        LLFATA=NERFAG.NE.2
        CLNSPR='LFIVER'
        CALL LFIEMS (INUMER,INIMES,IREP,LLFATA,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
      END
      SUBROUTINE LFIVID ( KREP, KRANG, KNUMPD, KTAMPO, KRETIN )
#include "lficomt.h"
C****
C        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
C     "VIDAGE" SUR FICHIER D'UNE PAGE DE DONNEES, APRES L'AVOIR DUMENT
C     COMPLETEE SI NECESSAIRE ( AVEC LES DONNEES DEJA PRESENTES SUR
C     FICHIER, OU AVEC DES ZEROS DANS LE CAS DU DERNIER ARTICLE ).
C**
C    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DE L'ECRITURE FORTRAN;
C                KRANG  (ENTREE) ==> RANG EN MEMOIRE DE L'UNITE LOGIQUE;
C                KNUMPD (ENTREE) ==> NUMERO DE LA PAGE DE DONNEES;
C                KTAMPO (ENTREE) ==> ZONE SERVANT A RELIRE L'ARTICLE
C                                    PHYSIQUE CORRESPONDANT SUR FICHIER,
C                                    SI NECESSAIRE. (LONGUEUR: JPLARX)
C                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
C
#include "lficom0.h"
#ifndef f77
#include "precision.h"
#endif
#include "lficom1.h"
C
      INTEGER KREP, KRANG, KNUMPD, KRETIN
#ifndef f77
      INTEGER (KIND=JPDBLE)  KTAMPO (JPLARX)
#else
      INTEGER KTAMPO (JPLARX)
#endif
      INTEGER INUMER, ILONPD, INUMAE, IFACTM, ILARPH, JD, INAPHY, IRETOU
      INTEGER INIMES, IRETIN
C
      LOGICAL LLADON
C
#include "lficom2.h"
C**
C     1.  -  CONTROLES ET INITIALISATIONS.
C-----------------------------------------------------------------------
C
      IF (KRANG.LE.0.OR.KRANG.GT.JPNXFI) THEN
        INUMER=JPNIL
      ELSE
        INUMER=NUMERO(KRANG)
        KREP=0
      ENDIF
C
      IRETOU=0
C
      IF (INUMER.EQ.JPNIL) THEN
        KREP=-14
        GOTO 1001
      ENDIF
C
      ILONPD=NLONPD(KNUMPD,KRANG)
      INUMAE=NUMAPD(KNUMPD,KRANG)
      IFACTM=MFACTM(KRANG)
      ILARPH=JPLARD*IFACTM
C**
C     2.  -  COMPLEMENT EVENTUEL DE LA PAGE DE DONNEES A TRAITER.
C-----------------------------------------------------------------------
C
      IF (ILONPD.NE.ILARPH) THEN
C
C             PAGE DE DONNEES INSUFFISAMMENT REMPLIE.
C
        IF (INUMAE.GT.MDES1D(IXM(JPAXPD,KRANG))) THEN
C*
C     2.1 -  PAS D'ARTICLE PHYSIQUE ASSOCIE SUR FICHIER,
C            ON LA COMPLETE AVEC DES ZEROS.
C-----------------------------------------------------------------------
C
          DO 211 JD=ILONPD+1,ILARPH
          MTAMPD(IXT(JD,KNUMPD,KRANG))=0
  211     CONTINUE
C
        ELSE
C*
C     2.2 -  NECESSITE D'ALLER RELIRE L'ARTICLE PHYSIQUE DE DONNEES
C            SUR FICHIER, ET DE "RECOLLER LES MORCEAUX".
C-----------------------------------------------------------------------
C
          INAPHY=INUMAE
          CALL LFILDO (KREP,INUMER,INUMAE,KTAMPO,NBREAD(KRANG),
     S                 IFACTM,IRETIN)
C
          IF (IRETIN.NE.0) THEN
            GOTO 904
          ENDIF
C
          DO 221 JD=ILONPD+1,ILARPH
          MTAMPD(IXT(JD,KNUMPD,KRANG))=KTAMPO(JD)
  221     CONTINUE
C
        ENDIF
C
      ENDIF
C**
C     3.  -  ECRITURE OU REECRITURE DE LA PAGE DE DONNEES COMPLETE
C            OU COMPLETEE SUR FICHIER.
C-----------------------------------------------------------------------
C
      LLADON=.TRUE.
      INAPHY=0
      CALL LFIECX (KREP,KRANG,INUMAE,MTAMPD(IXT(1,KNUMPD,KRANG)),LLADON,
     S             IRETIN)
C
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
C
      LECRPD(KNUMPD,KRANG)=.FALSE.
      GOTO 1001
C**
C     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
C      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
C-----------------------------------------------------------------------
C
  903 CONTINUE
      IRETOU=1
      CLACTI='WRITE'
      GOTO 909
C
  904 CONTINUE
      IRETOU=2
      CLACTI='READ'
C
  909 CONTINUE
      KREP=IABS (KREP)
      IF (INAPHY.NE.0) NUMAPH(KRANG)=INAPHY
C**
C    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
C            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
C-----------------------------------------------------------------------
C
 1001 CONTINUE
      LLFATA=LLMOER (KREP,KRANG)
C
      IF (KREP.EQ.0) THEN
        KRETIN=0
      ELSEIF (KREP.GT.0) THEN
        KRETIN=IRETOU
      ELSE
        KRETIN=3
      ENDIF
C
      IF (LMISOP.OR.LLFATA) THEN
        INIMES=2
        CLNSPR='LFIVID'
        WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I3,
     S         '', KNUMPD='',I3,'', KRETIN='',I2)')
     S     KREP,KRANG,KNUMPD,KRETIN
        CALL LFIEMS (INUMER,INIMES,KREP,.FALSE.,CLMESS,CLNSPR,CLACTI)
      ENDIF
C
      RETURN
C
      END
