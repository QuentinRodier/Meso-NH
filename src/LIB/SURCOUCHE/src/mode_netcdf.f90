!MNH_LIC Copyright 1994-2016 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
!  Modifications:
!    P. Wautelet : may 2016: use NetCDF Fortran module
!-----------------------------------------------------------------
!-----------------------------------------------------------------
#if defined(MNH_IOCDF4)
MODULE MODE_NETCDF
USE MODD_NETCDF
USE NETCDF
USE MODD_IO_ll
USE MODE_FIELD, ONLY : TFIELDDATA
USE MODE_MSG

IMPLICIT NONE 

PRIVATE

INTEGER(KIND=IDCDF_KIND),PARAMETER :: SHUFFLE = 1 !Set to 1 for (usually) better compression
INTEGER(KIND=IDCDF_KIND),PARAMETER :: DEFLATE = 1

INTERFACE IO_WRITE_FIELD_NC4
   MODULE PROCEDURE IO_WRITE_FIELD_NC4_X0,IO_WRITE_FIELD_NC4_X1, &
                    IO_WRITE_FIELD_NC4_X2,IO_WRITE_FIELD_NC4_X3, &
                    IO_WRITE_FIELD_NC4_X4,IO_WRITE_FIELD_NC4_X5, &
                    IO_WRITE_FIELD_NC4_X6,                       &
                    IO_WRITE_FIELD_NC4_N0,IO_WRITE_FIELD_NC4_N1, &
                    IO_WRITE_FIELD_NC4_L0,IO_WRITE_FIELD_NC4_L1, &
                    IO_WRITE_FIELD_NC4_N2,IO_WRITE_FIELD_NC4_N3, &
                    IO_WRITE_FIELD_NC4_C0,IO_WRITE_FIELD_NC4_C1, &
                    IO_WRITE_FIELD_NC4_T0
END INTERFACE IO_WRITE_FIELD_NC4

INTERFACE IO_READ_FIELD_NC4
   MODULE PROCEDURE IO_READ_FIELD_NC4_X0,IO_READ_FIELD_NC4_X1, &
                    IO_READ_FIELD_NC4_X2,IO_READ_FIELD_NC4_X3, &
                    IO_READ_FIELD_NC4_X4,IO_READ_FIELD_NC4_X5, &
                    IO_READ_FIELD_NC4_X6,                      &
                    IO_READ_FIELD_NC4_N0,IO_READ_FIELD_NC4_N1, &
                    IO_READ_FIELD_NC4_N2,                      &
                    IO_READ_FIELD_NC4_L0,IO_READ_FIELD_NC4_L1, &
                    IO_READ_FIELD_NC4_C0,                      &
                    IO_READ_FIELD_NC4_T0
END INTERFACE IO_READ_FIELD_NC4

! Public from module netcdf
PUBLIC NF90_OPEN,NF90_CREATE,NF90_NOWRITE,NF90_CLOBBER,NF90_NETCDF4,NF90_NOERR,NF90_STRERROR
! Public from this module :
PUBLIC NEWIOCDF,CLEANIOCDF,IO_WRITE_FIELD_NC4,IO_READ_FIELD_NC4,IO_WRITE_HEADER_NC4

CONTAINS

SUBROUTINE CLEANMNHNAME(HINNAME,HOUTNAME)
  CHARACTER(LEN=*),INTENT(IN)  :: HINNAME
  CHARACTER(LEN=*),INTENT(OUT) :: HOUTNAME

  ! NetCDF var names can't contain '%' nor '.'
  ! CF convention allows only letters, digits and underscores
  HOUTNAME = str_replace(HINNAME,  '%', '__')
  HOUTNAME = str_replace(HOUTNAME, '.', '___')
END SUBROUTINE

FUNCTION NEWIOCDF()
TYPE(IOCDF), POINTER :: NEWIOCDF
TYPE(IOCDF), POINTER :: TZIOCDF
INTEGER              :: IRESP

ALLOCATE(TZIOCDF, STAT=IRESP)
IF (IRESP > 0) THEN 
  PRINT *, 'NEWIOCDF : memory allocation error...'
  STOP
END IF

TZIOCDF%NCID = -1
NULLIFY(TZIOCDF%DIMX)
NULLIFY(TZIOCDF%DIMY)
NULLIFY(TZIOCDF%DIMZ)
NULLIFY(TZIOCDF%DIMSTR)
NULLIFY(TZIOCDF%DIMLIST)

NEWIOCDF=>TZIOCDF

END FUNCTION NEWIOCDF

SUBROUTINE CLEANIOCDF(PIOCDF)
TYPE(IOCDF),  POINTER :: PIOCDF

INTEGER(KIND=IDCDF_KIND) :: IRESP

! Close Netcdf File
IRESP = NF90_CLOSE(PIOCDF%NCID)
IF (IRESP /= NF90_NOERR) THEN
   PRINT *, 'CLEANIOCDF, NF90_CLOSE error : ', NF90_STRERROR(IRESP)
END IF

! Clean DIMLIST and DIMSTR
CALL CLEANLIST(PIOCDF%DIMLIST)
CALL CLEANLIST(PIOCDF%DIMSTR)
! Then free iocdf
DEALLOCATE(PIOCDF)

PRINT *, 'CLEANIOCDF done.'

CONTAINS

SUBROUTINE CLEANLIST(PLIST)
TYPE(DIMCDF), POINTER :: PLIST,TZDIMCUR, TZDIMNEXT    

TZDIMCUR  => PLIST
DO WHILE(ASSOCIATED(TZDIMCUR))
   TZDIMNEXT => TZDIMCUR%NEXT
   DEALLOCATE(TZDIMCUR)
   TZDIMCUR => TZDIMNEXT
END DO

END SUBROUTINE CLEANLIST
  
END SUBROUTINE CLEANIOCDF

SUBROUTINE HANDLE_ERR(status,line,text,kresp)
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: status
INTEGER, INTENT(IN) :: line
CHARACTER(LEN=*), INTENT(IN) :: text
INTEGER, OPTIONAL, INTENT(OUT) :: kresp

! Don't stop the code when kresp is present
! and ensure kresp is a negative integer
IF (status /= NF90_NOERR) THEN
   PRINT *, 'NETCDF ERROR in '//TRIM(text), line, NF90_STRERROR(status)
   IF (PRESENT(kresp)) THEN
      IF (status < 0) THEN
         kresp = status
      ELSE IF (status == 0) THEN
         kresp = -1
      ELSE
         kresp = -status
      END IF
   ELSE
      STOP
   END IF
END IF
END SUBROUTINE HANDLE_ERR

FUNCTION str_replace(hstr, hold, hnew)
CHARACTER(LEN=*) :: hstr, hold, hnew
CHARACTER(LEN=LEN_TRIM(hstr)+MAX(0,LEN(hnew)-LEN(hold))) :: str_replace

INTEGER :: pos

pos = INDEX(hstr,hold)
IF (pos /= 0) THEN
   str_replace = hstr(1:pos-1)//hnew//hstr(pos+LEN(hold):)
ELSE 
   str_replace = hstr 
END IF

END FUNCTION str_replace

SUBROUTINE IO_WRITE_HEADER_NC4(TPFILE)
!
USE MODD_IO_ll, ONLY: ISP,TFILEDATA
!
USE MODE_FD_ll
!
TYPE(TFILEDATA), INTENT(IN)  :: TPFILE ! File structure
!
INTEGER(KIND=IDCDF_KIND) :: ISTATUS
TYPE(FD_ll), POINTER         :: TZFD
!
IF (TRIM(TPFILE%CFORMAT)/='NETCDF4' .AND. TRIM(TPFILE%CFORMAT)/='LFICDF4') RETURN
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_HEADER_NC4','called for file '//TRIM(TPFILE%CNAME))
!
TZFD=>GETFD(TRIM(ADJUSTL(TPFILE%CNAME))//'.lfi')
!
IF (ISP == TZFD%OWNER)  THEN
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'Conventions', 'CF-1.6')
  IF (ISTATUS /= NF90_NOERR) CALL HANDLE_ERR(ISTATUS,__LINE__,'IO_FILE_WRITE_HEADER[NF90_PUT_ATT]')

!title

!history

!institution

!source

!comment

!references
END IF
!
END SUBROUTINE IO_WRITE_HEADER_NC4


SUBROUTINE IO_WRITE_FIELD_ATTR_NC4(TPFIELD,KNCID,KVARID,HCALENDAR)
!
TYPE(TFIELDDATA),         INTENT(IN) :: TPFIELD
INTEGER(KIND=IDCDF_KIND), INTENT(IN) :: KNCID
INTEGER(KIND=IDCDF_KIND), INTENT(IN) :: KVARID
CHARACTER(LEN=*),OPTIONAL,INTENT(IN) :: HCALENDAR
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','called for field '//TRIM(TPFIELD%CMNHNAME))
!
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0 .AND. LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_ATTR_NC4','at least long_name or standard_name must be provided &
  &to respect CF-convention for variable '//TRIM(TPFIELD%CMNHNAME))
ENDIF
!
! GRID attribute definition
IF(TPFIELD%NGRID<0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%NGRID not set for variable '//TRIM(TPFIELD%CMNHNAME))
!Do not write GRID attribute if NGRID=0
  ELSE IF (TPFIELD%NGRID>0) THEN
  STATUS = NF90_PUT_ATT(KNCID, KVARID, 'GRID', TPFIELD%NGRID)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! COMMENT attribute definition
IF(LEN_TRIM(TPFIELD%CCOMMENT)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CCOMMENT not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'COMMENT', TRIM(TPFIELD%CCOMMENT))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Standard_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CSTDNAME not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'standard_name', TRIM(TPFIELD%CSTDNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Long_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CLONGNAME not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'long_name', TRIM(TPFIELD%CLONGNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Canonical units attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CUNITS)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CUNITS not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'units', TRIM(TPFIELD%CUNITS))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Calendar (CF convention)
IF(PRESENT(HCALENDAR)) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','CALENDAR provided for variable '//TRIM(TPFIELD%CMNHNAME))
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'calendar', TRIM(HCALENDAR))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
END SUBROUTINE IO_WRITE_FIELD_ATTR_NC4

FUNCTION GETDIMCDF(PIOCDF, KLEN, HDIMNAME)
TYPE(IOCDF), POINTER       :: PIOCDF
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
CHARACTER(LEN=*), OPTIONAL :: HDIMNAME ! When provided don't search but
                                       ! simply create with name HDIMNAME
TYPE(DIMCDF), POINTER   :: GETDIMCDF

TYPE(DIMCDF), POINTER :: TMP
INTEGER               :: COUNT
CHARACTER(LEN=7)      :: YSUFFIX
CHARACTER(LEN=8)      :: YDIMNAME
INTEGER(KIND=IDCDF_KIND) :: STATUS

IF (KLEN < 1) THEN
   PRINT *, 'GETDIMCDF Error, KLEN=', KLEN
   STOP
END IF

IF (PRESENT(HDIMNAME)) THEN
   NULLIFY(TMP)
   YDIMNAME = TRIM(HDIMNAME)
ELSE
   ! Search dimension with KLEN length
   COUNT = 1
   TMP  => PIOCDF%DIMLIST
   DO WHILE(ASSOCIATED(TMP))
      IF (TMP%LEN == KLEN .AND. TMP%NAME /= 'STRLEN') EXIT
      TMP=>TMP%NEXT
      COUNT = COUNT+1
   END DO
   WRITE(YSUFFIX,'(i7)') KLEN
   YDIMNAME = 'D'//ADJUSTL(YSUFFIX)
END IF

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = YDIMNAME
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(PIOCDF%NCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETDIMCDF[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT       => PIOCDF%DIMLIST
   PIOCDF%DIMLIST => TMP
END IF

GETDIMCDF => TMP

END FUNCTION GETDIMCDF

FUNCTION GETSTRDIMID(PIOCDF, KLEN)
TYPE(IOCDF), POINTER    :: PIOCDF
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
INTEGER(KIND=IDCDF_KIND)            :: GETSTRDIMID

TYPE(DIMCDF), POINTER :: TMP
CHARACTER(LEN=7)      :: YSUFFIX
CHARACTER(LEN=8)      :: YDIMNAME
INTEGER(KIND=IDCDF_KIND) :: STATUS

IF (KLEN < 1) THEN
   PRINT *, 'GETSTRDIMID Error, KLEN=', KLEN
   STOP
END IF

! Search string dimension with KLEN length
TMP  => PIOCDF%DIMSTR
DO WHILE(ASSOCIATED(TMP))
   IF (TMP%LEN == KLEN) EXIT
   TMP=>TMP%NEXT
END DO
WRITE(YSUFFIX,'(i7)') KLEN
YDIMNAME = 'S'//ADJUSTL(YSUFFIX)

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = YDIMNAME
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(PIOCDF%NCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETSTRDIMID[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT      => PIOCDF%DIMSTR
   PIOCDF%DIMSTR => TMP
END IF

GETSTRDIMID = TMP%ID

END FUNCTION GETSTRDIMID

SUBROUTINE FILLVDIMS(PIOCDF, KSHAPE, HDIR, KVDIMS)
TYPE(IOCDF),           POINTER        :: PIOCDF 
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), INTENT(IN) :: KSHAPE
CHARACTER(LEN=*),      INTENT(IN)     :: HDIR
INTEGER(KIND=IDCDF_KIND),DIMENSION(:), INTENT(OUT) :: KVDIMS

INTEGER :: II
TYPE(DIMCDF), POINTER :: PTDIM

IF (SIZE(KSHAPE) < 1) THEN
   PRINT *, 'FILLVDIMS Error, KSHAPE empty'
   STOP
END IF

DO II=1, SIZE(KSHAPE)

   IF (II == 1) THEN
      IF (HDIR == 'XX' .OR. HDIR == 'XY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMX))  PIOCDF%DIMX => GETDIMCDF(PIOCDF, KSHAPE(II), 'X')
         IF (KSHAPE(II) == PIOCDF%DIMX%LEN) THEN
            PTDIM => PIOCDF%DIMX
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE IF (HDIR == 'YY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMY))  PIOCDF%DIMY => GETDIMCDF(PIOCDF, KSHAPE(II), 'Y')
         IF (KSHAPE(II) == PIOCDF%DIMY%LEN) THEN
            PTDIM => PIOCDF%DIMY
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE
         PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         KVDIMS(II) = PTDIM%ID
      END IF
   ELSE IF (II == 2) THEN
      IF (HDIR == 'XY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMY))  PIOCDF%DIMY => GETDIMCDF(PIOCDF, KSHAPE(II), 'Y')
         IF (KSHAPE(II) == PIOCDF%DIMY%LEN) THEN
            PTDIM => PIOCDF%DIMY
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE
         PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
      END IF
   ELSE IF (II == 3) THEN
      IF (HDIR == 'XY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMZ))  PIOCDF%DIMZ => GETDIMCDF(PIOCDF, KSHAPE(II), 'Z')
         IF (KSHAPE(II) == PIOCDF%DIMZ%LEN) THEN
            PTDIM => PIOCDF%DIMZ
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE
         PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
      END IF
   ELSE
      PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
   END IF
   
   KVDIMS(II) = PTDIM%ID
      
END DO

END SUBROUTINE FILLVDIMS


SUBROUTINE IO_WRITE_FIELD_NC4_X0(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
REAL,                  INTENT(IN) :: PFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X0


SUBROUTINE IO_WRITE_FIELD_NC4_X1(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
REAL,DIMENSION(:),     INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X1


SUBROUTINE IO_WRITE_FIELD_NC4_X2(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP,KVERTLEVEL,KZFILE)
!
USE MODE_IO_MANAGE_STRUCT, ONLY: IO_FILE_FIND_BYNAME
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
REAL,DIMENSION(:,:),   INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
INTEGER,OPTIONAL,      INTENT(IN) :: KVERTLEVEL ! Number of the vertical level (needed for Z-level splitted files)
INTEGER,OPTIONAL,      INTENT(IN) :: KZFILE     ! Number of the Z-level splitted file
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=4)         :: YSUFFIX
CHARACTER(LEN=3)         :: YNUMBER
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4) :: YTMP,YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
TYPE(TFILEDATA),POINTER  :: TZFILE
!
IRESP = 0

IF (PRESENT(KVERTLEVEL)) THEN
  WRITE(YSUFFIX,'(I4.4)') KVERTLEVEL
  IF (.NOT.PRESENT(KZFILE)) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_WRITE_FIELD_NC4_X2','KZFILE argument not provided')
    RETURN
  END IF
  WRITE(YNUMBER,'(I3.3)') KZFILE
  YTMP = TRIM(TPFIELD%CMNHNAME)//YSUFFIX
!PW: TODO: try to not do a find (for better perf)
  CALL IO_FILE_FIND_BYNAME(TRIM(TPFILE%CNAME)//'.Z'//YNUMBER,TZFILE,IRESP)
  IF (IRESP/=0) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_WRITE_FIELD_NC4_X2','file '//TRIM(TRIM(TPFILE%CNAME)//'.Z'//YNUMBER)//' not found in list')
    RETURN
  END IF
ELSE
  YTMP = TRIM(TPFIELD%CMNHNAME)
  TZFILE => TPFILE
ENDIF
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': writing '//TRIM(YTMP))
!
! Get the Netcdf file ID
INCID = TZFILE%NNCID

CALL CLEANMNHNAME(YTMP,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X2','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TZFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TZFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TZFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X2


SUBROUTINE IO_WRITE_FIELD_NC4_X3(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
REAL,DIMENSION(:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X3','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X3


SUBROUTINE IO_WRITE_FIELD_NC4_X4(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
TYPE(TFILEDATA),           INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),          INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER                  :: PZCDF
REAL,DIMENSION(:,:,:,:),   INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                   INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X4','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X4


SUBROUTINE IO_WRITE_FIELD_NC4_X5(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
TYPE(TFILEDATA),           INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),          INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER                  :: PZCDF
REAL,DIMENSION(:,:,:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                   INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X5','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X5


SUBROUTINE IO_WRITE_FIELD_NC4_X6(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
TYPE(TFILEDATA),             INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),            INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER                    :: PZCDF
REAL,DIMENSION(:,:,:,:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                     INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X6','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X6


SUBROUTINE IO_WRITE_FIELD_NC4_N0(TPFILE,TPFIELD,PZCDF,KFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
#if 0
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
#endif
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
INTEGER,               INTENT(IN) :: KFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

!
! Use IMAX, JMAX, KMAX to define DIMX, DIMY, DIMZ
! /!\ Can only work if IMAX, JMAX or KMAX are written before any array
!
#if 0
IF (YVARNAME == 'IMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMX)) PZCDF%DIMX=>GETDIMCDF(PZCDF,KFIELD+2*JPHEXT,'X')
IF (YVARNAME == 'JMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMY)) THEN
   IF (LPACK .AND. L2D) THEN
      PZCDF%DIMY=>GETDIMCDF(PZCDF, 1,'Y')
   ELSE
      PZCDF%DIMY=>GETDIMCDF(PZCDF, KFIELD+2*JPHEXT, 'Y')
   END IF
END IF
#endif
IF (YVARNAME == 'KMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMZ)) PZCDF%DIMZ=>GETDIMCDF(PZCDF,INT(KFIELD+2*JPVEXT,KIND=IDCDF_KIND),'Z')
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N0


SUBROUTINE IO_WRITE_FIELD_NC4_N1(TPFILE,TPFIELD,PZCDF,KFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
#if 0
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
#endif
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
INTEGER, DIMENSION(:), INTENT(IN) :: KFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N1[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N1


SUBROUTINE IO_WRITE_FIELD_NC4_N2(TPFILE,TPFIELD,PZCDF,KFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
INTEGER,DIMENSION(:,:),INTENT(IN) :: KFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
IRESP = 0
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N2','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N2

SUBROUTINE IO_WRITE_FIELD_NC4_N3(TPFILE,TPFIELD,PZCDF,KFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,  INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER                :: PZCDF
INTEGER,DIMENSION(:,:,:),INTENT(IN) :: KFIELD   ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
IRESP = 0
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N3',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N3','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N3

SUBROUTINE IO_WRITE_FIELD_NC4_L0(TPFILE,TPFIELD,PZCDF,OFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
LOGICAL,               INTENT(IN) :: OFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER                  :: IFIELD
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   ! Use of NF90_INT1 datatype (=NF90_BYTE) that is enough to store a boolean
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT1, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

!Convert LOGICAL to INTEGER (LOGICAL format not supported by netCDF files)
IF (OFIELD) THEN
  IFIELD = 1
ELSE
  IFIELD = 0
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, IFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_L0

SUBROUTINE IO_WRITE_FIELD_NC4_L1(TPFILE,TPFIELD,PZCDF,OFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
LOGICAL, DIMENSION(:), INTENT(IN) :: OFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER, DIMENSION(SIZE(OFIELD))                         :: IFIELD
INTEGER(KIND=IDCDF_KIND)                                 :: STATUS
INTEGER(KIND=IDCDF_KIND)                                 :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))                     :: YVARNAME
INTEGER(KIND=IDCDF_KIND)                                 :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(OFIELD))) :: IVDIMS
INTEGER                                                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(OFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_L1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(OFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   ! Use of NF90_INT1 datatype (=NF90_BYTE) that is enough to store a boolean
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT1, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L1[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

!Convert LOGICAL to INTEGER (LOGICAL format not supported by netCDF files)
WHERE (OFIELD)
  IFIELD = 1
ELSEWHERE
  IFIELD = 0
END WHERE

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, IFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_L1


SUBROUTINE IO_WRITE_FIELD_NC4_C0(TPFILE,TPFIELD,PZCDF,HFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
CHARACTER(LEN=*),      INTENT(IN) :: HFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER,PARAMETER :: IMULT = 16
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
INTEGER                                :: IRESP, ILEN
CHARACTER(LEN=:),ALLOCATABLE           :: YFIELD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0

!Store the character string in a string of a size multiple of IMULT
!This is done to limit the number of dimensions in the netCDF file
ILEN = ((LEN_TRIM(HFIELD)+IMULT-1)/IMULT)*IMULT
!If the string is empty, create it anyway with a non-zero size (to prevent problems later)
IF (ILEN==0) ILEN = IMULT

! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(PZCDF,INT(ILEN,KIND=IDCDF_KIND))
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

ALLOCATE(CHARACTER(LEN=ILEN)::YFIELD)
YFIELD(:)=TRIM(HFIELD) !Warning: keep (:) to prevent F2003 automatic reallocation
YFIELD(LEN_TRIM(HFIELD)+1:)=' '
! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, YFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
DEALLOCATE(YFIELD)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_C0

SUBROUTINE IO_WRITE_FIELD_NC4_C1(TPFILE,TPFIELD,PZCDF,HFIELD,KRESP)
!
TYPE(TFILEDATA),              INTENT(IN)  :: TPFILE
TYPE(TFIELDDATA),             INTENT(IN)  :: TPFIELD
TYPE(IOCDF), POINTER                      :: PZCDF
CHARACTER(LEN=*),DIMENSION(:),INTENT(IN)  :: HFIELD
INTEGER,                      INTENT(OUT) :: KRESP
!
INTEGER(KIND=IDCDF_KIND),PARAMETER :: IONE = 1
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(2) :: IVDIMS
INTEGER(KIND=IDCDF_KIND)               :: ILEN, ISIZE
INTEGER                                :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_C1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0

ILEN  = LEN(HFIELD)
ISIZE = SIZE(HFIELD)

! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(PZCDF,ILEN)
   CALL FILLVDIMS(PZCDF, (/ISIZE/), TPFIELD%CDIR, IVDIMS(2:2))
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C1[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_C1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, HFIELD(1:ISIZE)(1:ILEN), START=(/IONE,IONE/), COUNT=(/ILEN,ISIZE/))
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_C1


SUBROUTINE IO_WRITE_FIELD_NC4_T0(TPFILE,TPFIELD,PZCDF,TPDATA,KRESP)
!
USE MODD_TYPE_DATE
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
TYPE (DATE_TIME),      INTENT(IN) :: TPDATA
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
INTEGER                                :: IRESP
INTEGER, DIMENSION(3)                  :: ITDATE    ! date array
TYPE(TFIELDDATA)                       :: TZFIELD
CHARACTER(LEN=40)                      :: YUNITS
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
!
TZFIELD = TPFIELD
!
ITDATE(1)=TPDATA%TDATE%YEAR
ITDATE(2)=TPDATA%TDATE%MONTH
ITDATE(3)=TPDATA%TDATE%DAY
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
TZFIELD%CMNHNAME = TRIM(YVARNAME)
WRITE(YUNITS,'( "seconds since ",I4.4,"-",I2.2,"-",I2.2," 00:00:00 +0:00" )') ITDATE(1),ITDATE(2),ITDATE(3)
TZFIELD%CUNITS = TRIM(YUNITS)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TZFIELD,INCID,IVARID,HCALENDAR='standard')
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, TPDATA%TIME)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF (IRESP/=0) THEN
  KRESP = IRESP
  RETURN
END IF

#if 1
!This part is to keep backward compatibility with MesoNH files
!but date/time is not conform to CF convention
!
! Write date
!
TZFIELD%CMNHNAME  = TRIM(YVARNAME)//'__TDATE'
TZFIELD%CLONGNAME = TRIM(TPFIELD%CLONGNAME)//'%TDATE'
TZFIELD%CUNITS    = ''
TZFIELD%CCOMMENT  = 'YYYYMMDD'

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, TZFIELD%CMNHNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(ITDATE),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, TZFIELD%CMNHNAME, NF90_INT, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TZFIELD,INCID,IVARID)
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(TZFIELD%CMNHNAME)//' already defined')
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, ITDATE)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_PUT_VAR] '//TRIM(TZFIELD%CMNHNAME),IRESP)
 
IF (IRESP/=0) THEN
  KRESP = IRESP
  RETURN
END IF
!
! Write time
!
TZFIELD%CMNHNAME  = TRIM(YVARNAME)//'__TIME'
TZFIELD%CLONGNAME = TRIM(TPFIELD%CLONGNAME)//'%TIME'
TZFIELD%CUNITS    = 's'
TZFIELD%CCOMMENT  = 'SECONDS'

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, TZFIELD%CMNHNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, TZFIELD%CMNHNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TZFIELD,INCID,IVARID)
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(TZFIELD%CMNHNAME)//' already defined')
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, TPDATA%TIME)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_PUT_VAR] '//TRIM(TZFIELD%CMNHNAME),IRESP)
#endif

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_T0
!
!
! Here come the NetCDF READ routines
!
!
SUBROUTINE IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,KNCID,KVARID,KRESP,HCALENDAR)
!
TYPE(TFIELDDATA),         INTENT(INOUT) :: TPFIELD
INTEGER(KIND=IDCDF_KIND), INTENT(IN)    :: KNCID
INTEGER(KIND=IDCDF_KIND), INTENT(IN)    :: KVARID
INTEGER,                  INTENT(OUT)   :: KRESP  ! return-code
CHARACTER(LEN=*),OPTIONAL,INTENT(IN)    :: HCALENDAR
!
INTEGER                      :: ILEN
INTEGER                      :: IGRID
INTEGER(KIND=IDCDF_KIND)     :: STATUS
CHARACTER(LEN=12)            :: YVAL_FILE, YVAL_MEM
CHARACTER(LEN=:),ALLOCATABLE :: YVALUE
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','called for field '//TRIM(TPFIELD%CMNHNAME))
!
KRESP = 0
!
! GRID
!
STATUS = NF90_GET_ATT(KNCID,KVARID,'GRID',IGRID)
IF (STATUS == NF90_NOERR) THEN
  IF (IGRID/=TPFIELD%NGRID) THEN
    WRITE(YVAL_FILE,'(I12)') IGRID
    WRITE(YVAL_MEM, '(I12)') TPFIELD%NGRID
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected GRID     value ('//TRIM(ADJUSTL(YVAL_MEM))// &
                   ') is different than found in file ('//TRIM(ADJUSTL(YVAL_FILE))//') for variable '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%NGRID = IGRID
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected GRID found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ENDIF
ELSE !no GRID
  IF (TPFIELD%NGRID==0 .OR. TPFIELD%NGRID==-1) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no GRID (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected GRID but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
ENDIF
!
! COMMENT
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'COMMENT', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'COMMENT', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CCOMMENT)) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected COMMENT ('//TRIM(TPFIELD%CCOMMENT)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CCOMMENT=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected COMMENT  found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no COMMENT
  IF (LEN_TRIM(TPFIELD%CCOMMENT)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no COMMENT (as expected) in file for field ' &
                                                                //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected COMMENT but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! STDNAME
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'standard_name', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'standard_name', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CSTDNAME)) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected STDNAME  ('//TRIM(TPFIELD%CSTDNAME)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CSTDNAME=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected STDNAME  found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no STDNAME
  IF (LEN_TRIM(TPFIELD%CSTDNAME)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no STDNAME (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected STDNAME but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! LONGNAME
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'long_name', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'long_name', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CLONGNAME)) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected LONGNAME ('//TRIM(TPFIELD%CLONGNAME)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CLONGNAME=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected LONGNAME found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no LONGNAME
  IF (LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no LONGNAME (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected LONGNAME but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! UNITS
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'units', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'units', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CUNITS)) THEN
    IF(.NOT.PRESENT(HCALENDAR)) THEN
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS ('//TRIM(TPFIELD%CUNITS)// &
                     ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
      KRESP = -111 !Used later to broadcast modified metadata
    ELSE
      CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','UNITS found in file for field ' &
                                                                     //TRIM(TPFIELD%CMNHNAME)//' (will be analysed later)')
    END IF
    TPFIELD%CUNITS=TRIM(YVALUE)
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS    found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no UNITS
  IF (LEN_TRIM(TPFIELD%CUNITS)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no UNITS (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    IF(.NOT.PRESENT(HCALENDAR)) THEN
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS but not found in file for field ' &
                                                                       //TRIM(TPFIELD%CMNHNAME))
    ELSE
      CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS but not found in file for field ' &
                                                                     //TRIM(TPFIELD%CMNHNAME))
      KRESP = -3
    END IF
  END IF
END IF
!
! CALENDAR
!
IF(PRESENT(HCALENDAR)) THEN
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'calendar', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'calendar', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(HCALENDAR)) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected CALENDAR ('//TRIM(HCALENDAR)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected CALENDAR found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no CALENDAR
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected CALENDAR but not found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
END IF
ENDIF
!
END SUBROUTINE IO_READ_CHECK_FIELD_ATTR_NC4


SUBROUTINE IO_READ_FIELD_NC4_X0(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,             INTENT(OUT)   :: PFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 0 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Read variable
  STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF
  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong size or type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X0


SUBROUTINE IO_READ_FIELD_NC4_X1(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:),INTENT(OUT)   :: PFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 1 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(PFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X1


SUBROUTINE IO_READ_FIELD_NC4_X2(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),    INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),   INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:),INTENT(OUT)   :: PFIELD
INTEGER,            INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND),DIMENSION(3) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Treat special case of a degenerated 3D array (3rd dimension size is 1)
IF (IDIMS==3) THEN
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  IF (IDIMLEN(3)==1) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)// &
                   ': reading 3D array with degenerated third dimension in 2D array for '//TRIM(YVARNAME))
    IDIMS = 2
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': wrong number of dimensions for '//TRIM(YVARNAME))
  END IF
END IF

IF (IDIMS == 2 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X2


SUBROUTINE IO_READ_FIELD_NC4_X3(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),      INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),     INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,              INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(3)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 3 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. IDIMLEN(3) == SIZE(PFIELD,3)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X3


SUBROUTINE IO_READ_FIELD_NC4_X4(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),        INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),       INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(4)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 4 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X4


SUBROUTINE IO_READ_FIELD_NC4_X5(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),          INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),         INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                  INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(5)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 5 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(5), LEN=IDIMLEN(5))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4) .AND. &
       IDIMLEN(5) == SIZE(PFIELD,5) ) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X5


SUBROUTINE IO_READ_FIELD_NC4_X6(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),            INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),           INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                    INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(6)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 6 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(5), LEN=IDIMLEN(5))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(6), LEN=IDIMLEN(6))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4) .AND. &
       IDIMLEN(5) == SIZE(PFIELD,5) .AND. IDIMLEN(6) == SIZE(PFIELD,6) ) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X6


SUBROUTINE IO_READ_FIELD_NC4_N0(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
INTEGER,          INTENT(OUT)   :: KFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

#ifndef MNH_INT8
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT) ) THEN
#else
!Can read either 4 or 8 byte integers
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT) ) THEN
#endif
   ! Read variable
   STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
   IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
   END IF
   ! Read and check attributes of variable
   CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N0


SUBROUTINE IO_READ_FIELD_NC4_N1(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),         INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),        INTENT(INOUT) :: TPFIELD
INTEGER, DIMENSION(:),   INTENT(OUT)   :: KFIELD
INTEGER,                 INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!NF90_INT1 is for the case a boolean was written
#ifndef MNH_INT8
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT .OR. ITYPE == NF90_INT1) ) THEN
#else
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT1) ) THEN
#endif
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(KFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N1


SUBROUTINE IO_READ_FIELD_NC4_N2(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),         INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),        INTENT(INOUT) :: TPFIELD
INTEGER, DIMENSION(:,:), INTENT(OUT)   :: KFIELD
INTEGER,                 INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND),DIMENSION(3) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Treat special case of a degenerated 3D array (3rd dimension size is 1)
IF (IDIMS==3) THEN
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  IF (IDIMLEN(3)==1) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)// &
                   ': reading 3D array with degenerated third dimension in 2D array for '//TRIM(YVARNAME))
    IDIMS = 2
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': wrong number of dimensions for '//TRIM(YVARNAME))
  END IF
END IF

!NF90_INT1 is for the case a boolean was written
#ifndef MNH_INT8
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. (ITYPE == NF90_INT .OR. ITYPE == NF90_INT1) ) THEN
#else
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. (ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT1) ) THEN
#endif
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(KFIELD,1) .AND. IDIMLEN(2) == SIZE(KFIELD,2)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N2

SUBROUTINE IO_READ_FIELD_NC4_L0(TPFILE, TPFIELD, OFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
LOGICAL,          INTENT(OUT)   :: OFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP
INTEGER                  :: IFIELD

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!NF90_INT1 is for the case a boolean was written
!Accept also INT and INT64 (for backward compatibility)
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT1 .OR. ITYPE == NF90_INT .OR. ITYPE == NF90_INT64)  ) THEN
  ! Read variable
  STATUS = NF90_GET_VAR(INCID, IVARID, IFIELD)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF

  IF (IFIELD==0) THEN
    OFIELD = .FALSE.
  ELSE IF (IFIELD==1) THEN
    OFIELD = .TRUE.
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L0',TRIM(TPFILE%CNAME)//': invalid value in file for ' &
                                                           //TRIM(TPFIELD%CMNHNAME))
    OFIELD = .TRUE.
    IRESP = -112
  END IF

  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong size or type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_L0


SUBROUTINE IO_READ_FIELD_NC4_L1(TPFILE, TPFIELD, OFIELD, KRESP)
TYPE(TFILEDATA),     INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),    INTENT(INOUT) :: TPFIELD
LOGICAL,DIMENSION(:),INTENT(OUT)   :: OFIELD
INTEGER,             INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP
INTEGER                  :: JI
INTEGER,DIMENSION(SIZE(OFIELD)) :: IFIELD

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!NF90_INT1 is for the case a boolean was written
!Accept also INT and INT64 (for backward compatibility)
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT1 .OR. ITYPE == NF90_INT .OR. ITYPE == NF90_INT64)  ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(OFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, IFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF

    DO JI=1,IDIMLEN
      IF (IFIELD(JI)==0) THEN
        OFIELD(JI) = .FALSE.
      ELSE IF (IFIELD(JI)==1) THEN
        OFIELD(JI) = .TRUE.
      ELSE
        OFIELD(JI) = .TRUE.
        IRESP = -112
      END IF
    END DO
    IF (IRESP==-112) THEN
      CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L1',TRIM(TPFILE%CNAME)//': invalid value(s) in file for ' &
                                                             //TRIM(TPFIELD%CMNHNAME))
    END IF

    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_L1


SUBROUTINE IO_READ_FIELD_NC4_C0(TPFILE, TPFIELD, HFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
CHARACTER(LEN=*), INTENT(OUT)   :: HFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)     :: STATUS
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: IVARID
INTEGER(KIND=IDCDF_KIND)     :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)     :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)            :: YVARNAME
CHARACTER(LEN=:),ALLOCATABLE :: YSTR
INTEGER(KIND=IDCDF_KIND)     :: IDIMLEN
INTEGER                      :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 1 .AND. (ITYPE == NF90_CHAR) ) THEN
   ! Check size of variable before reading
   STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
   !
   ALLOCATE(CHARACTER(LEN=IDIMLEN)::YSTR)
   ! Read variable
   STATUS = NF90_GET_VAR(INCID, IVARID, YSTR)
   IF (STATUS /= NF90_NOERR) THEN
     CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
     GOTO 1000
   END IF
   IF (LEN_TRIM(YSTR) > LEN(HFIELD)) &
     CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' truncated')
   HFIELD = TRIM(YSTR)
   DEALLOCATE(YSTR)

   ! Read and check attributes of variable
   CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_C0

SUBROUTINE IO_READ_FIELD_NC4_T0(TPFILE, TPFIELD, TPDATA, KRESP)

USE MODD_TYPE_DATE

TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
TYPE (DATE_TIME), INTENT(OUT)   :: TPDATA
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)     :: STATUS
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: IVARID
INTEGER(KIND=IDCDF_KIND)     :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)     :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)            :: YVARNAME
CHARACTER(LEN=:),ALLOCATABLE :: YSTR
INTEGER(KIND=IDCDF_KIND)     :: IDIMLEN
INTEGER                      :: IDX,IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_T0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_T0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 0 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Read time
  STATUS = NF90_GET_VAR(INCID, IVARID, TPDATA%TIME)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF
  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP,HCALENDAR='standard')
  ! Extract date from UNITS
  IDX =  INDEX(TPFIELD%CUNITS,'since ')
  READ(TPFIELD%CUNITS(IDX+6 :IDX+9), '( I4.4 )') TPDATA%TDATE%YEAR
  READ(TPFIELD%CUNITS(IDX+11:IDX+12),'( I2.2 )') TPDATA%TDATE%MONTH
  READ(TPFIELD%CUNITS(IDX+14:IDX+15),'( I2.2 )') TPDATA%TDATE%DAY
  ! Simple check (should catch most errors)
  IF ( TPDATA%TDATE%DAY<1 .OR. TPDATA%TDATE%DAY>31 .OR. TPDATA%TDATE%MONTH<1 .OR. TPDATA%TDATE%MONTH>12 ) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' read date is invalid')
    IRESP = -3
  END IF
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_T0

END MODULE MODE_NETCDF

#else
!
! External dummy subroutines
!
SUBROUTINE IO_WRITE_FIELD_NC4(A,B,C,D)
INTEGER :: A,B,C,D
PRINT *, 'IO_WRITE_FIELD_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_FIELD_NC4

SUBROUTINE IO_READ_FIELD_NC4(A,B,C,D)
INTEGER :: A,B,C,D
PRINT *, 'IO_READ_FIELD_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_READ_FIELD_NC4

SUBROUTINE IO_WRITE_HEADER_NC4(A,B)
INTEGER :: A,B
PRINT *, 'IO_WRITE_HEADER_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_HEADER_NC4

SUBROUTINE CLEANIOCDF(A)
INTEGER :: A
PRINT *, 'CLEANIOCDF empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE CLEANIOCDF

#endif
