!MNH_LIC Copyright 1994-2016 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
!  Modifications:
!    P. Wautelet : may 2016: use NetCDF Fortran module
!-----------------------------------------------------------------
!-----------------------------------------------------------------
#if defined(MNH_IOCDF4)
MODULE MODE_NETCDF
USE MODD_NETCDF
USE NETCDF
USE MODD_IO_ll, ONLY : TFILEDATA
USE MODE_FIELD, ONLY : TFIELDDATA

IMPLICIT NONE 

PRIVATE

INTEGER(KIND=IDCDF_KIND),PARAMETER :: SHUFFLE = 1 !Set to 1 for (usually) better compression
INTEGER(KIND=IDCDF_KIND),PARAMETER :: DEFLATE = 1

INTERFACE IO_WRITE_FIELD_NC4
   MODULE PROCEDURE IO_WRITE_FIELD_NC4_X0,                       &
                    IO_WRITE_FIELD_NC4_X2,IO_WRITE_FIELD_NC4_X3, &
                    IO_WRITE_FIELD_NC4_N0, &
                    IO_WRITE_FIELD_NC4_C0
END INTERFACE IO_WRITE_FIELD_NC4

INTERFACE NCWRIT
   MODULE PROCEDURE NCWRITX0, NCWRITX1, NCWRITX2, NCWRITX3, &
        & NCWRITX4, NCWRITX5, NCWRITX6, &
        & NCWRITN0, NCWRITN1, NCWRITN2, &
        & NCWRITC0, NCWRITC1
END INTERFACE NCWRIT

INTERFACE NCREAD
   MODULE PROCEDURE NCREADX0, NCREADX1, NCREADX2, NCREADX3, &
        & NCREADX4, NCREADX5, NCREADX6, &
        & NCREADN0, NCREADN1, NCREADN2, &
        & NCREADC0
END INTERFACE NCREAD

! Public from module netcdf
PUBLIC NF90_OPEN,NF90_CREATE,NF90_NOWRITE,NF90_CLOBBER,NF90_NETCDF4,NF90_NOERR,NF90_STRERROR
! Public from this module :
PUBLIC NEWIOCDF,CLEANIOCDF,NCWRIT,NCREAD,IO_WRITE_FIELD_NC4,IO_WRITE_HEADER_NC4

CONTAINS

FUNCTION NEWIOCDF()
TYPE(IOCDF), POINTER :: NEWIOCDF
TYPE(IOCDF), POINTER :: TZIOCDF
INTEGER              :: IRESP

ALLOCATE(TZIOCDF, STAT=IRESP)
IF (IRESP > 0) THEN 
  PRINT *, 'NEWIOCDF : memory allocation error...'
  STOP
END IF

TZIOCDF%NCID = -1
NULLIFY(TZIOCDF%DIMX)
NULLIFY(TZIOCDF%DIMY)
NULLIFY(TZIOCDF%DIMZ)
NULLIFY(TZIOCDF%DIMSTR)
NULLIFY(TZIOCDF%DIMLIST)

NEWIOCDF=>TZIOCDF

END FUNCTION NEWIOCDF

SUBROUTINE CLEANIOCDF(PIOCDF)
TYPE(IOCDF),  POINTER :: PIOCDF

INTEGER(KIND=IDCDF_KIND) :: IRESP

! Close Netcdf File
IRESP = NF90_CLOSE(PIOCDF%NCID)
IF (IRESP /= NF90_NOERR) THEN
   PRINT *, 'CLEANIOCDF, NF90_CLOSE error : ', NF90_STRERROR(IRESP)
END IF

! Clean DIMLIST and DIMSTR
CALL CLEANLIST(PIOCDF%DIMLIST)
CALL CLEANLIST(PIOCDF%DIMSTR)
! Then free iocdf
DEALLOCATE(PIOCDF)

PRINT *, 'CLEANIOCDF done.'

CONTAINS

SUBROUTINE CLEANLIST(PLIST)
TYPE(DIMCDF), POINTER :: PLIST,TZDIMCUR, TZDIMNEXT    

TZDIMCUR  => PLIST
DO WHILE(ASSOCIATED(TZDIMCUR))
   TZDIMNEXT => TZDIMCUR%NEXT
   DEALLOCATE(TZDIMCUR)
   TZDIMCUR => TZDIMNEXT
END DO

END SUBROUTINE CLEANLIST
  
END SUBROUTINE CLEANIOCDF

SUBROUTINE HANDLE_ERR(status,line,text,kresp)
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: status
INTEGER, INTENT(IN) :: line
CHARACTER(LEN=*), INTENT(IN) :: text
INTEGER, OPTIONAL, INTENT(OUT) :: kresp

! Don't stop the code when kresp is present
! and ensure kresp is a negative integer
IF (status /= NF90_NOERR) THEN
   PRINT *, 'NETCDF ERROR in '//TRIM(text), line, NF90_STRERROR(status)
   IF (PRESENT(kresp)) THEN
      IF (status < 0) THEN
         kresp = status
      ELSE IF (status == 0) THEN
         kresp = -1
      ELSE
         kresp = -status
      END IF
   ELSE
      STOP
   END IF
END IF
END SUBROUTINE HANDLE_ERR

FUNCTION str_replace(hstr, hold, hnew)
CHARACTER(LEN=*) :: hstr, hold, hnew
CHARACTER(LEN=LEN_TRIM(hstr)+MAX(0,LEN(hnew)-LEN(hold))) :: str_replace

INTEGER :: pos

pos = INDEX(hstr,hold)
IF (pos /= 0) THEN
   str_replace = hstr(1:pos-1)//hnew//hstr(pos+LEN(hold):)
ELSE 
   str_replace = hstr 
END IF

END FUNCTION str_replace

SUBROUTINE IO_WRITE_HEADER_NC4(TPFILE,HFIPRI)
!
USE MODD_IO_ll, ONLY: ISP,TFILEDATA
!
USE MODE_FD_ll
!
TYPE(TFILEDATA),POINTER,INTENT(IN)  :: TPFILE ! File structure
CHARACTER(LEN=*),       INTENT(IN)  :: HFIPRI ! File for prints in FM
!
INTEGER(KIND=IDCDF_KIND) :: ISTATUS
TYPE(FD_ll), POINTER         :: TZFD
!
IF (TRIM(TPFILE%CFORMAT)/='NETCDF4' .AND. TRIM(TPFILE%CFORMAT)/='LFICDF4') RETURN
!
TZFD=>GETFD(TRIM(ADJUSTL(TPFILE%CNAME))//'.lfi')
!
IF (ISP == TZFD%OWNER)  THEN
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'Conventions', 'CF-1.6')
  IF (ISTATUS /= NF90_NOERR) CALL HANDLE_ERR(ISTATUS,__LINE__,'IO_FILE_WRITE_HEADER[NF90_PUT_ATT]')

!title

!history

!institution

!source

!comment

!references
END IF
!
END SUBROUTINE IO_WRITE_HEADER_NC4

SUBROUTINE WRITATTR(KNCID, KVARID, TPFMH)
USE MODD_FM, ONLY : FMHEADER
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KVARID
TYPE(FMHEADER), INTENT(IN) :: TPFMH

INTEGER(KIND=IDCDF_KIND) :: STATUS

! GRID attribute definition
STATUS = NF90_PUT_ATT(KNCID, KVARID, 'GRID', TPFMH%GRID)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITATTR [NF90_PUT_ATT]')

! COMMENT attribute definition
STATUS = NF90_PUT_ATT(KNCID, KVARID,'COMMENT', TRIM(TPFMH%COMMENT))
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITATTR [NF90_PUT_ATT]')

END SUBROUTINE WRITATTR

SUBROUTINE IO_WRITE_FIELD_ATTR_NC4(TPFIELD,KNCID,KVARID)
!
TYPE(TFIELDDATA),      INTENT(IN)   :: TPFIELD
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KVARID
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
!
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0 .AND. LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
  PRINT *,'ERROR: IO_WRITE_ATTR_NC4: at least long_name or standard_name must be provided &
  &to respect CF-convention for variable ',TRIM(TPFIELD%CMNHNAME)
ENDIF
!
! GRID attribute definition
IF(TPFIELD%NGRID<0) THEN
!  PRINT *,'WARNING: IO_WRITE_ATTR_NC4: TPFIELD%NGRID not set for variable ',TRIM(TPFIELD%CMNHNAME)
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID, 'GRID', TPFIELD%NGRID)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! COMMENT attribute definition
IF(LEN_TRIM(TPFIELD%CCOMMENT)==0) THEN
!  PRINT *,'WARNING: IO_WRITE_ATTR_NC4: TPFIELD%CCOMMENT not set for variable ',TRIM(TPFIELD%CMNHNAME)
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'COMMENT', TRIM(TPFIELD%CCOMMENT))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Standard_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0) THEN
!  PRINT *,'WARNING: IO_WRITE_ATTR_NC4: TPFIELD%CSTDNAME not set for variable ',TRIM(TPFIELD%CMNHNAME)
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'standard_name', TRIM(TPFIELD%CSTDNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Long_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
!  PRINT *,'WARNING: IO_WRITE_ATTR_NC4: TPFIELD%CLONGNAME not set for variable ',TRIM(TPFIELD%CMNHNAME)
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'long_name', TRIM(TPFIELD%CLONGNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Canonical units attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CUNITS)==0) THEN
!  PRINT *,'WARNING: IO_WRITE_ATTR_NC4: TPFIELD%CUNITS not set for variable ',TRIM(TPFIELD%CMNHNAME)
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'units', TRIM(TPFIELD%CUNITS))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
END SUBROUTINE IO_WRITE_FIELD_ATTR_NC4

FUNCTION GETDIMCDF(PIOCDF, KLEN, HDIMNAME)
TYPE(IOCDF), POINTER       :: PIOCDF
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
CHARACTER(LEN=*), OPTIONAL :: HDIMNAME ! When provided don't search but
                                       ! simply create with name HDIMNAME
TYPE(DIMCDF), POINTER   :: GETDIMCDF

TYPE(DIMCDF), POINTER :: TMP
INTEGER               :: COUNT
CHARACTER(LEN=7)      :: YSUFFIX
CHARACTER(LEN=8)      :: YDIMNAME
INTEGER(KIND=IDCDF_KIND) :: STATUS

IF (KLEN < 1) THEN
   PRINT *, 'GETDIMCDF Error, KLEN=', KLEN
   STOP
END IF

IF (PRESENT(HDIMNAME)) THEN
   NULLIFY(TMP)
   YDIMNAME = TRIM(HDIMNAME)
ELSE
   ! Search dimension with KLEN length
   COUNT = 1
   TMP  => PIOCDF%DIMLIST
   DO WHILE(ASSOCIATED(TMP))
      IF (TMP%LEN == KLEN .AND. TMP%NAME /= 'STRLEN') EXIT
      TMP=>TMP%NEXT
      COUNT = COUNT+1
   END DO
   WRITE(YSUFFIX,'(i7)') KLEN
   YDIMNAME = 'D'//ADJUSTL(YSUFFIX)
END IF

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = YDIMNAME
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(PIOCDF%NCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETDIMCDF[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT       => PIOCDF%DIMLIST
   PIOCDF%DIMLIST => TMP
END IF

GETDIMCDF => TMP

END FUNCTION GETDIMCDF

FUNCTION GETSTRDIMID(PIOCDF, KLEN)
TYPE(IOCDF), POINTER    :: PIOCDF
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
INTEGER(KIND=IDCDF_KIND)            :: GETSTRDIMID

TYPE(DIMCDF), POINTER :: TMP
CHARACTER(LEN=7)      :: YSUFFIX
CHARACTER(LEN=8)      :: YDIMNAME
INTEGER(KIND=IDCDF_KIND) :: STATUS

IF (KLEN < 1) THEN
   PRINT *, 'GETSTRDIMID Error, KLEN=', KLEN
   STOP
END IF

! Search string dimension with KLEN length
TMP  => PIOCDF%DIMSTR
DO WHILE(ASSOCIATED(TMP))
   IF (TMP%LEN == KLEN) EXIT
   TMP=>TMP%NEXT
END DO
WRITE(YSUFFIX,'(i7)') KLEN
YDIMNAME = 'S'//ADJUSTL(YSUFFIX)

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = YDIMNAME
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(PIOCDF%NCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETSTRDIMID[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT      => PIOCDF%DIMSTR
   PIOCDF%DIMSTR => TMP
END IF

GETSTRDIMID = TMP%ID

END FUNCTION GETSTRDIMID

SUBROUTINE FILLVDIMS(PIOCDF, KSHAPE, HDIR, KVDIMS)
TYPE(IOCDF),           POINTER        :: PIOCDF 
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), INTENT(IN) :: KSHAPE
CHARACTER(LEN=*),      INTENT(IN)     :: HDIR
INTEGER(KIND=IDCDF_KIND),DIMENSION(:), INTENT(OUT) :: KVDIMS

INTEGER :: II
TYPE(DIMCDF), POINTER :: PTDIM

IF (SIZE(KSHAPE) < 1) THEN
   PRINT *, 'FILLVDIMS Error, KSHAPE empty'
   STOP
END IF

DO II=1, SIZE(KSHAPE)

   IF (II == 1) THEN
      IF (HDIR == 'XX' .OR. HDIR == 'XY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMX))  PIOCDF%DIMX => GETDIMCDF(PIOCDF, KSHAPE(II), 'X')
         IF (KSHAPE(II) == PIOCDF%DIMX%LEN) THEN
            PTDIM => PIOCDF%DIMX
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE IF (HDIR == 'YY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMY))  PIOCDF%DIMY => GETDIMCDF(PIOCDF, KSHAPE(II), 'Y')
         IF (KSHAPE(II) == PIOCDF%DIMY%LEN) THEN
            PTDIM => PIOCDF%DIMY
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE
         PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         KVDIMS(II) = PTDIM%ID
      END IF
   ELSE IF (II == 2) THEN
      IF (HDIR == 'XY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMY))  PIOCDF%DIMY => GETDIMCDF(PIOCDF, KSHAPE(II), 'Y')
         IF (KSHAPE(II) == PIOCDF%DIMY%LEN) THEN
            PTDIM => PIOCDF%DIMY
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE
         PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
      END IF
   ELSE IF (II == 3) THEN
      IF (HDIR == 'XY') THEN
         IF (.NOT. ASSOCIATED(PIOCDF%DIMZ))  PIOCDF%DIMZ => GETDIMCDF(PIOCDF, KSHAPE(II), 'Z')
         IF (KSHAPE(II) == PIOCDF%DIMZ%LEN) THEN
            PTDIM => PIOCDF%DIMZ
         ELSE
            PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
         END IF
      ELSE
         PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
      END IF
   ELSE
      PTDIM => GETDIMCDF(PIOCDF, KSHAPE(II))
   END IF
   
   KVDIMS(II) = PTDIM%ID
      
END DO

END SUBROUTINE FILLVDIMS


SUBROUTINE NCWRITX0(PZCDF, HVARNAME, HDIR, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER             :: PZCDF
CHARACTER(LEN=*),     INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),     INTENT(IN) :: HDIR
REAL,                 INTENT(IN) :: PFIELD
TYPE(FMHEADER),       INTENT(IN) :: TPFMH
INTEGER,              INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER           :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX0[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITX0 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX0[NF90_PUT_VAR]',IRESP)

KRESP = IRESP
END SUBROUTINE NCWRITX0

SUBROUTINE IO_WRITE_FIELD_NC4_X0(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
USE MODD_FM, ONLY : FMHEADER
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
REAL,                  INTENT(IN) :: PFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(TPFIELD%CMNHNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
ELSE
   PRINT *,'IO_WRITE_FIELD_NC4_X0: ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X0

SUBROUTINE NCWRITX1(PZCDF, HVARNAME, HDIR, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER             :: PZCDF
CHARACTER(LEN=*),     INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),     INTENT(IN) :: HDIR
REAL, DIMENSION(:),   INTENT(IN) :: PFIELD
TYPE(FMHEADER),       INTENT(IN) :: TPFMH
INTEGER,              INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)

   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX1[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITX1 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX1[NF90_PUT_VAR]',IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITX1

SUBROUTINE NCWRITX2(PZCDF, HVARNAME, HDIR, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER             :: PZCDF
CHARACTER(LEN=*),     INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),     INTENT(IN) :: HDIR
REAL, DIMENSION(:,:), INTENT(IN) :: PFIELD
TYPE(FMHEADER),       INTENT(IN) :: TPFMH
INTEGER,              INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)
   
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX2[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITX2 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX2[NF90_PUT_VAR]',IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITX2

SUBROUTINE IO_WRITE_FIELD_NC4_X2(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP,KVERTLEVEL,KZFILE)
!
USE MODD_FM, ONLY : FMHEADER
USE MODE_IO_MANAGE_STRUCT, ONLY: IO_FILE_FIND_BYNAME
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
REAL,DIMENSION(:,:),   INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
INTEGER,OPTIONAL,      INTENT(IN) :: KVERTLEVEL ! Number of the vertical level (needed for Z-level splitted files)
INTEGER,OPTIONAL,      INTENT(IN) :: KZFILE     ! Number of the Z-level splitted file
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=4)         :: YSUFFIX
CHARACTER(LEN=3)         :: YNUMBER
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
TYPE(TFILEDATA),POINTER  :: TZFILE
!
IRESP = 0

IF (PRESENT(KVERTLEVEL)) THEN
  WRITE(YSUFFIX,'(I4.4)') KVERTLEVEL
  IF (.NOT.PRESENT(KZFILE)) THEN
    PRINT *,'FATAL: IO_WRITE_FIELD_NC4_X2: KZFILE argument not provided'
    STOP
  END IF
  WRITE(YNUMBER,'(I3.3)') KZFILE
  YVARNAME = TRIM(TPFIELD%CMNHNAME)//YSUFFIX
!PW: TODO: try to not do a find (for better perf)
  CALL IO_FILE_FIND_BYNAME(TRIM(TPFILE%CNAME)//'.Z'//YNUMBER,TZFILE,IRESP)
  IF (IRESP/=0) THEN
    PRINT *,'FATAL: IO_WRITE_FIELD_NC4_X2: file ',TRIM(TRIM(TPFILE%CNAME)//'.Z'//YNUMBER),' not found in list'
    STOP
  END IF
ELSE
  YVARNAME = TRIM(TPFIELD%CMNHNAME)
  TZFILE => TPFILE
ENDIF

! Get the Netcdf file ID
INCID = TZFILE%NNCID
! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(YVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     PRINT *,'WARNING: IO_WRITE_FIELD_NC4_X2: ignoring variable with a zero size (',TRIM(YVARNAME),')'
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TZFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TZFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TZFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR_DEFLATE]')
   END IF
   CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
ELSE
   PRINT *,'IO_WRITE_FIELD_NC4_X2: ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X2

SUBROUTINE NCWRITX3(PZCDF, HVARNAME, HDIR, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER              :: PZCDF
CHARACTER(LEN=*),      INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),      INTENT(IN) :: HDIR
REAL, DIMENSION(:,:,:),INTENT(IN) :: PFIELD
TYPE(FMHEADER),        INTENT(IN) :: TPFMH
INTEGER,               INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)

   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX3[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITX3 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX3[NF90_PUT_VAR] '//TRIM(HVARNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITX3

SUBROUTINE IO_WRITE_FIELD_NC4_X3(TPFILE,TPFIELD,PZCDF,PFIELD,KRESP)
!
USE MODD_FM, ONLY : FMHEADER
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
REAL,DIMENSION(:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(TPFIELD%CMNHNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     PRINT *,'WARNING: IO_WRITE_FIELD_NC4_X3: ignoring variable with a zero size (',TRIM(YVARNAME),')'
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), TPFIELD%CDIR, IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
ELSE
   PRINT *,'IO_WRITE_FIELD_NC4_X3: ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X3

SUBROUTINE NCWRITX4(PZCDF, HVARNAME, HDIR, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER                 :: PZCDF
CHARACTER(LEN=*),         INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),         INTENT(IN) :: HDIR
REAL, DIMENSION(:,:,:,:), INTENT(IN) :: PFIELD
TYPE(FMHEADER),           INTENT(IN) :: TPFMH
INTEGER,                  INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)

   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX4[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITX4 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX4[NF90_PUT_VAR]',IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITX4

SUBROUTINE NCWRITX5(PZCDF, HVARNAME, HDIR, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER                   :: PZCDF
CHARACTER(LEN=*),           INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),           INTENT(IN) :: HDIR
REAL, DIMENSION(:,:,:,:,:), INTENT(IN) :: PFIELD
TYPE(FMHEADER),             INTENT(IN) :: TPFMH
INTEGER,                    INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)

   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX5[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITX5 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX5[NF90_PUT_VAR]',IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITX5

SUBROUTINE NCWRITX6(PZCDF, HVARNAME, HDIR, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER                     :: PZCDF
CHARACTER(LEN=*),             INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),             INTENT(IN) :: HDIR
REAL, DIMENSION(:,:,:,:,:,:), INTENT(IN) :: PFIELD
TYPE(FMHEADER),               INTENT(IN) :: TPFMH
INTEGER,                      INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)
   
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX6[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITX6 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITX6[NF90_PUT_VAR]',IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITX6

SUBROUTINE NCWRITN0(PZCDF, HVARNAME, HDIR, KFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
TYPE(IOCDF), POINTER             :: PZCDF
CHARACTER(LEN=*),     INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),     INTENT(IN) :: HDIR
INTEGER,              INTENT(IN) :: KFIELD
TYPE(FMHEADER),       INTENT(IN) :: TPFMH
INTEGER,              INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER           :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITN0[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITN0 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITN0[NF90_PUT_VAR]',IRESP)
!
! Use IMAX, JMAX, KMAX to define DIMX, DIMY, DIMZ
! /!\ Can only work if IMAX, JMAX or KMAX are written before any array
!
#if 0
IF (YVARNAME == 'IMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMX)) PZCDF%DIMX=>GETDIMCDF(PZCDF,KFIELD+2*JPHEXT,'X')
IF (YVARNAME == 'JMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMY)) THEN
   IF (LPACK .AND. L2D) THEN
      PZCDF%DIMY=>GETDIMCDF(PZCDF, 1,'Y')
   ELSE
      PZCDF%DIMY=>GETDIMCDF(PZCDF, KFIELD+2*JPHEXT, 'Y')
   END IF
END IF
#endif
IF (YVARNAME == 'KMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMZ)) PZCDF%DIMZ=>GETDIMCDF(PZCDF,INT(KFIELD+2*JPVEXT,KIND=IDCDF_KIND),'Z')
 
KRESP = IRESP
END SUBROUTINE NCWRITN0

SUBROUTINE IO_WRITE_FIELD_NC4_N0(TPFILE,TPFIELD,PZCDF,KFIELD,KRESP)
!
USE MODD_FM, ONLY : FMHEADER
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
#if 0
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
#endif
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
INTEGER,               INTENT(IN) :: KFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(TPFIELD%CMNHNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
ELSE
   PRINT *,'IO_WRITE_FIELD_NC4_N0: ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

!
! Use IMAX, JMAX, KMAX to define DIMX, DIMY, DIMZ
! /!\ Can only work if IMAX, JMAX or KMAX are written before any array
!
#if 0
IF (YVARNAME == 'IMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMX)) PZCDF%DIMX=>GETDIMCDF(PZCDF,KFIELD+2*JPHEXT,'X')
IF (YVARNAME == 'JMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMY)) THEN
   IF (LPACK .AND. L2D) THEN
      PZCDF%DIMY=>GETDIMCDF(PZCDF, 1,'Y')
   ELSE
      PZCDF%DIMY=>GETDIMCDF(PZCDF, KFIELD+2*JPHEXT, 'Y')
   END IF
END IF
#endif
IF (YVARNAME == 'KMAX' .AND. .NOT. ASSOCIATED(PZCDF%DIMZ)) PZCDF%DIMZ=>GETDIMCDF(PZCDF,INT(KFIELD+2*JPVEXT,KIND=IDCDF_KIND),'Z')
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N0

SUBROUTINE NCWRITN1(PZCDF, HVARNAME, HDIR, KFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER              :: PZCDF
CHARACTER(LEN=*),      INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),      INTENT(IN) :: HDIR
INTEGER, DIMENSION(:), INTENT(IN) :: KFIELD
TYPE(FMHEADER),        INTENT(IN) :: TPFMH
INTEGER,               INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)
   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITN1[NF90_DEF_VAR] '//TRIM(YVARNAME))
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITN1 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITN1[NF90_PUT_VAR]',IRESP)

KRESP = IRESP 
END SUBROUTINE NCWRITN1

SUBROUTINE NCWRITN2(PZCDF, HVARNAME, HDIR, KFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER               :: PZCDF
CHARACTER(LEN=*),       INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),       INTENT(IN) :: HDIR
INTEGER, DIMENSION(:,:),INTENT(IN) :: KFIELD
TYPE(FMHEADER),         INTENT(IN) :: TPFMH
INTEGER,                INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER               :: IRESP

IRESP = 0
! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(PZCDF, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), HDIR, IVDIMS)

   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITN2[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITN2 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITN2[NF90_PUT_VAR]',IRESP)

KRESP = IRESP
END SUBROUTINE NCWRITN2

SUBROUTINE NCWRITC0(PZCDF, HVARNAME, HDIR, HFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF), POINTER              :: PZCDF
CHARACTER(LEN=*),      INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),      INTENT(IN) :: HDIR
CHARACTER(LEN=*),      INTENT(IN) :: HFIELD
TYPE(FMHEADER),        INTENT(IN) :: TPFMH
INTEGER,               INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
CHARACTER(LEN=32)     :: YSTR
!CHARACTER(LEN=LEN(HFIELD)) :: YSTR
INTEGER               :: IRESP

IRESP = 0
YSTR = HFIELD
IF (LEN_TRIM(HFIELD) > LEN(YSTR)) THEN
   PRINT *,'NCWRIT0 : ',TRIM(YVARNAME), ' string variable TRUNCATED.'
END IF

! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(PZCDF, INT(LEN(YSTR),KIND=IDCDF_KIND))
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITC0[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITC0 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, YSTR)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITC0[NF90_PUT_VAR]',IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITC0

SUBROUTINE IO_WRITE_FIELD_NC4_C0(TPFILE,TPFIELD,PZCDF,HFIELD,KRESP)
!
USE MODD_FM, ONLY : FMHEADER
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE(IOCDF), POINTER              :: PZCDF
CHARACTER(LEN=*),      INTENT(IN) :: HFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER,PARAMETER :: IMULT = 16
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
INTEGER                                :: IRESP, ILEN
CHARACTER(LEN=:),ALLOCATABLE           :: YFIELD
!
IRESP = 0

!Store the character string in a string of a size multiple of IMULT
!This is done to limit the number of dimensions in the netCDF file
ILEN = ((LEN_TRIM(HFIELD)+IMULT-1)/IMULT)*IMULT
IF (MOD(ILEN,IMULT)/=0) PRINT *,'ERROR: IO_WRITE_FIELD_NC4_C0: ILEN is not a multiple of IMULT'
!If the string is empty, create it anyway with a non-zero size (to prevent problems later)
IF (ILEN==0) ILEN = IMULT

! Get the Netcdf file ID
INCID = TPFILE%NNCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(TPFIELD%CMNHNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(PZCDF,INT(ILEN,KIND=IDCDF_KIND))
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
ELSE
   PRINT *,'IO_WRITE_FIELD_NC4_C0: ', TRIM(YVARNAME), ' already defined !'
END IF

ALLOCATE(CHARACTER(LEN=ILEN)::YFIELD)
YFIELD(:)=TRIM(HFIELD) !Warning: keep (:) to prevent F2003 automatic reallocation
YFIELD(LEN_TRIM(HFIELD)+1:)=' '
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, YFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
DEALLOCATE(YFIELD)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_C0

SUBROUTINE NCWRITC1(PZCDF, HVARNAME, HDIR, HFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER
TYPE(IOCDF),        POINTER              :: PZCDF
CHARACTER(LEN=*),             INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),             INTENT(IN) :: HDIR
CHARACTER(LEN=*),DIMENSION(:),INTENT(IN) :: HFIELD
TYPE(FMHEADER),               INTENT(IN) :: TPFMH
INTEGER,                      INTENT(OUT):: KRESP

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(2) :: IVDIMS
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: ITMP
INTEGER               :: IRESP
INTEGER(KIND=IDCDF_KIND) :: ILEN
INTEGER(KIND=IDCDF_KIND) :: ISIZE

IRESP = 0
ILEN  = LEN(HFIELD)
ISIZE = SIZE(HFIELD)

! Get the Netcdf file ID
INCID = PZCDF%NCID

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions ID 
   IVDIMS(1) = GETSTRDIMID(PZCDF,ILEN)
   CALL FILLVDIMS(PZCDF, (/ISIZE/), HDIR, ITMP)
   IVDIMS(2) = ITMP(1)
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITC1[NF90_DEF_VAR]')
   CALL WRITATTR(INCID, IVARID, TPFMH)
ELSE
   PRINT *,'NCWRITC1 : ', TRIM(YVARNAME), ' already defined !'
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, HFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCWRITC1[NF90_PUT_VAR]',IRESP)
 
KRESP = IRESP
END SUBROUTINE NCWRITC1

!
!
! Here come the NetCDF READ routines
!
!
SUBROUTINE READATTR(KNCID, KVARID, HVAR, TPFMH)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KVARID
CHARACTER(LEN=*),INTENT(IN) :: HVAR
TYPE(FMHEADER),  INTENT(OUT):: TPFMH

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN
      
! Read variables attributes (GRID and COMMENT)
STATUS = NF90_GET_ATT(KNCID, KVARID, 'GRID', TPFMH%GRID)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'READATTR[NF90_GET_ATT_INT] '//TRIM(HVAR))
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'COMMENT', LEN=ICOMLEN)
!IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'READATTR[NF90_INQUIRE_ATTRIBUTE] '//TRIM(HVAR))
IF (STATUS == NF90_NOERR) THEN
  IF (ICOMLEN <= JPXKRK) THEN
    TPFMH%COMLEN = ICOMLEN
    STATUS = NF90_GET_ATT(KNCID, KVARID, 'COMMENT', TPFMH%COMMENT)
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'READATTR[NF90_GET_ATT] '//TRIM(HVAR))
  ELSE
    PRINT *, 'READATTR : '//TRIM(HVAR)//' COMMENT attribute ignored because too long.'
    TPFMH%COMLEN = 0
  END IF
ELSE
  TPFMH%COMLEN = 0
END IF
END SUBROUTINE READATTR

SUBROUTINE NCREADX0(KNCID, HVARNAME, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*), INTENT(IN) :: HVARNAME
REAL,             INTENT(OUT):: PFIELD
TYPE(FMHEADER),   INTENT(OUT):: TPFMH
INTEGER,          INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER           :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADX0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADX0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 0 .AND. ITYPE == NF90_DOUBLE) THEN
   ! Read variable
   STATUS = NF90_GET_VAR(KNCID, IVARID, PFIELD)
   IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'NCREADX0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
   END IF
   ! Read variables attributes (GRID and COMMENT)
   CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
ELSE
   PRINT *, 'NCREADNCREADX0 : '//TRIM(YVARNAME)//' not READ (wrong size or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADX0

SUBROUTINE NCREADX1(KNCID, HVARNAME, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*),   INTENT(IN) :: HVARNAME
REAL, DIMENSION(:), INTENT(OUT):: PFIELD
TYPE(FMHEADER),     INTENT(OUT):: TPFMH
INTEGER,            INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADX1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADX1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == SIZE(SHAPE(PFIELD)) .AND. ITYPE == NF90_DOUBLE) THEN
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADX1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(PFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, PFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADX1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADX1 : '//TRIM(YVARNAME)//' not READ wrong size (file, mem) : ', IVARSIZE, SIZE(PFIELD)
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADX1 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADX1

SUBROUTINE NCREADX2(KNCID, HVARNAME, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*),     INTENT(IN) :: HVARNAME
REAL, DIMENSION(:,:), INTENT(OUT):: PFIELD
TYPE(FMHEADER),       INTENT(OUT):: TPFMH
INTEGER,              INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADX2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADX2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == SIZE(SHAPE(PFIELD)) .AND. ITYPE == NF90_DOUBLE) THEN
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADX2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(PFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, PFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADX2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADX2 : '//TRIM(YVARNAME)//' not READ (wrong size).'
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADX2 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADX2

SUBROUTINE NCREADX3(KNCID, HVARNAME, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*),       INTENT(IN) :: HVARNAME
REAL, DIMENSION(:,:,:), INTENT(OUT):: PFIELD
TYPE(FMHEADER),         INTENT(OUT):: TPFMH
INTEGER,                INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADX3[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADX3[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == SIZE(SHAPE(PFIELD)) .AND. ITYPE == NF90_DOUBLE) THEN
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADX3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(PFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, PFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADX3[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADX3 : '//TRIM(YVARNAME)//' not READ (wrong size).'
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADX3 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADX3

SUBROUTINE NCREADX4(KNCID, HVARNAME, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND), INTENT(IN) :: KNCID
CHARACTER(LEN=*),         INTENT(IN) :: HVARNAME
REAL, DIMENSION(:,:,:,:), INTENT(OUT):: PFIELD
TYPE(FMHEADER),           INTENT(OUT):: TPFMH
INTEGER,                  INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADX4[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADX4[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == SIZE(SHAPE(PFIELD)) .AND. ITYPE == NF90_DOUBLE) THEN
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADX4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(PFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, PFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADX4[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADX4 : '//TRIM(YVARNAME)//' not READ (wrong size).'
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADX4 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADX4

SUBROUTINE NCREADX5(KNCID, HVARNAME, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),   INTENT(IN) :: KNCID
CHARACTER(LEN=*),           INTENT(IN) :: HVARNAME
REAL, DIMENSION(:,:,:,:,:), INTENT(OUT):: PFIELD
TYPE(FMHEADER),             INTENT(OUT):: TPFMH
INTEGER,                    INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADX5[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADX5[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == SIZE(SHAPE(PFIELD)) .AND. ITYPE == NF90_DOUBLE) THEN
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADX5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(PFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, PFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADX5[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADX5 : '//TRIM(YVARNAME)//' not READ (wrong size).'
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADX5 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADX5

SUBROUTINE NCREADX6(KNCID, HVARNAME, PFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),     INTENT(IN) :: KNCID
CHARACTER(LEN=*),             INTENT(IN) :: HVARNAME
REAL, DIMENSION(:,:,:,:,:,:), INTENT(OUT):: PFIELD
TYPE(FMHEADER),               INTENT(OUT):: TPFMH
INTEGER,                      INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADX6[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADX6[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == SIZE(SHAPE(PFIELD)) .AND. ITYPE == NF90_DOUBLE) THEN
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADX6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(PFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, PFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADX6[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADX6 : '//TRIM(YVARNAME)//' not READ (wrong size).'
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADX6 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADX6

SUBROUTINE NCREADN0(KNCID, HVARNAME, KFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*), INTENT(IN) :: HVARNAME
INTEGER,          INTENT(OUT):: KFIELD
TYPE(FMHEADER),   INTENT(OUT):: TPFMH
INTEGER,          INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER           :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADN0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADN0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

#ifndef MNH_INT8
IF (IDIMS == 0 .AND. ITYPE == NF90_INT) THEN
#else
IF (IDIMS == 0 .AND. ITYPE == NF90_INT64) THEN
#endif
   ! Read variable
   STATUS = NF90_GET_VAR(KNCID, IVARID, KFIELD)
   IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'NCREADN0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
   END IF
   ! Read variables attributes (GRID and COMMENT)
   CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
ELSE
   PRINT *, 'NCREADN0 : '//TRIM(YVARNAME)//' not READ (wrong size or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADN0

SUBROUTINE NCREADN1(KNCID, HVARNAME, KFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*),      INTENT(IN) :: HVARNAME
INTEGER, DIMENSION(:), INTENT(OUT):: KFIELD
TYPE(FMHEADER),        INTENT(OUT):: TPFMH
INTEGER,               INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADN1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADN1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

#ifndef MNH_INT8
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. ITYPE == NF90_INT) THEN
#else
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. ITYPE == NF90_INT64) THEN
#endif
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADN1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(KFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, KFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADN1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADN1 : '//TRIM(YVARNAME)//' not READ (wrong size).'
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADN1 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADN1

SUBROUTINE NCREADN2(KNCID, HVARNAME, KFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*),        INTENT(IN) :: HVARNAME
INTEGER, DIMENSION(:,:), INTENT(OUT):: KFIELD
TYPE(FMHEADER),          INTENT(OUT):: TPFMH
INTEGER,                 INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)  :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER               :: IVARSIZE
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADN2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADN2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

#ifndef MNH_INT8
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. ITYPE == NF90_INT) THEN
#else
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. ITYPE == NF90_INT64) THEN
#endif
   ! Check size of variable before reading
   IVARSIZE = 1
   DO II=1,IDIMS
      STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(II), LEN=IDIMLEN)
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADN2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
      IVARSIZE = IVARSIZE*IDIMLEN
   END DO
   
   IF (IVARSIZE == SIZE(KFIELD)) THEN
      ! Read variable
      STATUS = NF90_GET_VAR(KNCID, IVARID, KFIELD)
      IF (STATUS /= NF90_NOERR) THEN
         CALL HANDLE_ERR(status,__LINE__,'NCREADN2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
         GOTO 1000
      END IF
      ! Read variables attributes (GRID and COMMENT)
      CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
   ELSE
      PRINT *, 'NCREADN2 : '//TRIM(YVARNAME)//' not READ (wrong size).'
      IRESP = -3
   END IF
ELSE
   PRINT *, 'NCREADN2 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADN2

SUBROUTINE NCREADC0(KNCID, HVARNAME, HFIELD, TPFMH, KRESP)
USE MODD_FM, ONLY : FMHEADER, JPXKRK
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KNCID
CHARACTER(LEN=*),      INTENT(IN) :: HVARNAME
CHARACTER(LEN=*),      INTENT(OUT):: HFIELD
TYPE(FMHEADER),        INTENT(OUT):: TPFMH
INTEGER,               INTENT(OUT):: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
CHARACTER(LEN=30)     :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(1) :: IVDIMS
CHARACTER(LEN=:),ALLOCATABLE :: YSTR
INTEGER(KIND=IDCDF_KIND) :: ICOMLEN ! comment length
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER               :: II
INTEGER               :: IRESP

IRESP = 0

! NetCDF var names can't contain '%' nor '.' 
YVARNAME = str_replace(HVARNAME, '%', '__')
YVARNAME = str_replace(YVARNAME, '.', '--')

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(KNCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'NCREADC0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(KNCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'NCREADC0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 1 .AND. ITYPE == NF90_CHAR) THEN
   ! Check size of variable before reading
   STATUS = NF90_INQUIRE_DIMENSION(KNCID, IVDIMS(1), LEN=IDIMLEN)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'NCREADC0[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
   !
   ALLOCATE(CHARACTER(LEN=IDIMLEN)::YSTR)
   ! Read variable
   STATUS = NF90_GET_VAR(KNCID, IVARID, YSTR)
   IF (STATUS /= NF90_NOERR) THEN
     CALL HANDLE_ERR(status,__LINE__,'NCREADC0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
     GOTO 1000
   END IF
   IF (LEN_TRIM(YSTR) > LEN(HFIELD)) PRINT *, 'NCDREADC0 : '//TRIM(YVARNAME)//' truncated !!'
   HFIELD = TRIM(YSTR)
   DEALLOCATE(YSTR)
   ! Read variables attributes (GRID and COMMENT)
   CALL READATTR(KNCID, IVARID, YVARNAME, TPFMH)
ELSE
   PRINT *, 'NCREADC0 : '//TRIM(YVARNAME)//' not READ (wrong shape or type).'
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE NCREADC0

END MODULE MODE_NETCDF

#else
!
! External dummy subroutines
!
SUBROUTINE IO_WRITE_FIELD_NC4(A,B,C,D)
INTEGER :: A,B,C,D
PRINT *, 'IO_WRITE_FIELD_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_FIELD_NC4

SUBROUTINE IO_WRITE_HEADER_NC4(A,B)
INTEGER :: A,B
PRINT *, 'IO_WRITE_HEADER_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_HEADER_NC4

SUBROUTINE NCWRIT(A,B,C,D,E,F)
INTEGER :: A,B,C,D,E,F
PRINT *, 'NCWRIT empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE NCWRIT

SUBROUTINE NCREAD(A,B,C,D,E)
INTEGER :: A,B,C,D,E
PRINT *, 'NCREAD empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE NCREAD

SUBROUTINE CLEANIOCDF(A)
INTEGER :: A
PRINT *, 'CLEANIOCDF empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE CLEANIOCDF

#endif
