!MNH_LIC Copyright 1994-2016 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
!  Modifications:
!    P. Wautelet : may 2016: use NetCDF Fortran module
!-----------------------------------------------------------------
!-----------------------------------------------------------------
#if defined(MNH_IOCDF4)
MODULE MODE_NETCDF
USE MODD_NETCDF
USE NETCDF
USE MODD_IO_ll
USE MODE_FIELD, ONLY : TFIELDDATA
USE MODE_MSG

IMPLICIT NONE 

PRIVATE

INTEGER(KIND=IDCDF_KIND),PARAMETER :: SHUFFLE = 1 !Set to 1 for (usually) better compression
INTEGER(KIND=IDCDF_KIND),PARAMETER :: DEFLATE = 1

INTERFACE IO_WRITE_FIELD_NC4
   MODULE PROCEDURE IO_WRITE_FIELD_NC4_X0,IO_WRITE_FIELD_NC4_X1, &
                    IO_WRITE_FIELD_NC4_X2,IO_WRITE_FIELD_NC4_X3, &
                    IO_WRITE_FIELD_NC4_X4,IO_WRITE_FIELD_NC4_X5, &
                    IO_WRITE_FIELD_NC4_X6,                       &
                    IO_WRITE_FIELD_NC4_N0,IO_WRITE_FIELD_NC4_N1, &
                    IO_WRITE_FIELD_NC4_L0,IO_WRITE_FIELD_NC4_L1, &
                    IO_WRITE_FIELD_NC4_N2,IO_WRITE_FIELD_NC4_N3, &
                    IO_WRITE_FIELD_NC4_C0,IO_WRITE_FIELD_NC4_C1, &
                    IO_WRITE_FIELD_NC4_T0
END INTERFACE IO_WRITE_FIELD_NC4

INTERFACE IO_READ_FIELD_NC4
   MODULE PROCEDURE IO_READ_FIELD_NC4_X0,IO_READ_FIELD_NC4_X1, &
                    IO_READ_FIELD_NC4_X2,IO_READ_FIELD_NC4_X3, &
                    IO_READ_FIELD_NC4_X4,IO_READ_FIELD_NC4_X5, &
                    IO_READ_FIELD_NC4_X6,                      &
                    IO_READ_FIELD_NC4_N0,IO_READ_FIELD_NC4_N1, &
                    IO_READ_FIELD_NC4_N2,                      &
                    IO_READ_FIELD_NC4_L0,IO_READ_FIELD_NC4_L1, &
                    IO_READ_FIELD_NC4_C0,                      &
                    IO_READ_FIELD_NC4_T0
END INTERFACE IO_READ_FIELD_NC4

! Public from module netcdf
PUBLIC NF90_CLOSE,NF90_OPEN,NF90_CREATE,NF90_NOWRITE,NF90_CLOBBER,NF90_NETCDF4,NF90_NOERR,NF90_STRERROR
! Public from this module :
PUBLIC NEWIOCDF,CLEANIOCDF,IO_SET_KNOWNDIMS_NC4,IO_WRITE_COORDVAR_NC4, &
       IO_WRITE_FIELD_NC4,IO_READ_FIELD_NC4,IO_WRITE_HEADER_NC4

CONTAINS

SUBROUTINE CLEANMNHNAME(HINNAME,HOUTNAME)
  CHARACTER(LEN=*),INTENT(IN)  :: HINNAME
  CHARACTER(LEN=*),INTENT(OUT) :: HOUTNAME

  ! NetCDF var names can't contain '%' nor '.'
  ! CF convention allows only letters, digits and underscores
  HOUTNAME = str_replace(HINNAME,  '%', '__')
  HOUTNAME = str_replace(HOUTNAME, '.', '___')
END SUBROUTINE

FUNCTION NEWIOCDF()
TYPE(IOCDF), POINTER :: NEWIOCDF
TYPE(IOCDF), POINTER :: TZIOCDF
INTEGER              :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','NEWIOCDF','called')

ALLOCATE(TZIOCDF, STAT=IRESP)
IF (IRESP > 0) THEN 
  CALL PRINT_MSG(NVERB_FATAL,'IO','NEWIOCDF','memory allocation error')
  STOP
END IF

NEWIOCDF=>TZIOCDF

END FUNCTION NEWIOCDF

SUBROUTINE CLEANIOCDF(PIOCDF)
TYPE(IOCDF),  POINTER :: PIOCDF

INTEGER(KIND=IDCDF_KIND) :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','CLEANIOCDF','called')

! Clean DIMLIST and DIMSTR
CALL CLEANLIST(PIOCDF%DIMLIST)
CALL CLEANLIST(PIOCDF%DIMSTR)
! Then free iocdf
DEALLOCATE(PIOCDF)

CONTAINS

SUBROUTINE CLEANLIST(PLIST)
TYPE(DIMCDF), POINTER :: PLIST,TZDIMCUR, TZDIMNEXT    

TZDIMCUR  => PLIST
DO WHILE(ASSOCIATED(TZDIMCUR))
   TZDIMNEXT => TZDIMCUR%NEXT
   DEALLOCATE(TZDIMCUR)
   TZDIMCUR => TZDIMNEXT
END DO

END SUBROUTINE CLEANLIST
  
END SUBROUTINE CLEANIOCDF


SUBROUTINE IO_SET_KNOWNDIMS_NC4(TPFILE)

USE MODD_DIM_n,         ONLY: NIMAX_ll, NJMAX_ll, NKMAX
USE MODD_PARAMETERS_ll, ONLY: JPHEXT, JPVEXT

TYPE(TFILEDATA),INTENT(IN) :: TPFILE

INTEGER              :: IIU_ll, IJU_ll, IKU
TYPE(IOCDF), POINTER :: PIOCDF

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_SET_KNOWNDIMS_NC4','called')

PIOCDF => TPFILE%TNCDIMS

IIU_ll = NIMAX_ll + 2*JPHEXT
IJU_ll = NJMAX_ll + 2*JPHEXT
IKU    = NKMAX    + 2*JPVEXT

IF (.NOT. ASSOCIATED(PIOCDF%DIM_NI))      PIOCDF%DIM_NI      => GETDIMCDF(TPFILE, IIU_ll, 'ni')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NJ))      PIOCDF%DIM_NJ      => GETDIMCDF(TPFILE, IJU_ll, 'nj')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NI_U))    PIOCDF%DIM_NI_U    => GETDIMCDF(TPFILE, IIU_ll, 'ni_u')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NJ_U))    PIOCDF%DIM_NJ_U    => GETDIMCDF(TPFILE, IJU_ll, 'nj_u')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NI_V))    PIOCDF%DIM_NI_V    => GETDIMCDF(TPFILE, IIU_ll, 'ni_v')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NJ_V))    PIOCDF%DIM_NJ_V    => GETDIMCDF(TPFILE, IJU_ll, 'nj_v')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_LEVEL))   PIOCDF%DIM_LEVEL   => GETDIMCDF(TPFILE, IKU   , 'level')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_LEVEL_W)) PIOCDF%DIM_LEVEL_W => GETDIMCDF(TPFILE, IKU   , 'level_w')

IF (.NOT. ASSOCIATED(PIOCDF%DIMTIME)) PIOCDF%DIMTIME => GETDIMCDF(TPFILE, NF90_UNLIMITED, 'time')

! Store X,Y,Z coordinates for the 4 Arakawa points
! Mass point
NCOORDID(1,1) = PIOCDF%DIM_NI
NCOORDID(2,1) = PIOCDF%DIM_NJ
NCOORDID(3,1) = PIOCDF%DIM_LEVEL
! u point
NCOORDID(1,2) = PIOCDF%DIM_NI_U
NCOORDID(2,2) = PIOCDF%DIM_NJ_U
NCOORDID(3,2) = PIOCDF%DIM_LEVEL
! v point
NCOORDID(1,3) = PIOCDF%DIM_NI_V
NCOORDID(2,3) = PIOCDF%DIM_NJ_V
NCOORDID(3,3) = PIOCDF%DIM_LEVEL
! w point
NCOORDID(1,4) = PIOCDF%DIM_NI
NCOORDID(2,4) = PIOCDF%DIM_NJ
NCOORDID(3,4) = PIOCDF%DIM_LEVEL_W

END SUBROUTINE IO_SET_KNOWNDIMS_NC4


SUBROUTINE IO_WRITE_COORDVAR_NC4(TPFILE)
USE MODD_CONF,       ONLY: CPROGRAM, LCARTESIAN
USE MODD_GRID_n,     ONLY: LSLEVE, XXHAT, XYHAT, XZHAT
USE MODD_PARAMETERS, ONLY: JPHEXT, JPVEXT

TYPE(TFILEDATA),INTENT(IN) :: TPFILE

CHARACTER(LEN=:),ALLOCATABLE  :: YSTDNAMEPREFIX
INTEGER                       :: IIU, IJU, IKU
INTEGER(KIND=IDCDF_KIND)      :: INCID
REAL,DIMENSION(:),ALLOCATABLE :: ZXHATM, ZYHATM,ZZHATM !Coordinates at mass points in the transformed space
TYPE(IOCDF), POINTER          :: PIOCDF

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_COORDVAR_NC4','called')

PIOCDF => TPFILE%TNCDIMS

! Get the Netcdf file ID
INCID = TPFILE%NNCID

IF (TPFILE%LMASTER) THEN
  IF ( TRIM(CPROGRAM)/='PGD' &
      .AND. .NOT.(TRIM(CPROGRAM)=='REAL'.AND. .NOT.ASSOCIATED(XXHAT)) ) THEN !condition to detect PREP_SURFEX
    IIU = SIZE(XXHAT)
    IJU = SIZE(XYHAT)
    ALLOCATE(ZXHATM(IIU),ZYHATM(IJU))
    ZXHATM(1:IIU-1) = 0.5*(XXHAT(1:IIU-1)+XXHAT(2:IIU))
    ZXHATM(IIU)     = 2.*XXHAT(IIU)-ZXHATM(IIU-1)
    ZYHATM(1:IJU-1) = 0.5*(XYHAT(1:IJU-1)+XYHAT(2:IJU))
    ZYHATM(IJU)     = 2.*XYHAT(IJU)-ZYHATM(IJU-1)
    !
    IF (LCARTESIAN) THEN
      YSTDNAMEPREFIX = 'plane'
    ELSE
      YSTDNAMEPREFIX = 'projection'
    ENDIF
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NI,'x-dimension of the grid',TRIM(YSTDNAMEPREFIX)//'_x_coordinate','X',0.,JPHEXT,JPHEXT,ZXHATM)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ,'y-dimension of the grid',TRIM(YSTDNAMEPREFIX)//'_y_coordinate','Y',0.,JPHEXT,JPHEXT,ZYHATM)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NI_U,'x-dimension of the grid at u location', &
                         TRIM(YSTDNAMEPREFIX)//'_x_coordinate_at_u_location','X',-0.5,JPHEXT,0,     XXHAT)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ_U,'y-dimension of the grid at u location', &
                         TRIM(YSTDNAMEPREFIX)//'_y_coordinate_at_u_location','Y', 0., JPHEXT,JPHEXT,ZYHATM)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NI_V,'x-dimension of the grid at v location', &
                         TRIM(YSTDNAMEPREFIX)//'_x_coordinate_at_v_location','X', 0., JPHEXT,JPHEXT,ZXHATM)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ_V,'y-dimension of the grid at v location', &
                         TRIM(YSTDNAMEPREFIX)//'_y_coordinate_at_v_location','Y',-0.5,JPHEXT,0,     XYHAT)
    !
    DEALLOCATE(ZXHATM,ZYHATM)
  ELSE
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NI,'x-dimension of the grid','x_grid_index','X',0.,JPHEXT,JPHEXT)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ,'y-dimension of the grid','y_grid_index','Y',0.,JPHEXT,JPHEXT)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NI_U,'x-dimension of the grid at u location','x_grid_index_at_u_location','X',-0.5,JPHEXT,0)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ_U,'y-dimension of the grid at u location','y_grid_index_at_u_location',&
                         'Y', 0., JPHEXT,JPHEXT)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NI_V,'x-dimension of the grid at v location','x_grid_index_at_v_location',&
                         'X', 0., JPHEXT,JPHEXT)
    CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ_V,'y-dimension of the grid at v location','y_grid_index_at_v_location','Y',-0.5,JPHEXT,0)
  ENDIF
  !
  IF (TRIM(CPROGRAM)/='PGD' .AND. TRIM(CPROGRAM)/='NESPGD' &
      .AND. .NOT.(TRIM(CPROGRAM)=='REAL'.AND. .NOT.ASSOCIATED(XXHAT)) ) THEN !condition to detect PREP_SURFEX
    !
    IKU = SIZE(XZHAT)
    ALLOCATE(ZZHATM(IKU))
    ZZHATM(1:IKU-1) = 0.5 * (XZHAT(2:IKU)+XZHAT(1:IKU-1))
    ZZHATM(IKU)     = 2.* XZHAT(IKU) - ZZHATM(IKU-1)
    !
    CALL WRITE_VER_COORD(PIOCDF%DIM_LEVEL,  'position z in the transformed space',              '', &
                         'altitude',               0., JPVEXT,JPVEXT,ZZHATM)
    !
    CALL WRITE_VER_COORD(PIOCDF%DIM_LEVEL_W,'position z in the transformed space at w location','', &
                         'altitude_at_w_location',-0.5,JPVEXT,0,     XZHAT)
    !
    DEALLOCATE(ZZHATM)
  END IF
  !
ENDIF


CONTAINS
SUBROUTINE WRITE_HOR_COORD(TDIM,HLONGNAME,HSTDNAME,HAXIS,PSHIFT,KBOUNDLOW,KBOUNDHIGH,PCOORDS)
  TYPE(DIMCDF), POINTER,     INTENT(IN) :: TDIM
  CHARACTER(LEN=*),          INTENT(IN) :: HLONGNAME
  CHARACTER(LEN=*),          INTENT(IN) :: HSTDNAME
  CHARACTER(LEN=*),          INTENT(IN) :: HAXIS
  REAL,                      INTENT(IN) :: PSHIFT
  INTEGER,                   INTENT(IN) :: KBOUNDLOW
  INTEGER,                   INTENT(IN) :: KBOUNDHIGH
  REAL,DIMENSION(:),OPTIONAL,INTENT(IN) :: PCOORDS

  CHARACTER(LEN=64)             :: YRANGE
  CHARACTER(LEN=:),ALLOCATABLE  :: YVARNAME
  INTEGER                       :: IRESP
  INTEGER                       :: ISIZE
  INTEGER                       :: JI
  INTEGER(KIND=IDCDF_KIND)      :: IVARID
  INTEGER(KIND=IDCDF_KIND)      :: IVDIM
  INTEGER(KIND=IDCDF_KIND)      :: STATUS
  REAL,DIMENSION(:),ALLOCATABLE :: ZTAB

  ISIZE = TDIM%LEN
  YVARNAME = TRIM(TDIM%NAME)
  IVDIM = TDIM%ID

  IF (.NOT.PRESENT(PCOORDS)) THEN
    ALLOCATE(ZTAB(ISIZE))
    DO JI=1,ISIZE
      ZTAB(JI) = REAL(JI,KIND=KIND(ZTAB(1)))+PSHIFT
    END DO
  END IF

  STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
  IF (STATUS /= NF90_NOERR) THEN
    ! Define the coordinate variable
    STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIM, IVARID)
    IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_DEF_VAR]')
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','WRITE_NC_COORDS_VAR',TRIM(YVARNAME)//' already defined')
  END IF

  ! Write metadata
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'long_name',HLONGNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'standard_name',HSTDNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  IF (PRESENT(PCOORDS)) THEN
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'units','m')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  END IF
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'axis',HAXIS)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_axis_shift',PSHIFT)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  WRITE(YRANGE,'( I0,":",I0 )') 1+KBOUNDLOW,ISIZE-KBOUNDHIGH
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_dynamic_range',TRIM(YRANGE))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))

  ! Write the data
  IF (PRESENT(PCOORDS)) THEN
    STATUS = NF90_PUT_VAR(INCID, IVARID, PCOORDS)
  ELSE
    STATUS = NF90_PUT_VAR(INCID, IVARID, ZTAB)
    DEALLOCATE(ZTAB)
  END IF
  IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))

END SUBROUTINE WRITE_HOR_COORD

SUBROUTINE WRITE_VER_COORD(TDIM,HLONGNAME,HSTDNAME,HCOMPNAME,PSHIFT,KBOUNDLOW,KBOUNDHIGH,PCOORDS)
  TYPE(DIMCDF), POINTER, INTENT(IN) :: TDIM
  CHARACTER(LEN=*),      INTENT(IN) :: HLONGNAME
  CHARACTER(LEN=*),      INTENT(IN) :: HSTDNAME
  CHARACTER(LEN=*),      INTENT(IN) :: HCOMPNAME
  REAL,                  INTENT(IN) :: PSHIFT
  INTEGER,               INTENT(IN) :: KBOUNDLOW
  INTEGER,               INTENT(IN) :: KBOUNDHIGH
  REAL,DIMENSION(:),     INTENT(IN) :: PCOORDS

  CHARACTER(LEN=64)             :: YRANGE
  CHARACTER(LEN=:),ALLOCATABLE  :: YVARNAME
  INTEGER                       :: IRESP
  INTEGER                       :: ISIZE
  INTEGER                       :: JI
  INTEGER(KIND=IDCDF_KIND)      :: IVARID
  INTEGER(KIND=IDCDF_KIND)      :: IVDIM
  INTEGER(KIND=IDCDF_KIND)      :: STATUS

  ISIZE = TDIM%LEN
  YVARNAME = TRIM(TDIM%NAME)
  IVDIM = TDIM%ID

  STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
  IF (STATUS /= NF90_NOERR) THEN
    ! Define the coordinate variable
    STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIM, IVARID)
    IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_DEF_VAR]')
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','WRITE_NC_COORDS_VAR',TRIM(YVARNAME)//' already defined')
  END IF

  ! Write metadata
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'long_name',HLONGNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'standard_name',HSTDNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'units','m')
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'axis','Z')
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'positive','up')
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_axis_shift',PSHIFT)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  WRITE(YRANGE,'( I0,":",I0 )') 1+KBOUNDLOW,ISIZE-KBOUNDHIGH
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_dynamic_range',TRIM(YRANGE))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  !
  IF (LSLEVE) THEN
    !Remark: ZS, ZSMT and ZTOP in the formula are the same for mass point or flux point
    STATUS = NF90_PUT_ATT(INCID, IVARID,'formula_terms','s: '//TRIM(YVARNAME)//                   &
                                        ' height: ZTOP oro_ls: ZSMT oro: ZS len1: LEN1 len2: LEN2')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'formula_definition','z(n,k,j,i)=s(k)'//                                      &
                          '+ oro_ls(j,i)*sinh((height/len1)**1.35-(s(k)/len1)**1.35)/sinh((s(k)/len1)**1.35)'//        &
                          '+(oro(j,i)-oro_ls(j,i))*sinh((height/len2)**1.35-(s(k)/len2)**1.35)/sinh((s(k)/len2)**1.35)')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  ELSE
    !Remark: ZS and ZTOP in the formula are the same for mass point or flux point
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'formula_terms','s: '//TRIM(YVARNAME)//' height: ZTOP orog: ZS')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'formula_definition','z(n,k,j,i)=s(k)*(height-orog(j,i))/height+orog(j,i)')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  ENDIF
  !
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'computed_standard_name',HCOMPNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))

  ! Write the data
  STATUS = NF90_PUT_VAR(INCID, IVARID, PCOORDS)
  IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))

END SUBROUTINE WRITE_VER_COORD

END SUBROUTINE IO_WRITE_COORDVAR_NC4


SUBROUTINE HANDLE_ERR(STATUS,LINE,TEXT,KRESP)
INTEGER(KIND=IDCDF_KIND),INTENT(IN)  :: STATUS
INTEGER,                 INTENT(IN)  :: LINE
CHARACTER(LEN=*),        INTENT(IN)  :: TEXT
INTEGER, OPTIONAL,       INTENT(OUT) :: KRESP

CHARACTER(LEN=6) :: YLINE

WRITE(YLINE,'( I6 )') LINE

! Don't stop (by default) the code when KRESP is present
! and ensure KRESP is a negative integer
IF (STATUS /= NF90_NOERR) THEN
  IF (PRESENT(KRESP)) THEN
    IF (STATUS < 0) THEN
      KRESP = STATUS
    ELSE IF (STATUS == 0) THEN
      KRESP = -1
    ELSE
      KRESP = -STATUS
    END IF
    CALL PRINT_MSG(NVERB_WARNING,'IO',TRIM(TEXT),'NetCDF error at line '//TRIM(YLINE)//': '//TRIM(NF90_STRERROR(STATUS)))
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO',TRIM(TEXT),'NetCDF error at line '//TRIM(YLINE)//': '//TRIM(NF90_STRERROR(STATUS)))
  END IF
END IF
END SUBROUTINE HANDLE_ERR

FUNCTION str_replace(hstr, hold, hnew)
CHARACTER(LEN=*) :: hstr, hold, hnew
CHARACTER(LEN=LEN_TRIM(hstr)+MAX(0,LEN(hnew)-LEN(hold))) :: str_replace

INTEGER :: pos

pos = INDEX(hstr,hold)
IF (pos /= 0) THEN
   str_replace = hstr(1:pos-1)//hnew//hstr(pos+LEN(hold):)
ELSE 
   str_replace = hstr 
END IF

END FUNCTION str_replace

SUBROUTINE IO_WRITE_HEADER_NC4(TPFILE)
!
USE MODD_IO_ll, ONLY: TFILEDATA
!
TYPE(TFILEDATA), INTENT(IN)  :: TPFILE ! File structure
!
INTEGER(KIND=IDCDF_KIND) :: ISTATUS
!
IF (TRIM(TPFILE%CFORMAT)/='NETCDF4' .AND. TRIM(TPFILE%CFORMAT)/='LFICDF4') RETURN
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_HEADER_NC4','called for file '//TRIM(TPFILE%CNAME))
!
IF (TPFILE%LMASTER)  THEN
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'Conventions', 'CF-1.7 COMODO-1.4')
  IF (ISTATUS /= NF90_NOERR) CALL HANDLE_ERR(ISTATUS,__LINE__,'IO_FILE_WRITE_HEADER[NF90_PUT_ATT]')

!title

!history

!institution

!source

!comment

!references
END IF
!
END SUBROUTINE IO_WRITE_HEADER_NC4


SUBROUTINE IO_WRITE_FIELD_ATTR_NC4(TPFIELD,KNCID,KVARID,HCALENDAR)
!
TYPE(TFIELDDATA),         INTENT(IN) :: TPFIELD
INTEGER(KIND=IDCDF_KIND), INTENT(IN) :: KNCID
INTEGER(KIND=IDCDF_KIND), INTENT(IN) :: KVARID
CHARACTER(LEN=*),OPTIONAL,INTENT(IN) :: HCALENDAR
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','called for field '//TRIM(TPFIELD%CMNHNAME))
!
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0 .AND. LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_ATTR_NC4','at least long_name or standard_name must be provided &
  &to respect CF-convention for variable '//TRIM(TPFIELD%CMNHNAME))
ENDIF
!
! GRID attribute definition
IF(TPFIELD%NGRID<0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%NGRID not set for variable '//TRIM(TPFIELD%CMNHNAME))
!Do not write GRID attribute if NGRID=0
  ELSE IF (TPFIELD%NGRID>0) THEN
  STATUS = NF90_PUT_ATT(KNCID, KVARID, 'GRID', TPFIELD%NGRID)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! COMMENT attribute definition
IF(LEN_TRIM(TPFIELD%CCOMMENT)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CCOMMENT not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'COMMENT', TRIM(TPFIELD%CCOMMENT))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Standard_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CSTDNAME not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'standard_name', TRIM(TPFIELD%CSTDNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Long_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CLONGNAME not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'long_name', TRIM(TPFIELD%CLONGNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Canonical units attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CUNITS)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CUNITS not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'units', TRIM(TPFIELD%CUNITS))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Calendar (CF convention)
IF(PRESENT(HCALENDAR)) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','CALENDAR provided for variable '//TRIM(TPFIELD%CMNHNAME))
  STATUS = NF90_PUT_ATT(KNCID, KVARID,'calendar', TRIM(HCALENDAR))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
END SUBROUTINE IO_WRITE_FIELD_ATTR_NC4

FUNCTION GETDIMCDF(TPFILE, KLEN, HDIMNAME)
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
CHARACTER(LEN=*), OPTIONAL :: HDIMNAME ! When provided don't search but
                                       ! simply create with name HDIMNAME
TYPE(DIMCDF), POINTER   :: GETDIMCDF

TYPE(DIMCDF), POINTER :: TMP
INTEGER               :: COUNT
CHARACTER(LEN=7)      :: YSUFFIX
CHARACTER(LEN=8)      :: YDIMNAME
CHARACTER(LEN=20)     :: YLEN
INTEGER(KIND=IDCDF_KIND) :: STATUS
LOGICAL                  :: GCHKLEN !Check if KLEN is valid
TYPE(IOCDF), POINTER     :: PIOCDF

CALL PRINT_MSG(NVERB_DEBUG,'IO','GETDIMCDF','called')

PIOCDF => TPFILE%TNCDIMS

GCHKLEN = .TRUE.
!Do not check KLEN if 'time' (because NF90_UNLIMITED = 0)
IF (PRESENT(HDIMNAME)) THEN
  IF (TRIM(HDIMNAME)=='time') THEN
    GCHKLEN = .FALSE.
  END IF
END IF

IF (GCHKLEN .AND. KLEN < 1) THEN
  WRITE(YLEN,*) KLEN
  CALL PRINT_MSG(NVERB_FATAL,'IO','GETDIMCDF','KLEN='//TRIM(YLEN))
END IF

IF (PRESENT(HDIMNAME)) THEN
   NULLIFY(TMP)
   YDIMNAME = TRIM(HDIMNAME)
ELSE
   ! Search dimension with KLEN length
   COUNT = 1
   TMP  => PIOCDF%DIMLIST
   DO WHILE(ASSOCIATED(TMP))
      IF (TMP%LEN == KLEN .AND. TMP%NAME /= 'STRLEN') EXIT
      TMP=>TMP%NEXT
      COUNT = COUNT+1
   END DO
   WRITE(YSUFFIX,'(i7)') KLEN
   YDIMNAME = 'D'//ADJUSTL(YSUFFIX)
END IF

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = YDIMNAME
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(TPFILE%NNCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETDIMCDF[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT       => PIOCDF%DIMLIST
   PIOCDF%DIMLIST => TMP
CALL PRINT_MSG(NVERB_DEBUG,'IO','GETDIMCDF','new dimension: '//TRIM(TMP%NAME))
END IF

GETDIMCDF => TMP

END FUNCTION GETDIMCDF

FUNCTION GETSTRDIMID(TPFILE,KLEN)
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
INTEGER(KIND=IDCDF_KIND)            :: GETSTRDIMID

TYPE(DIMCDF), POINTER :: TMP
CHARACTER(LEN=7)      :: YSUFFIX
CHARACTER(LEN=8)      :: YDIMNAME
CHARACTER(LEN=20)     :: YLEN
INTEGER(KIND=IDCDF_KIND) :: STATUS

CALL PRINT_MSG(NVERB_DEBUG,'IO','GETSTRDIMID','called')

IF (KLEN < 1) THEN
  WRITE(YLEN,*) KLEN
  CALL PRINT_MSG(NVERB_FATAL,'IO','GETSTRDIMID','KLEN='//TRIM(YLEN))
END IF

! Search string dimension with KLEN length
TMP  => TPFILE%TNCDIMS%DIMSTR
DO WHILE(ASSOCIATED(TMP))
   IF (TMP%LEN == KLEN) EXIT
   TMP=>TMP%NEXT
END DO
WRITE(YSUFFIX,'(i7)') KLEN
YDIMNAME = 'S'//ADJUSTL(YSUFFIX)

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = YDIMNAME
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(TPFILE%NNCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETSTRDIMID[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT      => TPFILE%TNCDIMS%DIMSTR
   TPFILE%TNCDIMS%DIMSTR => TMP
END IF

GETSTRDIMID = TMP%ID

END FUNCTION GETSTRDIMID

SUBROUTINE FILLVDIMS(TPFILE, TPFIELD, KSHAPE, KVDIMS)
TYPE(TFILEDATA),                      INTENT(IN)  :: TPFILE
TYPE(TFIELDDATA),                     INTENT(IN)  :: TPFIELD
INTEGER(KIND=IDCDF_KIND),DIMENSION(:),INTENT(IN)  :: KSHAPE
INTEGER(KIND=IDCDF_KIND),DIMENSION(:),INTENT(OUT) :: KVDIMS
!
INTEGER               :: IGRID
INTEGER               :: JI
CHARACTER(LEN=32)     :: YINT
CHARACTER(LEN=2)      :: YDIR
TYPE(DIMCDF), POINTER :: PTDIM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','FILLVDIMS','called for '//TRIM(TPFIELD%CMNHNAME))
!
IF (SIZE(KSHAPE) < 1) CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','empty KSHAPE')
!
IGRID  =  TPFIELD%NGRID
YDIR   =  TPFIELD%CDIR
!
IF(SIZE(KSHAPE)/=TPFIELD%NDIMS) THEN
  WRITE(YINT,'( I0,"/",I0 )') SIZE(KSHAPE),TPFIELD%NDIMS
  CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','SIZE(KSHAPE)/=TPFIELD%NDIMS ('//TRIM(YINT)//') for field '//TRIM(TPFIELD%CMNHNAME))
END IF
!
IF(IGRID<0 .OR. IGRID>4) THEN
  WRITE(YINT,'( I0 )') IGRID
  CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','invalid NGRID ('//TRIM(YINT)//') for field '//TRIM(TPFIELD%CMNHNAME))
END IF
!
IF(IGRID==0 .AND. YDIR/='--' .AND. YDIR/=''  ) THEN
  CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','invalid YDIR ('//TRIM(YDIR)//') with NGRID=0 for field '//TRIM(TPFIELD%CMNHNAME))
END IF
!
DO JI=1,TPFIELD%NDIMS
  IF (JI == 1) THEN
    IF ( (YDIR == 'XX' .OR. YDIR == 'XY') .AND. KSHAPE(1)==NCOORDID(1,IGRID)%LEN) THEN
      KVDIMS(1) = NCOORDID(1,IGRID)%ID
    ELSE IF ( YDIR == 'YY'                .AND. KSHAPE(1)==NCOORDID(1,IGRID)%LEN) THEN
      KVDIMS(1) = NCOORDID(2,IGRID)%ID
    ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(1)); KVDIMS(1) = PTDIM%ID
    END IF
  ELSE IF (JI == 2) THEN
    IF ( YDIR == 'XY' .AND. KSHAPE(2)==NCOORDID(2,IGRID)%LEN) THEN
      KVDIMS(2) = NCOORDID(2,IGRID)%ID
    ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(2)); KVDIMS(2) = PTDIM%ID
    END IF
  ELSE IF (JI == 3) THEN
    IF ( YDIR == 'XY' .AND. KSHAPE(3)==NCOORDID(3,IGRID)%LEN) THEN
      KVDIMS(3) = NCOORDID(3,IGRID)%ID
    ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(3)); KVDIMS(3) = PTDIM%ID
    END IF
  ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(JI)); KVDIMS(JI) = PTDIM%ID
  END IF
END DO
!
END SUBROUTINE FILLVDIMS


SUBROUTINE IO_WRITE_FIELD_NC4_X0(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,                  INTENT(IN) :: PFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X0


SUBROUTINE IO_WRITE_FIELD_NC4_X1(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:),     INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X1


SUBROUTINE IO_WRITE_FIELD_NC4_X2(TPFILE,TPFIELD,PFIELD,KRESP,KVERTLEVEL,KZFILE)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:),   INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
INTEGER,OPTIONAL,      INTENT(IN) :: KVERTLEVEL ! Number of the vertical level (needed for Z-level splitted files)
INTEGER,OPTIONAL,      INTENT(IN) :: KZFILE     ! Number of the Z-level splitted file
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=4)         :: YSUFFIX
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4) :: YTMP,YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
TYPE(TFILEDATA),POINTER  :: TZFILE
!
IRESP = 0
!
IF (PRESENT(KVERTLEVEL)) THEN
  WRITE(YSUFFIX,'(I4.4)') KVERTLEVEL
  IF (.NOT.PRESENT(KZFILE)) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_WRITE_FIELD_NC4_X2','KZFILE argument not provided')
    RETURN
  END IF
  YTMP = TRIM(TPFIELD%CMNHNAME)//YSUFFIX
  IF (KZFILE>TPFILE%NSUBFILES_IOZ) CALL PRINT_MSG(NVERB_FATAL,'IO','IO_WRITE_FIELD_NC4_X2','KZFILE value too high')
  TZFILE => TPFILE%TFILES_IOZ(KZFILE)%TFILE
ELSE
  YTMP = TRIM(TPFIELD%CMNHNAME)
  TZFILE => TPFILE
ENDIF
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': writing '//TRIM(YTMP))
!
! Get the Netcdf file ID
INCID = TZFILE%NNCID

CALL CLEANMNHNAME(YTMP,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X2','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TZFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TZFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TZFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X2


SUBROUTINE IO_WRITE_FIELD_NC4_X3(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X3','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X3


SUBROUTINE IO_WRITE_FIELD_NC4_X4(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),           INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),          INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:),   INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                   INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X4','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X4


SUBROUTINE IO_WRITE_FIELD_NC4_X5(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),           INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),          INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                   INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X5','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X5


SUBROUTINE IO_WRITE_FIELD_NC4_X6(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),             INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),            INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                     INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(PFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X6','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X6


SUBROUTINE IO_WRITE_FIELD_NC4_N0(TPFILE,TPFIELD,KFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
#if 0
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
#endif
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
INTEGER,               INTENT(IN) :: KFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

!
! Use IMAX, JMAX, KMAX to define DIM_NI, DIM_NJ, DIM_LEVEL
! /!\ Can only work if IMAX, JMAX or KMAX are written before any array
!
#if 0
IF (YVARNAME == 'IMAX' .AND. .NOT. ASSOCIATED(TPFILE%TNCDIMS%DIM_NI)) TPFILE%TNCDIMS%DIM_NI=>GETDIMCDF(TPFILE%TNCDIMS,KFIELD+2*JPHEXT,'X')
IF (YVARNAME == 'JMAX' .AND. .NOT. ASSOCIATED(TPFILE%TNCDIMS%DIM_NJ)) THEN
   IF (LPACK .AND. L2D) THEN
      TPFILE%TNCDIMS%DIM_NJ=>GETDIMCDF(TPFILE, 1,'Y')
   ELSE
      TPFILE%TNCDIMS%DIM_NJ=>GETDIMCDF(TPFILE, KFIELD+2*JPHEXT, 'Y')
   END IF
END IF
#endif
IF (YVARNAME == 'KMAX' .AND. .NOT. ASSOCIATED(TPFILE%TNCDIMS%DIM_LEVEL)) &
  TPFILE%TNCDIMS%DIM_LEVEL=>GETDIMCDF(TPFILE,INT(KFIELD+2*JPVEXT,KIND=IDCDF_KIND),'Z')
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N0


SUBROUTINE IO_WRITE_FIELD_NC4_N1(TPFILE,TPFIELD,KFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
#if 0
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
#endif
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
INTEGER, DIMENSION(:), INTENT(IN) :: KFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N1[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N1


SUBROUTINE IO_WRITE_FIELD_NC4_N2(TPFILE,TPFIELD,KFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
INTEGER,DIMENSION(:,:),INTENT(IN) :: KFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
IRESP = 0
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N2','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N2

SUBROUTINE IO_WRITE_FIELD_NC4_N3(TPFILE,TPFIELD,KFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,  INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
INTEGER,DIMENSION(:,:,:),INTENT(IN) :: KFIELD   ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(KFIELD))) :: IVDIMS
INTEGER                  :: IRESP
!
IRESP = 0
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N3',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N3','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
#ifndef MNH_INT8
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N3

SUBROUTINE IO_WRITE_FIELD_NC4_L0(TPFILE,TPFIELD,OFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
LOGICAL,               INTENT(IN) :: OFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER                  :: IFIELD
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   ! Use of NF90_INT1 datatype (=NF90_BYTE) that is enough to store a boolean
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT1, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

!Convert LOGICAL to INTEGER (LOGICAL format not supported by netCDF files)
IF (OFIELD) THEN
  IFIELD = 1
ELSE
  IFIELD = 0
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, IFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_L0

SUBROUTINE IO_WRITE_FIELD_NC4_L1(TPFILE,TPFIELD,OFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
LOGICAL, DIMENSION(:), INTENT(IN) :: OFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER, DIMENSION(SIZE(OFIELD))                         :: IFIELD
INTEGER(KIND=IDCDF_KIND)                                 :: STATUS
INTEGER(KIND=IDCDF_KIND)                                 :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))                     :: YVARNAME
INTEGER(KIND=IDCDF_KIND)                                 :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(SIZE(SHAPE(OFIELD))) :: IVDIMS
INTEGER                                                  :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(OFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_L1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(OFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   ! Use of NF90_INT1 datatype (=NF90_BYTE) that is enough to store a boolean
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT1, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L1[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

!Convert LOGICAL to INTEGER (LOGICAL format not supported by netCDF files)
WHERE (OFIELD)
  IFIELD = 1
ELSEWHERE
  IFIELD = 0
END WHERE

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, IFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_L1


SUBROUTINE IO_WRITE_FIELD_NC4_C0(TPFILE,TPFIELD,HFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
CHARACTER(LEN=*),      INTENT(IN) :: HFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER,PARAMETER :: IMULT = 16
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
INTEGER                                :: IRESP, ILEN
CHARACTER(LEN=:),ALLOCATABLE           :: YFIELD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0

!Store the character string in a string of a size multiple of IMULT
!This is done to limit the number of dimensions in the netCDF file
ILEN = ((LEN_TRIM(HFIELD)+IMULT-1)/IMULT)*IMULT
!If the string is empty, create it anyway with a non-zero size (to prevent problems later)
IF (ILEN==0) ILEN = IMULT

! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(TPFILE,INT(ILEN,KIND=IDCDF_KIND))
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

ALLOCATE(CHARACTER(LEN=ILEN)::YFIELD)
YFIELD(:)=TRIM(HFIELD) !Warning: keep (:) to prevent F2003 automatic reallocation
YFIELD(LEN_TRIM(HFIELD)+1:)=' '
! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, YFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
DEALLOCATE(YFIELD)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_C0

SUBROUTINE IO_WRITE_FIELD_NC4_C1(TPFILE,TPFIELD,HFIELD,KRESP)
!
TYPE(TFILEDATA),              INTENT(IN)  :: TPFILE
TYPE(TFIELDDATA),             INTENT(IN)  :: TPFIELD
CHARACTER(LEN=*),DIMENSION(:),INTENT(IN)  :: HFIELD
INTEGER,                      INTENT(OUT) :: KRESP
!
INTEGER(KIND=IDCDF_KIND),PARAMETER :: IONE = 1
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(2) :: IVDIMS
INTEGER(KIND=IDCDF_KIND)               :: ILEN, ISIZE
INTEGER                                :: IRESP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_C1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0

ILEN  = LEN(HFIELD)
ISIZE = SIZE(HFIELD)

! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(TPFILE,ILEN)
   CALL FILLVDIMS(TPFILE, TPFIELD, (/ISIZE/), IVDIMS(2:2))
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C1[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_C1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, HFIELD(1:ISIZE)(1:ILEN), START=(/IONE,IONE/), COUNT=(/ILEN,ISIZE/))
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_C1


SUBROUTINE IO_WRITE_FIELD_NC4_T0(TPFILE,TPFIELD,TPDATA,KRESP)
!
USE MODD_TYPE_DATE
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE (DATE_TIME),      INTENT(IN) :: TPDATA
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
INTEGER                                :: IRESP
INTEGER, DIMENSION(3)                  :: ITDATE    ! date array
TYPE(TFIELDDATA)                       :: TZFIELD
CHARACTER(LEN=40)                      :: YUNITS
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
!
TZFIELD = TPFIELD
!
ITDATE(1)=TPDATA%TDATE%YEAR
ITDATE(2)=TPDATA%TDATE%MONTH
ITDATE(3)=TPDATA%TDATE%DAY
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
TZFIELD%CMNHNAME = TRIM(YVARNAME)
WRITE(YUNITS,'( "seconds since ",I4.4,"-",I2.2,"-",I2.2," 00:00:00 +0:00" )') ITDATE(1),ITDATE(2),ITDATE(3)
TZFIELD%CUNITS = TRIM(YUNITS)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TZFIELD,INCID,IVARID,HCALENDAR='standard')
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, TPDATA%TIME)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF (IRESP/=0) THEN
  KRESP = IRESP
  RETURN
END IF

#if 0
!This part is to keep backward compatibility with MesoNH files
!but date/time is not conform to CF convention
!
! Write date
!
TZFIELD%CMNHNAME  = TRIM(YVARNAME)//'__TDATE'
TZFIELD%CLONGNAME = TRIM(TPFIELD%CLONGNAME)//'%TDATE'
TZFIELD%CUNITS    = ''
TZFIELD%CCOMMENT  = 'YYYYMMDD'

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, TZFIELD%CMNHNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(ITDATE),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, TZFIELD%CMNHNAME, NF90_INT, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TZFIELD,INCID,IVARID)
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(TZFIELD%CMNHNAME)//' already defined')
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, ITDATE)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_PUT_VAR] '//TRIM(TZFIELD%CMNHNAME),IRESP)
 
IF (IRESP/=0) THEN
  KRESP = IRESP
  RETURN
END IF
!
! Write time
!
TZFIELD%CMNHNAME  = TRIM(YVARNAME)//'__TIME'
TZFIELD%CLONGNAME = TRIM(TPFIELD%CLONGNAME)//'%TIME'
TZFIELD%CUNITS    = 's'
TZFIELD%CCOMMENT  = 'SECONDS'

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, TZFIELD%CMNHNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
   STATUS = NF90_DEF_VAR(INCID, TZFIELD%CMNHNAME, NF90_DOUBLE, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TZFIELD,INCID,IVARID)
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(TZFIELD%CMNHNAME)//' already defined')
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, TPDATA%TIME)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_PUT_VAR] '//TRIM(TZFIELD%CMNHNAME),IRESP)
#endif

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_T0
!
!
! Here come the NetCDF READ routines
!
!
SUBROUTINE IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,KNCID,KVARID,KRESP,HCALENDAR)
!
TYPE(TFIELDDATA),         INTENT(INOUT) :: TPFIELD
INTEGER(KIND=IDCDF_KIND), INTENT(IN)    :: KNCID
INTEGER(KIND=IDCDF_KIND), INTENT(IN)    :: KVARID
INTEGER,                  INTENT(OUT)   :: KRESP  ! return-code
CHARACTER(LEN=*),OPTIONAL,INTENT(IN)    :: HCALENDAR
!
INTEGER                      :: ILEN
INTEGER                      :: IGRID
INTEGER(KIND=IDCDF_KIND)     :: STATUS
CHARACTER(LEN=12)            :: YVAL_FILE, YVAL_MEM
CHARACTER(LEN=:),ALLOCATABLE :: YVALUE
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','called for field '//TRIM(TPFIELD%CMNHNAME))
!
KRESP = 0
!
! GRID
!
STATUS = NF90_GET_ATT(KNCID,KVARID,'GRID',IGRID)
IF (STATUS == NF90_NOERR) THEN
  IF (IGRID/=TPFIELD%NGRID) THEN
    WRITE(YVAL_FILE,'(I12)') IGRID
    WRITE(YVAL_MEM, '(I12)') TPFIELD%NGRID
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected GRID     value ('//TRIM(ADJUSTL(YVAL_MEM))// &
                   ') is different than found in file ('//TRIM(ADJUSTL(YVAL_FILE))//') for variable '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%NGRID = IGRID
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected GRID found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ENDIF
ELSE !no GRID
  IF (TPFIELD%NGRID==0 .OR. TPFIELD%NGRID==-1) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no GRID (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected GRID but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
ENDIF
!
! COMMENT
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'COMMENT', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'COMMENT', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CCOMMENT)) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected COMMENT ('//TRIM(TPFIELD%CCOMMENT)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CCOMMENT=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected COMMENT  found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no COMMENT
  IF (LEN_TRIM(TPFIELD%CCOMMENT)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no COMMENT (as expected) in file for field ' &
                                                                //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected COMMENT but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! STDNAME
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'standard_name', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'standard_name', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CSTDNAME)) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected STDNAME  ('//TRIM(TPFIELD%CSTDNAME)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CSTDNAME=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected STDNAME  found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no STDNAME
  IF (LEN_TRIM(TPFIELD%CSTDNAME)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no STDNAME (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected STDNAME but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! LONGNAME
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'long_name', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'long_name', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CLONGNAME)) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected LONGNAME ('//TRIM(TPFIELD%CLONGNAME)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CLONGNAME=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected LONGNAME found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no LONGNAME
  IF (LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no LONGNAME (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected LONGNAME but not found in file for field ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! UNITS
!
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'units', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'units', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CUNITS)) THEN
    IF(.NOT.PRESENT(HCALENDAR)) THEN
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS ('//TRIM(TPFIELD%CUNITS)// &
                     ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
      KRESP = -111 !Used later to broadcast modified metadata
    ELSE
      CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','UNITS found in file for field ' &
                                                                     //TRIM(TPFIELD%CMNHNAME)//' (will be analysed later)')
    END IF
    TPFIELD%CUNITS=TRIM(YVALUE)
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS    found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no UNITS
  IF (LEN_TRIM(TPFIELD%CUNITS)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','no UNITS (as expected) in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  ELSE
    IF(.NOT.PRESENT(HCALENDAR)) THEN
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS but not found in file for field ' &
                                                                       //TRIM(TPFIELD%CMNHNAME))
    ELSE
      CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected UNITS but not found in file for field ' &
                                                                     //TRIM(TPFIELD%CMNHNAME))
      KRESP = -3
    END IF
  END IF
END IF
!
! CALENDAR
!
IF(PRESENT(HCALENDAR)) THEN
STATUS = NF90_INQUIRE_ATTRIBUTE(KNCID, KVARID, 'calendar', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(KNCID, KVARID, 'calendar', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(HCALENDAR)) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected CALENDAR ('//TRIM(HCALENDAR)// &
                   ') is different than found ('//TRIM(YVALUE)//')in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected CALENDAR found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no CALENDAR
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4','expected CALENDAR but not found in file for field ' &
                                                                   //TRIM(TPFIELD%CMNHNAME))
END IF
ENDIF
!
END SUBROUTINE IO_READ_CHECK_FIELD_ATTR_NC4


SUBROUTINE IO_READ_FIELD_NC4_X0(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,             INTENT(OUT)   :: PFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 0 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Read variable
  STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF
  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong size or type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X0


SUBROUTINE IO_READ_FIELD_NC4_X1(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:),INTENT(OUT)   :: PFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 1 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(PFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X1


SUBROUTINE IO_READ_FIELD_NC4_X2(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),    INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),   INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:),INTENT(OUT)   :: PFIELD
INTEGER,            INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND),DIMENSION(3) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Treat special case of a degenerated 3D array (3rd dimension size is 1)
IF (IDIMS==3) THEN
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  IF (IDIMLEN(3)==1) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)// &
                   ': reading 3D array with degenerated third dimension in 2D array for '//TRIM(YVARNAME))
    IDIMS = 2
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': wrong number of dimensions for '//TRIM(YVARNAME))
  END IF
END IF

IF (IDIMS == 2 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X2


SUBROUTINE IO_READ_FIELD_NC4_X3(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),      INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),     INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,              INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(3)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 3 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. IDIMLEN(3) == SIZE(PFIELD,3)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X3


SUBROUTINE IO_READ_FIELD_NC4_X4(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),        INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),       INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(4)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 4 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X4


SUBROUTINE IO_READ_FIELD_NC4_X5(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),          INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),         INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                  INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(5)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 5 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(5), LEN=IDIMLEN(5))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4) .AND. &
       IDIMLEN(5) == SIZE(PFIELD,5) ) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X5


SUBROUTINE IO_READ_FIELD_NC4_X6(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),            INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),           INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                    INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(6)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 6 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(5), LEN=IDIMLEN(5))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(6), LEN=IDIMLEN(6))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4) .AND. &
       IDIMLEN(5) == SIZE(PFIELD,5) .AND. IDIMLEN(6) == SIZE(PFIELD,6) ) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X6


SUBROUTINE IO_READ_FIELD_NC4_N0(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
INTEGER,          INTENT(OUT)   :: KFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

#ifndef MNH_INT8
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT) ) THEN
#else
!Can read either 4 or 8 byte integers
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT) ) THEN
#endif
   ! Read variable
   STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
   IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
   END IF
   ! Read and check attributes of variable
   CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N0


SUBROUTINE IO_READ_FIELD_NC4_N1(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),         INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),        INTENT(INOUT) :: TPFIELD
INTEGER, DIMENSION(:),   INTENT(OUT)   :: KFIELD
INTEGER,                 INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!NF90_INT1 is for the case a boolean was written
#ifndef MNH_INT8
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT .OR. ITYPE == NF90_INT1) ) THEN
#else
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT1) ) THEN
#endif
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(KFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N1


SUBROUTINE IO_READ_FIELD_NC4_N2(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),         INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),        INTENT(INOUT) :: TPFIELD
INTEGER, DIMENSION(:,:), INTENT(OUT)   :: KFIELD
INTEGER,                 INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND),DIMENSION(3) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Treat special case of a degenerated 3D array (3rd dimension size is 1)
IF (IDIMS==3) THEN
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  IF (IDIMLEN(3)==1) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)// &
                   ': reading 3D array with degenerated third dimension in 2D array for '//TRIM(YVARNAME))
    IDIMS = 2
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': wrong number of dimensions for '//TRIM(YVARNAME))
  END IF
END IF

!NF90_INT1 is for the case a boolean was written
#ifndef MNH_INT8
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. (ITYPE == NF90_INT .OR. ITYPE == NF90_INT1) ) THEN
#else
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. (ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT1) ) THEN
#endif
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(KFIELD,1) .AND. IDIMLEN(2) == SIZE(KFIELD,2)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N2

SUBROUTINE IO_READ_FIELD_NC4_L0(TPFILE, TPFIELD, OFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
LOGICAL,          INTENT(OUT)   :: OFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP
INTEGER                  :: IFIELD

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!NF90_INT1 is for the case a boolean was written
!Accept also INT and INT64 (for backward compatibility)
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT1 .OR. ITYPE == NF90_INT .OR. ITYPE == NF90_INT64)  ) THEN
  ! Read variable
  STATUS = NF90_GET_VAR(INCID, IVARID, IFIELD)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF

  IF (IFIELD==0) THEN
    OFIELD = .FALSE.
  ELSE IF (IFIELD==1) THEN
    OFIELD = .TRUE.
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L0',TRIM(TPFILE%CNAME)//': invalid value in file for ' &
                                                           //TRIM(TPFIELD%CMNHNAME))
    OFIELD = .TRUE.
    IRESP = -112
  END IF

  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong size or type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_L0


SUBROUTINE IO_READ_FIELD_NC4_L1(TPFILE, TPFIELD, OFIELD, KRESP)
TYPE(TFILEDATA),     INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),    INTENT(INOUT) :: TPFIELD
LOGICAL,DIMENSION(:),INTENT(OUT)   :: OFIELD
INTEGER,             INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP
INTEGER                  :: JI
INTEGER,DIMENSION(SIZE(OFIELD)) :: IFIELD

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!NF90_INT1 is for the case a boolean was written
!Accept also INT and INT64 (for backward compatibility)
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT1 .OR. ITYPE == NF90_INT .OR. ITYPE == NF90_INT64)  ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(OFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, IFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF

    DO JI=1,IDIMLEN
      IF (IFIELD(JI)==0) THEN
        OFIELD(JI) = .FALSE.
      ELSE IF (IFIELD(JI)==1) THEN
        OFIELD(JI) = .TRUE.
      ELSE
        OFIELD(JI) = .TRUE.
        IRESP = -112
      END IF
    END DO
    IF (IRESP==-112) THEN
      CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L1',TRIM(TPFILE%CNAME)//': invalid value(s) in file for ' &
                                                             //TRIM(TPFIELD%CMNHNAME))
    END IF

    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_L1


SUBROUTINE IO_READ_FIELD_NC4_C0(TPFILE, TPFIELD, HFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
CHARACTER(LEN=*), INTENT(OUT)   :: HFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)     :: STATUS
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: IVARID
INTEGER(KIND=IDCDF_KIND)     :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)     :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)            :: YVARNAME
CHARACTER(LEN=:),ALLOCATABLE :: YSTR
INTEGER(KIND=IDCDF_KIND)     :: IDIMLEN
INTEGER                      :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 1 .AND. (ITYPE == NF90_CHAR) ) THEN
   ! Check size of variable before reading
   STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
   !
   ALLOCATE(CHARACTER(LEN=IDIMLEN)::YSTR)
   ! Read variable
   STATUS = NF90_GET_VAR(INCID, IVARID, YSTR)
   IF (STATUS /= NF90_NOERR) THEN
     CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
     GOTO 1000
   END IF
   IF (LEN_TRIM(YSTR) > LEN(HFIELD)) &
     CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' truncated')
   HFIELD = TRIM(YSTR)
   DEALLOCATE(YSTR)

   ! Read and check attributes of variable
   CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP)
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_C0

SUBROUTINE IO_READ_FIELD_NC4_T0(TPFILE, TPFIELD, TPDATA, KRESP)

USE MODD_TYPE_DATE

TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
TYPE (DATE_TIME), INTENT(OUT)   :: TPDATA
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)     :: STATUS
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: IVARID
INTEGER(KIND=IDCDF_KIND)     :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)     :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)            :: YVARNAME
CHARACTER(LEN=:),ALLOCATABLE :: YSTR
INTEGER(KIND=IDCDF_KIND)     :: IDIMLEN
INTEGER                      :: IDX,IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_T0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_T0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 0 .AND. ITYPE == NF90_DOUBLE) THEN
  ! Read time
  STATUS = NF90_GET_VAR(INCID, IVARID, TPDATA%TIME)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF
  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFIELD,INCID,IVARID,IRESP,HCALENDAR='standard')
  ! Extract date from UNITS
  IDX =  INDEX(TPFIELD%CUNITS,'since ')
  READ(TPFIELD%CUNITS(IDX+6 :IDX+9), '( I4.4 )') TPDATA%TDATE%YEAR
  READ(TPFIELD%CUNITS(IDX+11:IDX+12),'( I2.2 )') TPDATA%TDATE%MONTH
  READ(TPFIELD%CUNITS(IDX+14:IDX+15),'( I2.2 )') TPDATA%TDATE%DAY
  ! Simple check (should catch most errors)
  IF ( TPDATA%TDATE%DAY<1 .OR. TPDATA%TDATE%DAY>31 .OR. TPDATA%TDATE%MONTH<1 .OR. TPDATA%TDATE%MONTH>12 ) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' read date is invalid')
    IRESP = -3
  END IF
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_T0

END MODULE MODE_NETCDF

#else
!
! External dummy subroutines
!
SUBROUTINE IO_WRITE_FIELD_NC4(A,B,C,D)
INTEGER :: A,B,C,D
PRINT *, 'IO_WRITE_FIELD_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_FIELD_NC4

SUBROUTINE IO_READ_FIELD_NC4(A,B,C,D)
INTEGER :: A,B,C,D
PRINT *, 'IO_READ_FIELD_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_READ_FIELD_NC4

SUBROUTINE IO_WRITE_HEADER_NC4(A,B)
INTEGER :: A,B
PRINT *, 'IO_WRITE_HEADER_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_HEADER_NC4

SUBROUTINE CLEANIOCDF(A)
INTEGER :: A
PRINT *, 'CLEANIOCDF empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE CLEANIOCDF

#endif
