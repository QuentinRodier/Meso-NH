!MNH_LIC Copyright 1994-2018 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
!  Modifications:
!    P. Wautelet : may 2016   : use NetCDF Fortran module
!    J.Escobar   : 14/12/2017 : Correction for MNH_INT=8
!  Philippe Wautelet: 05/2016-04/2018: new data structures and calls for I/O
!-----------------------------------------------------------------
#if defined(MNH_IOCDF4)
MODULE MODE_NETCDF
USE MODD_NETCDF
USE NETCDF
USE MODD_IO_ll
USE MODE_FIELD, ONLY : TFIELDDATA
USE MODE_MSG

IMPLICIT NONE 

PRIVATE

INTEGER(KIND=IDCDF_KIND),PARAMETER :: SHUFFLE = 1 !Set to 1 for (usually) better compression
INTEGER(KIND=IDCDF_KIND),PARAMETER :: DEFLATE = 1

INTEGER,PARAMETER :: NSTRINGCHUNKSIZE = 16 !Dimension of the chunks of strings
                                           !(to limit the number of dimensions for strings)

INTERFACE IO_WRITE_FIELD_NC4
   MODULE PROCEDURE IO_WRITE_FIELD_NC4_X0,IO_WRITE_FIELD_NC4_X1, &
                    IO_WRITE_FIELD_NC4_X2,IO_WRITE_FIELD_NC4_X3, &
                    IO_WRITE_FIELD_NC4_X4,IO_WRITE_FIELD_NC4_X5, &
                    IO_WRITE_FIELD_NC4_X6,                       &
                    IO_WRITE_FIELD_NC4_N0,IO_WRITE_FIELD_NC4_N1, &
                    IO_WRITE_FIELD_NC4_N2,IO_WRITE_FIELD_NC4_N3, &
                    IO_WRITE_FIELD_NC4_L0,IO_WRITE_FIELD_NC4_L1, &
                    IO_WRITE_FIELD_NC4_C0,IO_WRITE_FIELD_NC4_C1, &
                    IO_WRITE_FIELD_NC4_T0
END INTERFACE IO_WRITE_FIELD_NC4

INTERFACE IO_READ_FIELD_NC4
   MODULE PROCEDURE IO_READ_FIELD_NC4_X0,IO_READ_FIELD_NC4_X1, &
                    IO_READ_FIELD_NC4_X2,IO_READ_FIELD_NC4_X3, &
                    IO_READ_FIELD_NC4_X4,IO_READ_FIELD_NC4_X5, &
                    IO_READ_FIELD_NC4_X6,                      &
                    IO_READ_FIELD_NC4_N0,IO_READ_FIELD_NC4_N1, &
                    IO_READ_FIELD_NC4_N2,                      &
                    IO_READ_FIELD_NC4_L0,IO_READ_FIELD_NC4_L1, &
                    IO_READ_FIELD_NC4_C0,                      &
                    IO_READ_FIELD_NC4_T0
END INTERFACE IO_READ_FIELD_NC4

! Public from module netcdf
PUBLIC NF90_CLOSE,NF90_OPEN,NF90_CREATE,                                &
       NF90_NOWRITE,NF90_CLOBBER,NF90_NETCDF4,NF90_NOERR,NF90_STRERROR, &
       NF90_FILL_REAL,NF90_INQUIRE
! Public from this module :
PUBLIC GETDIMCDF,NEWIOCDF,CLEANIOCDF,                           &
       IO_GUESS_DIMIDS_NC4,IO_FIND_DIM_BYNAME_NC4,              &
       IO_SET_KNOWNDIMS_NC4,IO_WRITE_COORDVAR_NC4,              &
       IO_WRITE_FIELD_NC4,IO_READ_FIELD_NC4,IO_WRITE_HEADER_NC4

CONTAINS

SUBROUTINE CLEANMNHNAME(HINNAME,HOUTNAME)
  CHARACTER(LEN=*),INTENT(IN)  :: HINNAME
  CHARACTER(LEN=*),INTENT(OUT) :: HOUTNAME

  ! NetCDF var names can't contain '%' nor '.'
  ! CF convention allows only letters, digits and underscores
  HOUTNAME = str_replace(HINNAME,  '%', '__')
  HOUTNAME = str_replace(HOUTNAME, '.', '___')
END SUBROUTINE

FUNCTION NEWIOCDF()
TYPE(IOCDF), POINTER :: NEWIOCDF
TYPE(IOCDF), POINTER :: TZIOCDF
INTEGER              :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','NEWIOCDF','called')

ALLOCATE(TZIOCDF, STAT=IRESP)
IF (IRESP > 0) THEN 
  CALL PRINT_MSG(NVERB_FATAL,'IO','NEWIOCDF','memory allocation error')
  STOP
END IF

NEWIOCDF=>TZIOCDF

END FUNCTION NEWIOCDF

SUBROUTINE CLEANIOCDF(PIOCDF)
TYPE(IOCDF),  POINTER :: PIOCDF

INTEGER(KIND=IDCDF_KIND) :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','CLEANIOCDF','called')

! Clean DIMLIST and DIMSTR
CALL CLEANLIST(PIOCDF%DIMLIST)
CALL CLEANLIST(PIOCDF%DIMSTR)
! Then free iocdf
DEALLOCATE(PIOCDF)

CONTAINS

SUBROUTINE CLEANLIST(PLIST)
TYPE(DIMCDF), POINTER :: PLIST,TZDIMCUR, TZDIMNEXT    

TZDIMCUR  => PLIST
DO WHILE(ASSOCIATED(TZDIMCUR))
   TZDIMNEXT => TZDIMCUR%NEXT
   DEALLOCATE(TZDIMCUR)
   TZDIMCUR => TZDIMNEXT
END DO

END SUBROUTINE CLEANLIST
  
END SUBROUTINE CLEANIOCDF


SUBROUTINE IO_SET_KNOWNDIMS_NC4(TPFILE,HPROGRAM_ORIG)

USE MODD_CONF,          ONLY: CPROGRAM
USE MODD_CONF_n,        ONLY: CSTORAGE_TYPE
USE MODD_DIM_n,         ONLY: NIMAX_ll, NJMAX_ll, NKMAX
USE MODD_PARAMETERS_ll, ONLY: JPHEXT, JPVEXT

TYPE(TFILEDATA),INTENT(INOUT)        :: TPFILE
CHARACTER(LEN=*),OPTIONAL,INTENT(IN) :: HPROGRAM_ORIG !To emulate a file coming from this program

CHARACTER(LEN=:),ALLOCATABLE :: YPROGRAM
INTEGER                      :: IIU_ll, IJU_ll, IKU
TYPE(IOCDF), POINTER         :: PIOCDF

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_SET_KNOWNDIMS_NC4','called for '//TRIM(TPFILE%CNAME))

PIOCDF => TPFILE%TNCDIMS

IF (PRESENT(HPROGRAM_ORIG)) THEN
  YPROGRAM = HPROGRAM_ORIG
ELSE
  YPROGRAM = CPROGRAM
ENDIF

IIU_ll = NIMAX_ll + 2*JPHEXT
IJU_ll = NJMAX_ll + 2*JPHEXT
IKU    = NKMAX    + 2*JPVEXT

IF (.NOT. ASSOCIATED(PIOCDF%DIM_NI))      PIOCDF%DIM_NI      => GETDIMCDF(TPFILE, IIU_ll, 'ni')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NJ))      PIOCDF%DIM_NJ      => GETDIMCDF(TPFILE, IJU_ll, 'nj')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NI_U))    PIOCDF%DIM_NI_U    => GETDIMCDF(TPFILE, IIU_ll, 'ni_u')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NJ_U))    PIOCDF%DIM_NJ_U    => GETDIMCDF(TPFILE, IJU_ll, 'nj_u')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NI_V))    PIOCDF%DIM_NI_V    => GETDIMCDF(TPFILE, IIU_ll, 'ni_v')
IF (.NOT. ASSOCIATED(PIOCDF%DIM_NJ_V))    PIOCDF%DIM_NJ_V    => GETDIMCDF(TPFILE, IJU_ll, 'nj_v')
IF (TRIM(YPROGRAM)/='PGD' .AND. TRIM(YPROGRAM)/='NESPGD' .AND. TRIM(YPROGRAM)/='ZOOMPG' &
    .AND. .NOT.(TRIM(YPROGRAM)=='REAL' .AND. CSTORAGE_TYPE=='SU') ) THEN !condition to detect PREP_SURFEX
  IF (.NOT. ASSOCIATED(PIOCDF%DIM_LEVEL))   PIOCDF%DIM_LEVEL   => GETDIMCDF(TPFILE, IKU   , 'level')
  IF (.NOT. ASSOCIATED(PIOCDF%DIM_LEVEL_W)) PIOCDF%DIM_LEVEL_W => GETDIMCDF(TPFILE, IKU   , 'level_w')
  IF (.NOT. ASSOCIATED(PIOCDF%DIMTIME)) PIOCDF%DIMTIME => GETDIMCDF(TPFILE, NF90_UNLIMITED, 'time')
ELSE
  !PGD and SURFEX files for MesoNH have no vertical levels or time scale
  !These dimensions are allocated to default values
  !(they need to be allocated when looking for dimensions of variables)
  IF (.NOT. ASSOCIATED(PIOCDF%DIM_LEVEL))   ALLOCATE(PIOCDF%DIM_LEVEL)
  IF (.NOT. ASSOCIATED(PIOCDF%DIM_LEVEL_W)) ALLOCATE(PIOCDF%DIM_LEVEL_W)
  IF (.NOT. ASSOCIATED(PIOCDF%DIMTIME))     ALLOCATE(PIOCDF%DIMTIME)
END IF

!Store X,Y,Z coordinates for the Arakawa points
!0 2nd-dimension is to treat NGRID=0 case without crash
IF (.NOT.ALLOCATED(TPFILE%TNCCOORDS)) ALLOCATE(TPFILE%TNCCOORDS(3,0:8))
!Dummy point
TPFILE%TNCCOORDS(1,0)%TDIM => TDIM_DUMMY
TPFILE%TNCCOORDS(2,0)%TDIM => TDIM_DUMMY
TPFILE%TNCCOORDS(3,0)%TDIM => TDIM_DUMMY
! Mass point
TPFILE%TNCCOORDS(1,1)%TDIM => PIOCDF%DIM_NI
TPFILE%TNCCOORDS(2,1)%TDIM => PIOCDF%DIM_NJ
TPFILE%TNCCOORDS(3,1)%TDIM => PIOCDF%DIM_LEVEL
! u point
TPFILE%TNCCOORDS(1,2)%TDIM => PIOCDF%DIM_NI_U
TPFILE%TNCCOORDS(2,2)%TDIM => PIOCDF%DIM_NJ_U
TPFILE%TNCCOORDS(3,2)%TDIM => PIOCDF%DIM_LEVEL
! v point
TPFILE%TNCCOORDS(1,3)%TDIM => PIOCDF%DIM_NI_V
TPFILE%TNCCOORDS(2,3)%TDIM => PIOCDF%DIM_NJ_V
TPFILE%TNCCOORDS(3,3)%TDIM => PIOCDF%DIM_LEVEL
! w point
TPFILE%TNCCOORDS(1,4)%TDIM => PIOCDF%DIM_NI
TPFILE%TNCCOORDS(2,4)%TDIM => PIOCDF%DIM_NJ
TPFILE%TNCCOORDS(3,4)%TDIM => PIOCDF%DIM_LEVEL_W
! xi vorticity point (=f point =uv point)
TPFILE%TNCCOORDS(1,5)%TDIM => PIOCDF%DIM_NI_U
TPFILE%TNCCOORDS(2,5)%TDIM => PIOCDF%DIM_NJ_V
TPFILE%TNCCOORDS(3,5)%TDIM => PIOCDF%DIM_LEVEL
! eta vorticity point (=uw point)
TPFILE%TNCCOORDS(1,6)%TDIM => PIOCDF%DIM_NI_U
TPFILE%TNCCOORDS(2,6)%TDIM => PIOCDF%DIM_NJ_U
TPFILE%TNCCOORDS(3,6)%TDIM => PIOCDF%DIM_LEVEL_W
! zeta vorticity point (=vw point)
TPFILE%TNCCOORDS(1,7)%TDIM => PIOCDF%DIM_NI_V
TPFILE%TNCCOORDS(2,7)%TDIM => PIOCDF%DIM_NJ_V
TPFILE%TNCCOORDS(3,7)%TDIM => PIOCDF%DIM_LEVEL_W
! fw point (=uvw point)
TPFILE%TNCCOORDS(1,8)%TDIM => PIOCDF%DIM_NI_U
TPFILE%TNCCOORDS(2,8)%TDIM => PIOCDF%DIM_NJ_V
TPFILE%TNCCOORDS(3,8)%TDIM => PIOCDF%DIM_LEVEL_W


END SUBROUTINE IO_SET_KNOWNDIMS_NC4


SUBROUTINE IO_WRITE_COORDVAR_NC4(TPFILE,HPROGRAM_ORIG)
USE MODD_CONF,       ONLY: CPROGRAM, LCARTESIAN
USE MODD_CONF_n,     ONLY: CSTORAGE_TYPE
USE MODD_GRID,       ONLY: XLATORI, XLONORI
USE MODD_GRID_n,     ONLY: LSLEVE, XXHAT, XYHAT, XZHAT
USE MODD_PARAMETERS, ONLY: JPHEXT, JPVEXT

USE MODE_FIELD,      ONLY: TFIELDLIST,FIND_FIELD_ID_FROM_MNHNAME
USE MODE_GRIDPROJ
USE MODE_NEST_ll,    ONLY: GET_MODEL_NUMBER_ll, GO_TOMODEL_ll

TYPE(TFILEDATA),          INTENT(IN) :: TPFILE
CHARACTER(LEN=*),OPTIONAL,INTENT(IN) :: HPROGRAM_ORIG !To emulate a file coming from this program

CHARACTER(LEN=:),ALLOCATABLE    :: YSTDNAMEPREFIX
CHARACTER(LEN=:),ALLOCATABLE    :: YPROGRAM
INTEGER                         :: IIU, IJU, IKU
INTEGER                         :: ID, IID, IRESP
INTEGER                         :: IMI
INTEGER(KIND=IDCDF_KIND)        :: INCID
LOGICAL                         :: GCHANGEMODEL
LOGICAL,POINTER                 :: GSLEVE
REAL,DIMENSION(:),POINTER       :: ZXHAT, ZYHAT, ZZHAT
REAL,DIMENSION(:),ALLOCATABLE   :: ZXHATM, ZYHATM,ZZHATM !Coordinates at mass points in the transformed space
REAL,DIMENSION(:,:),POINTER     :: ZLAT, ZLON
TYPE(IOCDF), POINTER            :: PIOCDF

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_COORDVAR_NC4','called for '//TRIM(TPFILE%CNAME))

ZXHAT => NULL()
ZYHAT => NULL()
ZZHAT => NULL()

PIOCDF => TPFILE%TNCDIMS

GCHANGEMODEL = .FALSE.

IF (PRESENT(HPROGRAM_ORIG)) THEN
  YPROGRAM = HPROGRAM_ORIG
ELSE
  YPROGRAM = CPROGRAM
ENDIF

! Get the Netcdf file ID
INCID = TPFILE%NNCID

IF (TPFILE%NMODEL>0) THEN
  CALL FIND_FIELD_ID_FROM_MNHNAME('XHAT',IID,IRESP)
  ZXHAT => TFIELDLIST(IID)%TFIELD_X1D(TPFILE%NMODEL)%DATA
  CALL FIND_FIELD_ID_FROM_MNHNAME('YHAT',IID,IRESP)
  ZYHAT => TFIELDLIST(IID)%TFIELD_X1D(TPFILE%NMODEL)%DATA
  CALL FIND_FIELD_ID_FROM_MNHNAME('ZHAT',IID,IRESP)
  ZZHAT => TFIELDLIST(IID)%TFIELD_X1D(TPFILE%NMODEL)%DATA
  CALL FIND_FIELD_ID_FROM_MNHNAME('SLEVE',IID,IRESP)
  GSLEVE => TFIELDLIST(IID)%TFIELD_L0D(TPFILE%NMODEL)%DATA
  !
  CALL GET_MODEL_NUMBER_ll(IMI)
  IF (IMI/=TPFILE%NMODEL) THEN
    !This is necessary to have correct domain sizes (used by GATHER_XXFIELD)
    CALL GO_TOMODEL_ll(TPFILE%NMODEL,IRESP)
    GCHANGEMODEL = .TRUE.
  END IF
ELSE
  ZXHAT => XXHAT
  ZYHAT => XYHAT
  ZZHAT => XZHAT
  GSLEVE => LSLEVE
END IF

IIU = SIZE(ZXHAT)
IJU = SIZE(ZYHAT)
ALLOCATE(ZXHATM(IIU),ZYHATM(IJU))
!ZXHATM(IIU) and ZYHATM(IJU) are correct only on some processes
!but it is OK due to the way GATHER_XXFIELD is done
ZXHATM(1:IIU-1) = 0.5*(ZXHAT(1:IIU-1)+ZXHAT(2:IIU))
ZXHATM(IIU)     = 2.*ZXHAT(IIU)-ZXHATM(IIU-1)
ZYHATM(1:IJU-1) = 0.5*(ZYHAT(1:IJU-1)+ZYHAT(2:IJU))
ZYHATM(IJU)     = 2.*ZYHAT(IJU)-ZYHATM(IJU-1)
!
IF (LCARTESIAN) THEN
  YSTDNAMEPREFIX = 'plane'
ELSE
  YSTDNAMEPREFIX = 'projection'
ENDIF
CALL WRITE_HOR_COORD(PIOCDF%DIM_NI,'x-dimension of the grid',TRIM(YSTDNAMEPREFIX)//'_x_coordinate','X',0.,JPHEXT,JPHEXT,ZXHATM)
CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ,'y-dimension of the grid',TRIM(YSTDNAMEPREFIX)//'_y_coordinate','Y',0.,JPHEXT,JPHEXT,ZYHATM)
CALL WRITE_HOR_COORD(PIOCDF%DIM_NI_U,'x-dimension of the grid at u location', &
                     TRIM(YSTDNAMEPREFIX)//'_x_coordinate_at_u_location','X',-0.5,JPHEXT,0,     ZXHAT)
CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ_U,'y-dimension of the grid at u location', &
                     TRIM(YSTDNAMEPREFIX)//'_y_coordinate_at_u_location','Y', 0., JPHEXT,JPHEXT,ZYHATM)
CALL WRITE_HOR_COORD(PIOCDF%DIM_NI_V,'x-dimension of the grid at v location', &
                     TRIM(YSTDNAMEPREFIX)//'_x_coordinate_at_v_location','X', 0., JPHEXT,JPHEXT,ZXHATM)
CALL WRITE_HOR_COORD(PIOCDF%DIM_NJ_V,'y-dimension of the grid at v location', &
                     TRIM(YSTDNAMEPREFIX)//'_y_coordinate_at_v_location','Y',-0.5,JPHEXT,0,     ZYHAT)
!
IF (.NOT.LCARTESIAN) THEN
  ALLOCATE(ZLAT(IIU,IJU),ZLON(IIU,IJU))
  !
  !Compute latitude/longitude for the Arakawa points
  !
  ! Mass point
  CALL WRITE_HOR_2DCOORD(ZXHATM,ZYHATM,'latitude',  'longitude')
  ! u point
  CALL WRITE_HOR_2DCOORD(ZXHAT, ZYHATM,'latitude_u','longitude_u')
  ! v point
  CALL WRITE_HOR_2DCOORD(ZXHATM,ZYHAT, 'latitude_v','longitude_v')
  ! xi vorticity point (=f point =uv point)
  CALL WRITE_HOR_2DCOORD(ZXHAT, ZYHAT, 'latitude_f','longitude_f')
  !
  DEALLOCATE(ZLAT,ZLON)
END IF
!
DEALLOCATE(ZXHATM,ZYHATM)
!
IF (TPFILE%LMASTER) THEN !vertical coordinates in the transformed space are the same on all processes
  IF (TRIM(YPROGRAM)/='PGD' .AND. TRIM(YPROGRAM)/='NESPGD' .AND. TRIM(YPROGRAM)/='ZOOMPG' &
      .AND. .NOT.(TRIM(YPROGRAM)=='REAL' .AND. CSTORAGE_TYPE=='SU') ) THEN !condition to detect PREP_SURFEX
    !
    IKU = SIZE(ZZHAT)
    ALLOCATE(ZZHATM(IKU))
    ZZHATM(1:IKU-1) = 0.5 * (ZZHAT(2:IKU)+ZZHAT(1:IKU-1))
    ZZHATM(IKU)     = 2.* ZZHAT(IKU) - ZZHATM(IKU-1)
    !
    CALL WRITE_VER_COORD(PIOCDF%DIM_LEVEL,  'position z in the transformed space',              '', &
                         'altitude',               0., JPVEXT,JPVEXT,ZZHATM)
    !
    CALL WRITE_VER_COORD(PIOCDF%DIM_LEVEL_W,'position z in the transformed space at w location','', &
                         'altitude_at_w_location',-0.5,JPVEXT,0,     ZZHAT)
    !
    DEALLOCATE(ZZHATM)
  END IF
END IF
!
!Write time scale
IF (TPFILE%LMASTER) THEN !Time scale is the same on all processes
  IF (TRIM(YPROGRAM)/='PGD' .AND. TRIM(YPROGRAM)/='NESPGD' .AND. TRIM(YPROGRAM)/='ZOOMPG' &
      .AND. .NOT.(TRIM(YPROGRAM)=='REAL' .AND. CSTORAGE_TYPE=='SU') ) THEN !condition to detect PREP_SURFEX
    CALL WRITE_TIME_COORD(PIOCDF%DIMTIME)
  END IF
END IF

IF (GCHANGEMODEL) CALL GO_TOMODEL_ll(IMI,IRESP)

CONTAINS
SUBROUTINE WRITE_HOR_COORD(TDIM,HLONGNAME,HSTDNAME,HAXIS,PSHIFT,KBOUNDLOW,KBOUNDHIGH,PCOORDS)
  USE MODE_ALLOCBUFFER_ll, ONLY: ALLOCBUFFER_ll
  USE MODE_GATHER_ll,      ONLY: GATHER_XXFIELD

  TYPE(DIMCDF), POINTER,            INTENT(IN) :: TDIM
  CHARACTER(LEN=*),                 INTENT(IN) :: HLONGNAME
  CHARACTER(LEN=*),                 INTENT(IN) :: HSTDNAME
  CHARACTER(LEN=*),                 INTENT(IN) :: HAXIS
  REAL,                             INTENT(IN) :: PSHIFT
  INTEGER,                          INTENT(IN) :: KBOUNDLOW
  INTEGER,                          INTENT(IN) :: KBOUNDHIGH
  REAL,DIMENSION(:),TARGET,OPTIONAL,INTENT(IN) :: PCOORDS

  CHARACTER(LEN=2)              :: YDIR
  CHARACTER(LEN=64)             :: YRANGE
  CHARACTER(LEN=:),ALLOCATABLE  :: YVARNAME
  INTEGER                       :: IRESP
  INTEGER                       :: ISIZE
  INTEGER                       :: JI
  INTEGER(KIND=IDCDF_KIND)      :: IVARID
  INTEGER(KIND=IDCDF_KIND)      :: IVDIM
  INTEGER(KIND=IDCDF_KIND)      :: STATUS
  LOGICAL                       :: GALLOC
  REAL,DIMENSION(:),POINTER     :: ZTAB

  GALLOC = .FALSE.
  ZTAB => NULL()

  IF (HAXIS=='X') THEN
    YDIR = 'XX'
  ELSE IF (HAXIS=='Y') THEN
    YDIR = 'YY'
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO','WRITE_HOR_COORD','invalid HAXIS ('//TRIM(HAXIS)//')')
  END IF

  IF (.NOT.TPFILE%LMASTER) THEN
    IF (PRESENT(PCOORDS)) THEN
      ALLOCATE(ZTAB(0)) !To prevent false positive with valgrind
      GALLOC = .TRUE.
      CALL GATHER_XXFIELD(YDIR,PCOORDS,ZTAB,TPFILE%NMASTER_RANK,TPFILE%NMPICOMM)
    END IF
  ELSE !TPFILE%LMASTER
    ISIZE = TDIM%LEN
    YVARNAME = TRIM(TDIM%NAME)
    IVDIM = TDIM%ID

    IF (.NOT.PRESENT(PCOORDS)) THEN
      ALLOCATE(ZTAB(ISIZE))
      GALLOC = .TRUE.
      DO JI=1,ISIZE
        ZTAB(JI) = REAL(JI,KIND=KIND(ZTAB(1)))+PSHIFT
      END DO
    ELSE
      IF (GSMONOPROC) THEN ! sequential execution
        ZTAB => PCOORDS
      ELSE ! multiprocesses execution
        CALL ALLOCBUFFER_ll(ZTAB,PCOORDS,YDIR,GALLOC)
        CALL GATHER_XXFIELD(YDIR,PCOORDS,ZTAB,TPFILE%NMASTER_RANK,TPFILE%NMPICOMM)
      ENDIF
    END IF

    STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
    IF (STATUS /= NF90_NOERR) THEN
      ! Define the coordinate variable
#if (MNH_REAL == 8)
      STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIM, IVARID)
#else
      STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIM, IVARID)
#endif
      IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_DEF_VAR]')
    ELSE
      CALL PRINT_MSG(NVERB_ERROR,'IO','WRITE_NC_COORDS_VAR',TRIM(YVARNAME)//' already defined')
    END IF

    ! Write metadata
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'long_name',HLONGNAME)
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'standard_name',HSTDNAME)
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    IF (PRESENT(PCOORDS)) THEN
      STATUS = NF90_PUT_ATT(INCID, IVARID, 'units','m')
      IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    END IF
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'axis',HAXIS)
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_axis_shift',PSHIFT)
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    WRITE(YRANGE,'( I0,":",I0 )') 1+KBOUNDLOW,ISIZE-KBOUNDHIGH
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_dynamic_range',TRIM(YRANGE))
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))

    ! Write the data
    STATUS = NF90_PUT_VAR(INCID, IVARID, ZTAB)
    IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  END IF

  IF (GALLOC) DEALLOCATE(ZTAB)
END SUBROUTINE WRITE_HOR_COORD

SUBROUTINE WRITE_HOR_2DCOORD(PX,PY,HLAT,HLON)
  USE MODE_ALLOCBUFFER_ll, ONLY: ALLOCBUFFER_ll
  USE MODE_GATHER_ll,      ONLY: GATHER_XYFIELD

  REAL,DIMENSION(:), INTENT(IN) :: PX
  REAL,DIMENSION(:), INTENT(IN) :: PY
  CHARACTER(LEN=*),  INTENT(IN) :: HLAT
  CHARACTER(LEN=*),  INTENT(IN) :: HLON

  LOGICAL                       :: GALLOC1, GALLOC2
  REAL,DIMENSION(:,:),POINTER   :: ZTAB1, ZTAB2

  GALLOC1 = .FALSE.
  GALLOC2 = .FALSE.
  ZTAB1 => NULL()
  ZTAB2 => NULL()

  CALL SM_LATLON(XLATORI,XLONORI,                     &
                 SPREAD(SOURCE=PX,DIM=2,NCOPIES=IJU), &
                 SPREAD(SOURCE=PY,DIM=1,NCOPIES=IIU), &
                 ZLAT,ZLON)

  IF (.NOT.TPFILE%LMASTER) THEN
    ALLOCATE(ZTAB1(0,0),ZTAB2(0,0)) !To prevent false positive with valgrind
    GALLOC1 = .TRUE. ; GALLOC2 = .TRUE.
    CALL GATHER_XYFIELD(ZLAT,ZTAB1,TPFILE%NMASTER_RANK,TPFILE%NMPICOMM)
    CALL GATHER_XYFIELD(ZLON,ZTAB2,TPFILE%NMASTER_RANK,TPFILE%NMPICOMM)
  ELSE !TPFILE%LMASTER
    IF (GSMONOPROC) THEN ! sequential execution
      ZTAB1 => ZLAT
      ZTAB2 => ZLON
    ELSE ! multiprocesses execution
      CALL ALLOCBUFFER_ll(ZTAB1,ZLAT,'XY',GALLOC1)
      CALL ALLOCBUFFER_ll(ZTAB2,ZLON,'XY',GALLOC2)
      CALL GATHER_XYFIELD(ZLAT,ZTAB1,TPFILE%NMASTER_RANK,TPFILE%NMPICOMM)
      CALL GATHER_XYFIELD(ZLON,ZTAB2,TPFILE%NMASTER_RANK,TPFILE%NMPICOMM)
    ENDIF
    !
    CALL FIND_FIELD_ID_FROM_MNHNAME(HLAT,ID,IRESP)
    CALL IO_WRITE_FIELD_NC4_X2(TPFILE,TFIELDLIST(ID),ZTAB1,IRESP,OISCOORD=.TRUE.)
    CALL FIND_FIELD_ID_FROM_MNHNAME(HLON,ID,IRESP)
    CALL IO_WRITE_FIELD_NC4_X2(TPFILE,TFIELDLIST(ID),ZTAB2,IRESP,OISCOORD=.TRUE.)
  END IF

  IF (GALLOC1) DEALLOCATE(ZTAB1)
  IF (GALLOC2) DEALLOCATE(ZTAB2)
END SUBROUTINE WRITE_HOR_2DCOORD

SUBROUTINE WRITE_VER_COORD(TDIM,HLONGNAME,HSTDNAME,HCOMPNAME,PSHIFT,KBOUNDLOW,KBOUNDHIGH,PCOORDS)
  TYPE(DIMCDF), POINTER, INTENT(IN) :: TDIM
  CHARACTER(LEN=*),      INTENT(IN) :: HLONGNAME
  CHARACTER(LEN=*),      INTENT(IN) :: HSTDNAME
  CHARACTER(LEN=*),      INTENT(IN) :: HCOMPNAME
  REAL,                  INTENT(IN) :: PSHIFT
  INTEGER,               INTENT(IN) :: KBOUNDLOW
  INTEGER,               INTENT(IN) :: KBOUNDHIGH
  REAL,DIMENSION(:),     INTENT(IN) :: PCOORDS

  CHARACTER(LEN=64)             :: YRANGE
  CHARACTER(LEN=:),ALLOCATABLE  :: YVARNAME
  INTEGER                       :: IRESP
  INTEGER                       :: ISIZE
  INTEGER                       :: JI
  INTEGER(KIND=IDCDF_KIND)      :: IVARID
  INTEGER(KIND=IDCDF_KIND)      :: IVDIM
  INTEGER(KIND=IDCDF_KIND)      :: STATUS

  ISIZE = TDIM%LEN
  YVARNAME = TRIM(TDIM%NAME)
  IVDIM = TDIM%ID

  STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
  IF (STATUS /= NF90_NOERR) THEN
    ! Define the coordinate variable
#if (MNH_REAL == 8)
      STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIM, IVARID)
#else
      STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIM, IVARID)
#endif
    IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_DEF_VAR]')
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','WRITE_NC_COORDS_VAR',TRIM(YVARNAME)//' already defined')
  END IF

  ! Write metadata
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'long_name',HLONGNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'standard_name',HSTDNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'units','m')
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'axis','Z')
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'positive','up')
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_axis_shift',PSHIFT)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  WRITE(YRANGE,'( I0,":",I0 )') 1+KBOUNDLOW,ISIZE-KBOUNDHIGH
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'c_grid_dynamic_range',TRIM(YRANGE))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  !
  IF (GSLEVE) THEN
    !Remark: ZS, ZSMT and ZTOP in the formula are the same for mass point or flux point
    STATUS = NF90_PUT_ATT(INCID, IVARID,'formula_terms','s: '//TRIM(YVARNAME)//                   &
                                        ' height: ZTOP oro_ls: ZSMT oro: ZS len1: LEN1 len2: LEN2')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'formula_definition','z(n,k,j,i)=s(k)'//                                      &
                          '+ oro_ls(j,i)*sinh((height/len1)**1.35-(s(k)/len1)**1.35)/sinh((s(k)/len1)**1.35)'//        &
                          '+(oro(j,i)-oro_ls(j,i))*sinh((height/len2)**1.35-(s(k)/len2)**1.35)/sinh((s(k)/len2)**1.35)')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  ELSE
    !Remark: ZS and ZTOP in the formula are the same for mass point or flux point
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'formula_terms','s: '//TRIM(YVARNAME)//' height: ZTOP orog: ZS')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'formula_definition','z(n,k,j,i)=s(k)*(height-orog(j,i))/height+orog(j,i)')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  ENDIF
  !
  STATUS = NF90_PUT_ATT(INCID, IVARID, 'computed_standard_name',HCOMPNAME)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))

  ! Write the data
  STATUS = NF90_PUT_VAR(INCID, IVARID, PCOORDS)
  IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))

END SUBROUTINE WRITE_VER_COORD

SUBROUTINE WRITE_TIME_COORD(TDIM)
  USE MODD_TIME_n,     ONLY: TDTMOD, TDTCUR
  USE MODD_TYPE_DATE

  USE MODE_DATETIME
  USE MODE_FIELD,      ONLY: TFIELDLIST,FIND_FIELD_ID_FROM_MNHNAME
  USE MODE_GRIDPROJ

  TYPE(DIMCDF), POINTER, INTENT(IN) :: TDIM

  REAL                         :: ZDELTATIME
  CHARACTER(LEN=40)            :: YUNITS
  CHARACTER(LEN=:),ALLOCATABLE :: YVARNAME
  INTEGER(KIND=IDCDF_KIND)     :: IVARID
  INTEGER(KIND=IDCDF_KIND)     :: IVDIM
  INTEGER(KIND=IDCDF_KIND)     :: STATUS
  TYPE(DATE_TIME)              :: TZREF


  IF (ASSOCIATED(TDTCUR) .AND. ASSOCIATED(TDTMOD)) THEN
    YVARNAME = TRIM(TDIM%NAME)
    IVDIM = TDIM%ID

    STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
    IF (STATUS /= NF90_NOERR) THEN
      ! Define the coordinate variable
#if (MNH_REAL == 8)
      STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIM, IVARID)
#else
      STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIM, IVARID)
#endif
      IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_TIME_COORD[NF90_DEF_VAR]')
    ELSE
      CALL PRINT_MSG(NVERB_ERROR,'IO','WRITE_TIME_COORD',TRIM(YVARNAME)//' already defined')
    END IF

    ! Write metadata
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'long_name','time axis')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'standard_name','time')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    WRITE(YUNITS,'( "seconds since ",I4.4,"-",I2.2,"-",I2.2," 00:00:00 +0:00" )') &
          TDTMOD%TDATE%YEAR,TDTMOD%TDATE%MONTH,TDTMOD%TDATE%DAY
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'units',YUNITS)
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID, 'axis','T')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
    STATUS = NF90_PUT_ATT(INCID, IVARID,'calendar','standard')
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_ATT]')

    ! Model beginning date (TDTMOD%TDATE) is used as the reference date
    ! Reference time is set to 0.
    TZREF = TDTMOD
    TZREF%TIME = 0.
    ! Compute the temporal distance from reference
    CALL DATETIME_DISTANCE(TZREF,TDTCUR,ZDELTATIME)
    ! Write the data
    STATUS = NF90_PUT_VAR(INCID, IVARID, ZDELTATIME)
    IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'WRITE_NC_COORDS_VAR[NF90_PUT_VAR] '//TRIM(YVARNAME))
  END IF

END SUBROUTINE WRITE_TIME_COORD

END SUBROUTINE IO_WRITE_COORDVAR_NC4


SUBROUTINE HANDLE_ERR(STATUS,LINE,TEXT,KRESP)
INTEGER(KIND=IDCDF_KIND),INTENT(IN)  :: STATUS
INTEGER,                 INTENT(IN)  :: LINE
CHARACTER(LEN=*),        INTENT(IN)  :: TEXT
INTEGER, OPTIONAL,       INTENT(OUT) :: KRESP

CHARACTER(LEN=6) :: YLINE

WRITE(YLINE,'( I6 )') LINE

! Don't stop (by default) the code when KRESP is present
! and ensure KRESP is a negative integer
IF (STATUS /= NF90_NOERR) THEN
  IF (PRESENT(KRESP)) THEN
    IF (STATUS < 0) THEN
      KRESP = STATUS
    ELSE IF (STATUS == 0) THEN
      KRESP = -1
    ELSE
      KRESP = -STATUS
    END IF
    CALL PRINT_MSG(NVERB_WARNING,'IO',TRIM(TEXT),'NetCDF error at line '//TRIM(YLINE)//': '//TRIM(NF90_STRERROR(STATUS)))
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO',TRIM(TEXT),'NetCDF error at line '//TRIM(YLINE)//': '//TRIM(NF90_STRERROR(STATUS)))
  END IF
END IF
END SUBROUTINE HANDLE_ERR

FUNCTION str_replace(hstr, hold, hnew)
CHARACTER(LEN=*) :: hstr, hold, hnew
CHARACTER(LEN=LEN_TRIM(hstr)+MAX(0,LEN(hnew)-LEN(hold))) :: str_replace

INTEGER :: pos

pos = INDEX(hstr,hold)
IF (pos /= 0) THEN
   str_replace = hstr(1:pos-1)//hnew//hstr(pos+LEN(hold):)
ELSE 
   str_replace = hstr 
END IF

END FUNCTION str_replace

SUBROUTINE IO_WRITE_HEADER_NC4(TPFILE)
!
USE MODD_IO_ll, ONLY: TFILEDATA
!
TYPE(TFILEDATA), INTENT(IN)  :: TPFILE ! File structure
!
INTEGER(KIND=IDCDF_KIND) :: ISTATUS
!
IF (TRIM(TPFILE%CFORMAT)/='NETCDF4' .AND. TRIM(TPFILE%CFORMAT)/='LFICDF4') RETURN
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_HEADER_NC4','called for file '//TRIM(TPFILE%CNAME))
!
IF (TPFILE%LMASTER)  THEN
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'Conventions', 'CF-1.7 COMODO-1.4')
  IF (ISTATUS /= NF90_NOERR) CALL HANDLE_ERR(ISTATUS,__LINE__,'IO_FILE_WRITE_HEADER[NF90_PUT_ATT]')

#if (MNH_REAL == 8)
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'MNH_REAL', '8')
#else
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'MNH_REAL', '4')
#endif
  IF (ISTATUS /= NF90_NOERR) CALL HANDLE_ERR(ISTATUS,__LINE__,'IO_FILE_WRITE_HEADER[NF90_PUT_ATT]')

#if (MNH_INT == 4)
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'MNH_INT', '4')
#else
  ISTATUS = NF90_PUT_ATT(TPFILE%NNCID, NF90_GLOBAL, 'MNH_INT', '8')
#endif
  IF (ISTATUS /= NF90_NOERR) CALL HANDLE_ERR(ISTATUS,__LINE__,'IO_FILE_WRITE_HEADER[NF90_PUT_ATT]')

!title

!history

!institution

!source

!comment

!references
END IF
!
END SUBROUTINE IO_WRITE_HEADER_NC4


SUBROUTINE IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,KVARID,OEXISTED,KSHAPE,HCALENDAR,OISCOORD)
!
USE MODD_CONF,   ONLY: CPROGRAM, LCARTESIAN
USE MODD_CONF_n, ONLY: CSTORAGE_TYPE
!
USE MODE_FIELD,  ONLY: TYPEINT, TYPEREAL
!
TYPE(TFILEDATA),                               INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),                              INTENT(IN) :: TPFIELD
INTEGER(KIND=IDCDF_KIND),                      INTENT(IN) :: KVARID
LOGICAL,                                       INTENT(IN) :: OEXISTED !True if variable was already defined
INTEGER(KIND=IDCDF_KIND),DIMENSION(:),OPTIONAL,INTENT(IN) :: KSHAPE
CHARACTER(LEN=*),                     OPTIONAL,INTENT(IN) :: HCALENDAR
LOGICAL,                              OPTIONAL,INTENT(IN) :: OISCOORD   ! Is a coordinate variable (->do not write coordinates attribute)
!
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: STATUS
CHARACTER(LEN=:),ALLOCATABLE :: YCOORDS
LOGICAL                      :: GISCOORD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','called for field '//TRIM(TPFIELD%CMNHNAME))
!
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0 .AND. LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_ATTR_NC4','at least long_name or standard_name must be provided &
  &to respect CF-convention for variable '//TRIM(TPFIELD%CMNHNAME))
ENDIF
!
IF (TPFIELD%NDIMS>1 .AND. .NOT.PRESENT(KSHAPE)) &
  CALL PRINT_MSG(NVERB_FATAL,'IO','IO_WRITE_FIELD_ATTR_NC4','KSHAPE not provided for '//TRIM(TPFIELD%CMNHNAME))
!
IF (PRESENT(OISCOORD)) THEN
  GISCOORD = OISCOORD
ELSE
  GISCOORD = .FALSE.
END IF
!
INCID = TPFILE%NNCID
!
! Standard_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CSTDNAME)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CSTDNAME not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(INCID, KVARID,'standard_name', TRIM(TPFIELD%CSTDNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Long_name attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CLONGNAME not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(INCID, KVARID,'long_name', TRIM(TPFIELD%CLONGNAME))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Canonical units attribute definition (CF convention)
IF(LEN_TRIM(TPFIELD%CUNITS)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CUNITS not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(INCID, KVARID,'units', TRIM(TPFIELD%CUNITS))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! GRID attribute definition
IF(TPFIELD%NGRID<0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%NGRID not set for variable '//TRIM(TPFIELD%CMNHNAME))
!Do not write GRID attribute if NGRID=0
ELSE IF (TPFIELD%NGRID>0) THEN
  STATUS = NF90_PUT_ATT(INCID, KVARID, 'grid', TPFIELD%NGRID)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! COMMENT attribute definition
IF(LEN_TRIM(TPFIELD%CCOMMENT)==0) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','TPFIELD%CCOMMENT not set for variable '//TRIM(TPFIELD%CMNHNAME))
ELSE
  STATUS = NF90_PUT_ATT(INCID, KVARID,'comment', TRIM(TPFIELD%CCOMMENT))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Calendar (CF convention)
IF(PRESENT(HCALENDAR)) THEN
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_ATTR_NC4','CALENDAR provided for variable '//TRIM(TPFIELD%CMNHNAME))
  STATUS = NF90_PUT_ATT(INCID, KVARID,'calendar', TRIM(HCALENDAR))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
! Coordinates (CF convention)
IF (.NOT.GISCOORD) THEN
  !0D: nothing to do
  !1D: no direct correspondance with latitude(_x)/longitude(_x) 2D variables => nothing to do
  IF (.NOT.LCARTESIAN .AND. TPFIELD%NDIMS>1 .AND. TPFIELD%NGRID/=0) THEN
    IF (TPFIELD%CDIR=='XY') THEN
      IF (KSHAPE(1)==TPFILE%TNCCOORDS(1,TPFIELD%NGRID)%TDIM%LEN .AND. KSHAPE(2)==TPFILE%TNCCOORDS(2,TPFIELD%NGRID)%TDIM%LEN ) THEN
        SELECT CASE(TPFIELD%NGRID)
          CASE (0) !Not on Arakawa grid
            !Nothing to do
          CASE (1) !Mass point
            YCOORDS='latitude longitude'
          CASE (2) !u point
            YCOORDS='latitude_u longitude_u'
          CASE (3) !v point
            YCOORDS='latitude_v longitude_v'
          CASE (4) !w point
            YCOORDS='latitude longitude'
          CASE (5) !xi vorticity point (=f point =uv point)
            YCOORDS='latitude_f longitude_f'
          CASE (6) !eta vorticity point (=uw point)
            YCOORDS='latitude_u longitude_u'
          CASE (7) !zeta vorticity point (=vw point)
            YCOORDS='latitude_v longitude_v'
          CASE (8) !fw point (=uvw point)
            YCOORDS='latitude_f longitude_f'
          CASE DEFAULT
            CALL PRINT_MSG(NVERB_ERROR,'IO','IO_WRITE_FIELD_ATTR_NC4','invalid NGRID for variable '//TRIM(TPFIELD%CMNHNAME))
        END SELECT
        !
        STATUS = NF90_PUT_ATT(INCID, KVARID,'coordinates',YCOORDS)
        IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
        DEALLOCATE(YCOORDS)
      ELSE
        CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_ATTR_NC4','coordinates not implemented for variable ' &
                                                                    //TRIM(TPFIELD%CMNHNAME))
      END IF
    ELSE
      !No YCOORDS for CDIR/='XY'
    END IF
  END IF
ENDIF
!
IF(TPFIELD%NTYPE==TYPEINT .AND. TPFIELD%NDIMS>0) THEN
  IF (TPFIELD%NFILLVALUE>=TPFIELD%NVALIDMIN .AND. TPFIELD%NFILLVALUE<=TPFIELD%NVALIDMAX) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_ATTR_NC4','_FillValue is not outside of valid_min - valid_max'// &
                                                                'interval for variable '//TRIM(TPFIELD%CMNHNAME))
  !
  ! Fillvalue (CF/COMODO convention)
  ! Remarks: * the attribute '_FillValue' is also recognized by the netCDF library
  !            and is used when pre-filling a variable
  !          * it cannot be modified if some data has already been written (->check OEXISTED)
  IF(.NOT.OEXISTED) THEN
    STATUS = NF90_PUT_ATT(INCID, KVARID,'_FillValue', TPFIELD%NFILLVALUE)
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
  END IF
  !
  ! Valid_min/max (CF/COMODO convention)
  STATUS = NF90_PUT_ATT(INCID, KVARID,'valid_min', TPFIELD%NVALIDMIN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
  !
  STATUS = NF90_PUT_ATT(INCID, KVARID,'valid_max',TPFIELD%NVALIDMAX)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
IF(TPFIELD%NTYPE==TYPEREAL .AND. TPFIELD%NDIMS>0) THEN
  IF (TPFIELD%XFILLVALUE>=TPFIELD%XVALIDMIN .AND. TPFIELD%XFILLVALUE<=TPFIELD%XVALIDMAX) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_ATTR_NC4','_FillValue is not outside of valid_min - valid_max'// &
                                                                'interval for variable '//TRIM(TPFIELD%CMNHNAME))
  !
  ! Fillvalue (CF/COMODO convention)
  ! Remarks: * the attribute '_FillValue' is also recognized by the netCDF library
  !            and is used when pre-filling a variable
  !          * it cannot be modified if some data has already been written (->check OEXISTED)
  IF(.NOT.OEXISTED) THEN
    IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
      STATUS = NF90_PUT_ATT(INCID, KVARID,'_FillValue', REAL(TPFIELD%XFILLVALUE,KIND=4))
    ELSE
      STATUS = NF90_PUT_ATT(INCID, KVARID,'_FillValue', TPFIELD%XFILLVALUE)
    END IF
    IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
  END IF
  !
  ! Valid_min/max (CF/COMODO convention)
  IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
    STATUS = NF90_PUT_ATT(INCID, KVARID,'valid_min', REAL(TPFIELD%XVALIDMIN,KIND=4))
  ELSE
    STATUS = NF90_PUT_ATT(INCID, KVARID,'valid_min', TPFIELD%XVALIDMIN)
  END IF
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
  !
  IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
    STATUS = NF90_PUT_ATT(INCID, KVARID,'valid_max', REAL(TPFIELD%XVALIDMAX,KIND=4))
  ELSE
    STATUS = NF90_PUT_ATT(INCID, KVARID,'valid_max',TPFIELD%XVALIDMAX)
  END IF
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_ATTR_NC4 [NF90_PUT_ATT]')
ENDIF
!
END SUBROUTINE IO_WRITE_FIELD_ATTR_NC4

FUNCTION GETDIMCDF(TPFILE, KLEN, HDIMNAME)
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
CHARACTER(LEN=*), OPTIONAL :: HDIMNAME ! When provided don't search but
                                       ! simply create with name HDIMNAME
TYPE(DIMCDF), POINTER   :: GETDIMCDF

TYPE(DIMCDF), POINTER :: TMP
INTEGER               :: COUNT
CHARACTER(LEN=16)     :: YSUFFIX
CHARACTER(LEN=20)     :: YDIMNAME
INTEGER(KIND=IDCDF_KIND) :: STATUS
LOGICAL                  :: GCHKLEN !Check if KLEN is valid
TYPE(IOCDF), POINTER     :: PIOCDF

CALL PRINT_MSG(NVERB_DEBUG,'IO','GETDIMCDF','called')

PIOCDF => TPFILE%TNCDIMS

GCHKLEN = .TRUE.
!Do not check KLEN if 'time' (because NF90_UNLIMITED = 0)
IF (PRESENT(HDIMNAME)) THEN
  IF (TRIM(HDIMNAME)=='time') THEN
    GCHKLEN = .FALSE.
  END IF
END IF

WRITE(YSUFFIX,'(I0)') KLEN

IF (GCHKLEN .AND. KLEN < 1) THEN
  CALL PRINT_MSG(NVERB_FATAL,'IO','GETDIMCDF','KLEN='//TRIM(YSUFFIX))
END IF

IF (PRESENT(HDIMNAME)) THEN
   NULLIFY(TMP)
   YDIMNAME = TRIM(HDIMNAME)
ELSE
   ! Search dimension with KLEN length
   COUNT = 1
   TMP  => PIOCDF%DIMLIST
   DO WHILE(ASSOCIATED(TMP))
      IF (TMP%LEN == KLEN .AND. TMP%NAME(1:4) /= 'char') EXIT
      TMP=>TMP%NEXT
      COUNT = COUNT+1
   END DO
   YDIMNAME = 'size'//TRIM(YSUFFIX)
END IF

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = YDIMNAME
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(TPFILE%NNCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETDIMCDF[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT       => PIOCDF%DIMLIST
   PIOCDF%DIMLIST => TMP
CALL PRINT_MSG(NVERB_DEBUG,'IO','GETDIMCDF','new dimension: '//TRIM(TMP%NAME))
END IF

GETDIMCDF => TMP

END FUNCTION GETDIMCDF


FUNCTION GETSTRDIMID(TPFILE,KLEN)
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
INTEGER(KIND=IDCDF_KIND),INTENT(IN) :: KLEN
INTEGER(KIND=IDCDF_KIND)            :: GETSTRDIMID

TYPE(DIMCDF), POINTER :: TMP
TYPE(IOCDF),  POINTER :: TZIOCDF
CHARACTER(LEN=16)     :: YSUFFIX
INTEGER(KIND=IDCDF_KIND) :: STATUS

CALL PRINT_MSG(NVERB_DEBUG,'IO','GETSTRDIMID','called')

WRITE(YSUFFIX,'(I0)') KLEN

IF (KLEN < 1) THEN
  CALL PRINT_MSG(NVERB_FATAL,'IO','GETSTRDIMID','KLEN='//TRIM(YSUFFIX))
END IF

! Search string dimension with KLEN length
TMP  => TPFILE%TNCDIMS%DIMSTR
DO WHILE(ASSOCIATED(TMP))
   IF (TMP%LEN == KLEN) EXIT
   TMP=>TMP%NEXT
END DO

IF (.NOT. ASSOCIATED(TMP)) THEN
   ! Not found then define new dimension
   ALLOCATE(TMP)
   TMP%NAME = 'char'//TRIM(YSUFFIX)
   TMP%LEN = KLEN
   STATUS = NF90_DEF_DIM(TPFILE%NNCID, TMP%NAME, KLEN, TMP%ID)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'GETSTRDIMID[NF90_DEF_DIM]')
   NULLIFY(TMP%NEXT)
   TMP%NEXT      => TPFILE%TNCDIMS%DIMSTR
   TZIOCDF => TPFILE%TNCDIMS
   TZIOCDF%DIMSTR => TMP
END IF

GETSTRDIMID = TMP%ID

END FUNCTION GETSTRDIMID


SUBROUTINE IO_FIND_DIM_BYNAME_NC4(TPFILE, HDIMNAME, TPDIM, KRESP)
TYPE(TFILEDATA),         INTENT(IN)  :: TPFILE
CHARACTER(LEN=*),        INTENT(IN)  :: HDIMNAME
TYPE(DIMCDF),            INTENT(OUT) :: TPDIM
INTEGER,                 INTENT(OUT) :: KRESP
!
TYPE(DIMCDF), POINTER :: TMP
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_FIND_DIM_BYNAME_NC4','called for dimension name '//TRIM(HDIMNAME))
!
KRESP = -2
!
IF(.NOT.ASSOCIATED(TPFILE%TNCDIMS%DIMLIST)) THEN
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_FIND_DIM_BYNAME_NC4','DIMLIST not associated for file  '//TRIM(TPFILE%CNAME))
  KRESP = -1
  RETURN
END IF
!
TMP => TPFILE%TNCDIMS%DIMLIST
!
DO WHILE(ASSOCIATED(TMP))
  IF (TRIM(TMP%NAME)==TRIM(HDIMNAME)) THEN
    TPDIM = TMP
    KRESP = 0
    EXIT
  END IF
  TMP => TMP%NEXT
END DO
!
END SUBROUTINE IO_FIND_DIM_BYNAME_NC4


SUBROUTINE FILLVDIMS(TPFILE, TPFIELD, KSHAPE, KVDIMS)
TYPE(TFILEDATA),                      INTENT(IN)  :: TPFILE
TYPE(TFIELDDATA),                     INTENT(IN)  :: TPFIELD
INTEGER(KIND=IDCDF_KIND),DIMENSION(:),INTENT(IN)  :: KSHAPE
INTEGER(KIND=IDCDF_KIND),DIMENSION(:),ALLOCATABLE,INTENT(OUT) :: KVDIMS
!
INTEGER               :: IGRID
INTEGER               :: JI
CHARACTER(LEN=32)     :: YINT
CHARACTER(LEN=2)      :: YDIR
TYPE(DIMCDF), POINTER :: PTDIM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','FILLVDIMS','called for '//TRIM(TPFIELD%CMNHNAME))
!
IF (SIZE(KSHAPE) < 1 .AND. .NOT.TPFIELD%LTIMEDEP) CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','empty KSHAPE')
!
IGRID  =  TPFIELD%NGRID
YDIR   =  TPFIELD%CDIR
!
IF(SIZE(KSHAPE)/=TPFIELD%NDIMS) THEN
  WRITE(YINT,'( I0,"/",I0 )') SIZE(KSHAPE),TPFIELD%NDIMS
  CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','SIZE(KSHAPE)/=TPFIELD%NDIMS ('//TRIM(YINT)//') for field ' &
                 //TRIM(TPFIELD%CMNHNAME))
END IF
!
IF (TPFIELD%LTIMEDEP) THEN
  !Add time dimension
  ALLOCATE(KVDIMS(TPFIELD%NDIMS+1))
  KVDIMS(TPFIELD%NDIMS+1) = TPFILE%TNCDIMS%DIMTIME%ID
ELSE
  ALLOCATE(KVDIMS(TPFIELD%NDIMS))
END IF
!
IF(IGRID<0 .OR. IGRID>8) THEN
  WRITE(YINT,'( I0 )') IGRID
  CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','invalid NGRID ('//TRIM(YINT)//') for field '//TRIM(TPFIELD%CMNHNAME))
END IF
!
IF(IGRID==0 .AND. YDIR/='--' .AND. YDIR/=''  ) THEN
  CALL PRINT_MSG(NVERB_FATAL,'IO','FILLVDIMS','invalid YDIR ('//TRIM(YDIR)//') with NGRID=0 for field '//TRIM(TPFIELD%CMNHNAME))
END IF
!
DO JI=1,SIZE(KSHAPE)
  IF (JI == 1) THEN
    IF ( (YDIR == 'XX' .OR. YDIR == 'XY') .AND. KSHAPE(1)==TPFILE%TNCCOORDS(1,IGRID)%TDIM%LEN) THEN
      KVDIMS(1) = TPFILE%TNCCOORDS(1,IGRID)%TDIM%ID
    ELSE IF ( YDIR == 'YY'                .AND. KSHAPE(1)==TPFILE%TNCCOORDS(2,IGRID)%TDIM%LEN) THEN
      KVDIMS(1) = TPFILE%TNCCOORDS(2,IGRID)%TDIM%ID
    ELSE IF ( YDIR == 'ZZ'                .AND. KSHAPE(1)==TPFILE%TNCCOORDS(3,IGRID)%TDIM%LEN) THEN
      KVDIMS(1) = TPFILE%TNCCOORDS(3,IGRID)%TDIM%ID
    ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(1)); KVDIMS(1) = PTDIM%ID
    END IF
  ELSE IF (JI == 2) THEN
    IF ( YDIR == 'XY' .AND. KSHAPE(2)==TPFILE%TNCCOORDS(2,IGRID)%TDIM%LEN) THEN
      KVDIMS(2) = TPFILE%TNCCOORDS(2,IGRID)%TDIM%ID
    ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(2)); KVDIMS(2) = PTDIM%ID
    END IF
  ELSE IF (JI == 3) THEN
    IF ( YDIR == 'XY' .AND. KSHAPE(3)==TPFILE%TNCCOORDS(3,IGRID)%TDIM%LEN) THEN
      KVDIMS(3) = TPFILE%TNCCOORDS(3,IGRID)%TDIM%ID
    ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(3)); KVDIMS(3) = PTDIM%ID
    END IF
  ELSE
      PTDIM => GETDIMCDF(TPFILE, KSHAPE(JI)); KVDIMS(JI) = PTDIM%ID
  END IF
END DO
!
END SUBROUTINE FILLVDIMS


SUBROUTINE IO_GUESS_DIMIDS_NC4(TPFILE, TPFIELD, KLEN, TPDIMS, KRESP)
!
USE MODE_FIELD, ONLY: TYPECHAR
!
!Used by LFI2CDF
TYPE(TFILEDATA),                      INTENT(IN)  :: TPFILE
TYPE(TFIELDDATA),                     INTENT(IN)  :: TPFIELD
INTEGER,                              INTENT(IN)  :: KLEN
TYPE(DIMCDF),DIMENSION(:),            INTENT(OUT) :: TPDIMS
INTEGER,                              INTENT(OUT) :: KRESP
!
INTEGER               :: IGRID
INTEGER               :: ILEN, ISIZE
INTEGER               :: JI
CHARACTER(LEN=32)     :: YINT
CHARACTER(LEN=2)      :: YDIR
TYPE(DIMCDF), POINTER :: PTDIM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_GUESS_DIMIDS_NC4','called for '//TRIM(TPFIELD%CMNHNAME))
!
IGRID  =  TPFIELD%NGRID
YDIR   =  TPFIELD%CDIR
!
KRESP = 0
ILEN = 0
PTDIM => NULL()
!
IF(IGRID<0 .OR. IGRID>8) THEN
  WRITE(YINT,'( I0 )') IGRID
  CALL PRINT_MSG(NVERB_FATAL,'IO','IO_GUESS_DIMIDS_NC4','invalid NGRID ('//TRIM(YINT)//') for field '//TRIM(TPFIELD%CMNHNAME))
END IF
!
IF(IGRID==0 .AND. YDIR/='--' .AND. YDIR/=''  ) THEN
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4','invalid YDIR ('//TRIM(YDIR)//') with NGRID=0 for field '&
                 //TRIM(TPFIELD%CMNHNAME))
END IF
!
IF (IGRID==0) THEN
  SELECT CASE(TPFIELD%NDIMS)
    CASE (0)
      IF (TPFIELD%NTYPE == TYPECHAR) THEN
        ILEN = KLEN
      ELSE
        ILEN = 1
      END IF
    CASE (1)
      PTDIM => GETDIMCDF(TPFILE,KLEN)
      TPDIMS(1) = PTDIM
      ILEN      = PTDIM%LEN
    CASE DEFAULT
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4','NGRID=0 and NDIMS>1 not yet supported (field '&
                     //TRIM(TPFIELD%CMNHNAME)//')')
  END SELECT
ELSE IF (TPFIELD%CLBTYPE/='NONE') THEN
  IF (TPFIELD%NDIMS/=3) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4','CLBTYPE/=NONE and NDIMS/=3 not supported (field '&
                     //TRIM(TPFIELD%CMNHNAME)//')')
  END IF
  !
  IF (TPFIELD%CLBTYPE=='LBX' .OR. TPFIELD%CLBTYPE=='LBXU') THEN
    PTDIM => TPFILE%TNCCOORDS(2,IGRID)%TDIM
    TPDIMS(2) = PTDIM
    PTDIM => TPFILE%TNCCOORDS(3,IGRID)%TDIM
    TPDIMS(3) = PTDIM
    ILEN = TPDIMS(2)%LEN * TPDIMS(3)%LEN
    ISIZE = KLEN/ILEN
    IF (MOD(KLEN,ILEN)/=0) CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4', &
                                              'can not guess 1st dimension for field '//TRIM(TPFIELD%CMNHNAME))
    PTDIM => GETDIMCDF(TPFILE, ISIZE)
    TPDIMS(1) = PTDIM
    ILEN       = ILEN * PTDIM%LEN
  ELSE IF (TPFIELD%CLBTYPE=='LBY' .OR. TPFIELD%CLBTYPE=='LBYV') THEN
    PTDIM => TPFILE%TNCCOORDS(1,IGRID)%TDIM
    TPDIMS(1) = PTDIM
    PTDIM => TPFILE%TNCCOORDS(3,IGRID)%TDIM
    TPDIMS(3) = PTDIM
    ILEN = TPDIMS(1)%LEN * TPDIMS(3)%LEN
    ISIZE = KLEN/ILEN
    IF (MOD(KLEN,ILEN)/=0) CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4', &
                                              'can not guess 2nd dimension for field '//TRIM(TPFIELD%CMNHNAME))
    PTDIM => GETDIMCDF(TPFILE, ISIZE)
    TPDIMS(2) = PTDIM
    ILEN       = ILEN * PTDIM%LEN
  ELSE
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4','invalid CLBTYPE ('//TPFIELD%CLBTYPE//') for field '&
                     //TRIM(TPFIELD%CMNHNAME))
  END IF
ELSE
  IF (TPFIELD%NDIMS==0) ILEN = 1
  !
  DO JI=1,TPFIELD%NDIMS
    IF (JI == 1) THEN
      IF ( (YDIR == 'XX' .OR. YDIR == 'XY') ) THEN
        PTDIM => TPFILE%TNCCOORDS(1,IGRID)%TDIM
      ELSE IF ( YDIR == 'YY' ) THEN
        PTDIM => TPFILE%TNCCOORDS(2,IGRID)%TDIM
      ELSE IF ( YDIR == 'ZZ' ) THEN
        PTDIM => TPFILE%TNCCOORDS(3,IGRID)%TDIM
      ELSE IF (JI==TPFIELD%NDIMS) THEN !Guess last dimension
        PTDIM => GETDIMCDF(TPFILE, KLEN)
      END IF
      ILEN       = PTDIM%LEN
      TPDIMS(JI) = PTDIM
    ELSE IF (JI == 2) THEN
      IF ( YDIR == 'XY') THEN
        PTDIM => TPFILE%TNCCOORDS(2,IGRID)%TDIM
      ELSE IF (JI==TPFIELD%NDIMS) THEN !Guess last dimension
        ISIZE = KLEN/ILEN
        IF (MOD(KLEN,ILEN)/=0) THEN
          CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4', &
                                            'can not guess 2nd and last dimension for field '//TRIM(TPFIELD%CMNHNAME))
          EXIT
        END IF
        PTDIM => GETDIMCDF(TPFILE, ISIZE)
      ELSE
        CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4','can not guess 2nd dimension for field '//TRIM(TPFIELD%CMNHNAME))
        EXIT
      END IF
      ILEN       = ILEN * PTDIM%LEN
      TPDIMS(JI) = PTDIM
    ELSE IF (JI == 3) THEN
      IF ( YDIR == 'XY' ) THEN
        IF (JI==TPFIELD%NDIMS .AND. KLEN/ILEN==1 .AND. MOD(KLEN,ILEN)==0) THEN
          !The last dimension is of size 1 => probably time dimension
          ISIZE = 1
          PTDIM => GETDIMCDF(TPFILE,ISIZE)
        ELSE
          PTDIM => TPFILE%TNCCOORDS(3,IGRID)%TDIM
        END IF
      ELSE IF (JI==TPFIELD%NDIMS) THEN !Guess last dimension
        ISIZE = KLEN/ILEN
        IF (MOD(KLEN,ILEN)/=0) THEN
          CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4', &
                                            'can not guess 3rd and last dimension for field '//TRIM(TPFIELD%CMNHNAME))
          EXIT
        END IF
        PTDIM => GETDIMCDF(TPFILE, ISIZE)
      ELSE
        CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4','can not guess 3rd dimension for field '//TRIM(TPFIELD%CMNHNAME))
        EXIT
      END IF
      ILEN       = ILEN * PTDIM%LEN
      TPDIMS(JI) = PTDIM
    ELSE IF (JI==4 .AND. JI==TPFIELD%NDIMS) THEN !Guess last dimension
      ISIZE = KLEN/ILEN
      IF (MOD(KLEN,ILEN)/=0) THEN
        CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4', &
                                          'can not guess 4th and last dimension for field '//TRIM(TPFIELD%CMNHNAME))
        EXIT
      END IF
      PTDIM => GETDIMCDF(TPFILE, ISIZE)
      ILEN       = ILEN * PTDIM%LEN
      TPDIMS(JI) = PTDIM
    ELSE
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_GUESS_DIMIDS_NC4','can not guess dimension above 4 for field '&
                     //TRIM(TPFIELD%CMNHNAME))
    END IF
  END DO
END IF
!
IF (KLEN /= ILEN) THEN
  CALL PRINT_MSG(NVERB_INFO,'IO','IO_GUESS_DIMIDS_NC4','can not guess dimensions of field '&
                                   //TRIM(TPFIELD%CMNHNAME))
  KRESP = 1
END IF
!
END SUBROUTINE IO_GUESS_DIMIDS_NC4


SUBROUTINE IO_WRITE_FIELD_NC4_X0(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,                  INTENT(IN) :: PFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (TPFIELD%LTIMEDEP) THEN
     ! Get the netcdf dimensions
     CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)
     ! Define the variable
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
#endif
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_DEF_VAR]')
     DEALLOCATE(IVDIMS)
   ELSE
     ! Define the scalar variable
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVARID)
#endif
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_DEF_VAR]')
   END IF
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X0


SUBROUTINE IO_WRITE_FIELD_NC4_X1(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:),     INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
#endif
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X1


SUBROUTINE IO_WRITE_FIELD_NC4_X2(TPFILE,TPFIELD,PFIELD,KRESP,KVERTLEVEL,KZFILE,OISCOORD)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:),   INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
INTEGER,OPTIONAL,      INTENT(IN) :: KVERTLEVEL ! Number of the vertical level (needed for Z-level splitted files)
INTEGER,OPTIONAL,      INTENT(IN) :: KZFILE     ! Number of the Z-level splitted file
LOGICAL,OPTIONAL,      INTENT(IN) :: OISCOORD   ! Is a coordinate variable (->do not write coordinates attribute)
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=4)         :: YSUFFIX
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
TYPE(TFIELDDATA)         :: TZFIELD
TYPE(TFILEDATA),POINTER  :: TZFILE
LOGICAL                  :: GEXISTED !True if variable was already defined
!
IRESP = 0
!
IF (PRESENT(KVERTLEVEL)) THEN
  WRITE(YSUFFIX,'(I4.4)') KVERTLEVEL
  IF (.NOT.PRESENT(KZFILE)) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_WRITE_FIELD_NC4_X2','KZFILE argument not provided')
    RETURN
  END IF
  IF (KZFILE>TPFILE%NSUBFILES_IOZ) CALL PRINT_MSG(NVERB_FATAL,'IO','IO_WRITE_FIELD_NC4_X2','KZFILE value too high')
  TZFILE => TPFILE%TFILES_IOZ(KZFILE)%TFILE
  TZFIELD = TPFIELD
  TZFIELD%CMNHNAME  = TRIM(TZFIELD%CMNHNAME)//YSUFFIX
  IF (LEN_TRIM(TZFIELD%CSTDNAME)>0)  TZFIELD%CSTDNAME  = TRIM(TZFIELD%CSTDNAME)//'_at_level_'//YSUFFIX
  IF (LEN_TRIM(TZFIELD%CLONGNAME)>0) TZFIELD%CLONGNAME = TRIM(TZFIELD%CLONGNAME)//' at level '//YSUFFIX
  TZFIELD%NDIMS = 2
ELSE
  TZFILE => TPFILE
  TZFIELD = TPFIELD
ENDIF
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X2',TRIM(TZFILE%CNAME)//': writing '//TRIM(TZFIELD%CMNHNAME))
!
! Get the Netcdf file ID
INCID = TZFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TZFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X2','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TZFILE, TZFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TZFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
#endif
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TZFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TZFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X2',TRIM(TZFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TZFILE,TZFIELD,IVARID,GEXISTED,KSHAPE=INT(SHAPE(PFIELD),KIND=IDCDF_KIND),OISCOORD=OISCOORD)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X2[NF90_PUT_VAR] '//TRIM(TZFIELD%CMNHNAME),IRESP)
 
IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X2


SUBROUTINE IO_WRITE_FIELD_NC4_X3(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X3','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
#endif
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED,KSHAPE=INT(SHAPE(PFIELD),KIND=IDCDF_KIND))
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X3[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X3


SUBROUTINE IO_WRITE_FIELD_NC4_X4(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),           INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),          INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:),   INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                   INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X4','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
#endif
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED,KSHAPE=INT(SHAPE(PFIELD),KIND=IDCDF_KIND))
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X4[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X4


SUBROUTINE IO_WRITE_FIELD_NC4_X5(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),           INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),          INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                   INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X5','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
#endif
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED,KSHAPE=INT(SHAPE(PFIELD),KIND=IDCDF_KIND))
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X5[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X5


SUBROUTINE IO_WRITE_FIELD_NC4_X6(TPFILE,TPFIELD,PFIELD,KRESP)
!
TYPE(TFILEDATA),             INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),            INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:,:), INTENT(IN) :: PFIELD   ! array containing the data field
INTEGER,                     INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(PFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_X6','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(PFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   IF (TPFILE%LNCREDUCE_FLOAT_PRECISION) THEN
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
   ELSE
#if (MNH_REAL == 8)
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVDIMS, IVARID)
#endif
   END IF
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_DEF_VAR_DEFLATE]')
   END IF
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED,KSHAPE=INT(SHAPE(PFIELD),KIND=IDCDF_KIND))
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, PFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X6[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_X6


SUBROUTINE IO_WRITE_FIELD_NC4_N0(TPFILE,TPFIELD,KFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
#if 0
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
#endif
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
INTEGER,               INTENT(IN) :: KFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
TYPE(IOCDF), POINTER     :: TZIOCDF
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (TPFIELD%LTIMEDEP) THEN
     ! Get the netcdf dimensions
     CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), IVDIMS)
     ! Define the variable
#if ( MNH_INT == 4 )
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT,   IVDIMS, IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_DEF_VAR]')
     DEALLOCATE(IVDIMS)
   ELSE
     ! Define the scalar variable
#if ( MNH_INT == 4 )
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT,   IVARID)
#else
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVARID)
#endif
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_DEF_VAR]')
   END IF
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

!
! Use IMAX, JMAX, KMAX to define DIM_NI, DIM_NJ, DIM_LEVEL
! /!\ Can only work if IMAX, JMAX or KMAX are written before any array
!
#if 0
IF (YVARNAME == 'IMAX' .AND. .NOT. ASSOCIATED(TPFILE%TNCDIMS%DIM_NI)) TPFILE%TNCDIMS%DIM_NI=>GETDIMCDF(TPFILE%TNCDIMS,KFIELD+2*JPHEXT,'X')
IF (YVARNAME == 'JMAX' .AND. .NOT. ASSOCIATED(TPFILE%TNCDIMS%DIM_NJ)) THEN
   IF (LPACK .AND. L2D) THEN
      TPFILE%TNCDIMS%DIM_NJ=>GETDIMCDF(TPFILE, 1,'Y')
   ELSE
      TPFILE%TNCDIMS%DIM_NJ=>GETDIMCDF(TPFILE, KFIELD+2*JPHEXT, 'Y')
   END IF
END IF
#endif
IF (YVARNAME == 'KMAX' .AND. .NOT. ASSOCIATED(TPFILE%TNCDIMS%DIM_LEVEL)) THEN
  TZIOCDF => TPFILE%TNCDIMS
  TZIOCDF%DIM_LEVEL=>GETDIMCDF(TPFILE,INT(KFIELD+2*JPVEXT,KIND=IDCDF_KIND),'Z')
END IF
 
KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N0


SUBROUTINE IO_WRITE_FIELD_NC4_N1(TPFILE,TPFIELD,KFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
#if 0
USE MODD_PARAMETERS_ll,  ONLY : JPHEXT, JPVEXT
USE MODD_IO_ll, ONLY : LPACK,L1D,L2D
#endif
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
INTEGER, DIMENSION(:), INTENT(IN) :: KFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
#if ( MNH_INT == 4 )
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N1[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N1


SUBROUTINE IO_WRITE_FIELD_NC4_N2(TPFILE,TPFIELD,KFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
INTEGER,DIMENSION(:,:),INTENT(IN) :: KFIELD   ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
IRESP = 0
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N2','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
#if ( MNH_INT == 4 )
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED,KSHAPE=INT(SHAPE(KFIELD),KIND=IDCDF_KIND))
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N2[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N2

SUBROUTINE IO_WRITE_FIELD_NC4_N3(TPFILE,TPFIELD,KFIELD,KRESP)
!
TYPE(TFILEDATA),TARGET,  INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
INTEGER,DIMENSION(:,:,:),INTENT(IN) :: KFIELD   ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
IRESP = 0
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_N3',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(KFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_N3','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(KFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
#if ( MNH_INT == 4 )
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT, IVDIMS, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT64, IVDIMS, IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_DEF_VAR]')
   ! Add compression if asked for
   IF (TPFILE%LNCCOMPRESS) THEN
     STATUS = NF90_DEF_VAR_DEFLATE(INCID, IVARID, SHUFFLE, DEFLATE, TPFILE%NNCCOMPRESS_LEVEL)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_DEF_VAR_DEFLATE]')
   END IF
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_N3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED,KSHAPE=INT(SHAPE(KFIELD),KIND=IDCDF_KIND))
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, KFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_N3[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_N3

SUBROUTINE IO_WRITE_FIELD_NC4_L0(TPFILE,TPFIELD,OFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
LOGICAL,               INTENT(IN) :: OFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER                  :: IFIELD
INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)) :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE      :: IVDIMS
INTEGER                  :: IRESP
LOGICAL                  :: GEXISTED !True if variable was already defined
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (TPFIELD%LTIMEDEP) THEN
     ! Get the netcdf dimensions
     CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(OFIELD),KIND=IDCDF_KIND), IVDIMS)
     ! Define the variable
     ! Use of NF90_INT1 datatype (=NF90_BYTE) that is enough to store a boolean
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT1, IVDIMS, IVARID)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L0[NF90_DEF_VAR]')
     DEALLOCATE(IVDIMS)
   ELSE
     ! Define the scalar variable
     ! Use of NF90_INT1 datatype (=NF90_BYTE) that is enough to store a boolean
     STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT1, IVARID)
     IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L0[NF90_DEF_VAR]')
   END IF
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

!Convert LOGICAL to INTEGER (LOGICAL format not supported by netCDF files)
IF (OFIELD) THEN
  IFIELD = 1
ELSE
  IFIELD = 0
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, IFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_L0

SUBROUTINE IO_WRITE_FIELD_NC4_L1(TPFILE,TPFIELD,OFIELD,KRESP)
!
USE MODD_PARAMETERS_ll,  ONLY : JPVEXT
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
LOGICAL, DIMENSION(:), INTENT(IN) :: OFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER, DIMENSION(SIZE(OFIELD))                         :: IFIELD
INTEGER(KIND=IDCDF_KIND)                                 :: STATUS
INTEGER(KIND=IDCDF_KIND)                                 :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))                     :: YVARNAME
INTEGER(KIND=IDCDF_KIND)                                 :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE      :: IVDIMS
INTEGER                                                  :: IRESP
LOGICAL                                                  :: GEXISTED !True if variable was already defined
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   IF (SIZE(OFIELD)==0) THEN
     CALL PRINT_MSG(NVERB_INFO,'IO','IO_WRITE_FIELD_NC4_L1','ignoring variable with a zero size ('//TRIM(YVARNAME)//')')
     KRESP = 0
     RETURN
   END IF

   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(OFIELD),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   ! Use of NF90_INT1 datatype (=NF90_BYTE) that is enough to store a boolean
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_INT1, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L1[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

!Convert LOGICAL to INTEGER (LOGICAL format not supported by netCDF files)
WHERE (OFIELD)
  IFIELD = 1
ELSEWHERE
  IFIELD = 0
END WHERE

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, IFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_L1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMS)) DEALLOCATE(IVDIMS)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_L1


SUBROUTINE IO_WRITE_FIELD_NC4_C0(TPFILE,TPFIELD,HFIELD,KRESP)
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
CHARACTER(LEN=*),      INTENT(IN) :: HFIELD
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
INTEGER                                :: IRESP, ILEN
CHARACTER(LEN=:),ALLOCATABLE           :: YFIELD
LOGICAL                                :: GEXISTED !True if variable was already defined
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
!Store the character string in a string of a size multiple of NSTRINGCHUNKSIZE
!This is done to limit the number of dimensions in the netCDF file
ILEN = ((LEN_TRIM(HFIELD)+NSTRINGCHUNKSIZE-1)/NSTRINGCHUNKSIZE)*NSTRINGCHUNKSIZE
!If the string is empty, create it anyway with a non-zero size (to prevent problems later)
IF (ILEN==0) ILEN = NSTRINGCHUNKSIZE

! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
IF (TPFIELD%LTIMEDEP) &
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_C0',TRIM(TPFILE%CNAME)// &
                 ': time dependent variable not (yet) possible for 0D variable '//TRIM(TPFIELD%CMNHNAME))
!
! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(TPFILE,INT(ILEN,KIND=IDCDF_KIND))
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

ALLOCATE(CHARACTER(LEN=ILEN)::YFIELD)
YFIELD(1:LEN_TRIM(HFIELD))=TRIM(HFIELD)
YFIELD(LEN_TRIM(HFIELD)+1:)=' '
! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, YFIELD)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)
DEALLOCATE(YFIELD)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_C0

SUBROUTINE IO_WRITE_FIELD_NC4_C1(TPFILE,TPFIELD,HFIELD,KRESP)
!  Modif
!    J.Escobar : 25/04/2018 : missing 'IF ALLOCATED(IVDIMSTMP)' DEALLOCATE
!----------------------------------------------------------------
TYPE(TFILEDATA),              INTENT(IN)  :: TPFILE
TYPE(TFIELDDATA),             INTENT(IN)  :: TPFIELD
CHARACTER(LEN=*),DIMENSION(:),INTENT(IN)  :: HFIELD
INTEGER,                      INTENT(OUT) :: KRESP
!
INTEGER(KIND=IDCDF_KIND),PARAMETER :: IONE = 1
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(2) :: IVDIMS
INTEGER(KIND=IDCDF_KIND), DIMENSION(:), ALLOCATABLE :: IVDIMSTMP
INTEGER(KIND=IDCDF_KIND)               :: ILEN, ISIZE
INTEGER                                :: IRESP
LOGICAL                                :: GEXISTED !True if variable was already defined
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_C1',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0

ILEN  = LEN(HFIELD)
ISIZE = SIZE(HFIELD)

! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
IF (TPFIELD%LTIMEDEP) THEN
  !This is an error (+return) and not a warning because IVDIMSTMP could be of size 2 if LTIMEDEP=T
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_WRITE_FIELD_NC4_C1',TRIM(TPFILE%CNAME)// &
                 ': time dependent variable not (yet) possible for '//TRIM(TPFIELD%CMNHNAME))
  RETURN
END IF
!
! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf string dimensions id 
   IVDIMS(1) = GETSTRDIMID(TPFILE,ILEN)
   CALL FILLVDIMS(TPFILE, TPFIELD, (/ISIZE/), IVDIMSTMP)
   IVDIMS(2) = IVDIMSTMP(1)
   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_CHAR, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C1[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_C1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,GEXISTED)
! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, HFIELD(1:ISIZE)(1:ILEN), START=(/IONE,IONE/), COUNT=(/ILEN,ISIZE/))
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_C1[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF(ALLOCATED(IVDIMSTMP)) DEALLOCATE(IVDIMSTMP)

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_C1


SUBROUTINE IO_WRITE_FIELD_NC4_T0(TPFILE,TPFIELD,TPDATA,KRESP)
!
USE MODD_TIME_n,     ONLY: TDTMOD
USE MODD_TYPE_DATE
!
USE MODE_DATETIME
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
TYPE (DATE_TIME),      INTENT(IN) :: TPDATA
INTEGER,               INTENT(OUT):: KRESP
!
INTEGER(KIND=IDCDF_KIND)               :: STATUS
INTEGER(KIND=IDCDF_KIND)               :: INCID
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME))   :: YVARNAME
INTEGER(KIND=IDCDF_KIND)               :: IVARID
INTEGER(KIND=IDCDF_KIND), DIMENSION(1) :: IVDIMS
INTEGER                                :: IRESP
TYPE(TFIELDDATA)                       :: TZFIELD
CHARACTER(LEN=40)                      :: YUNITS
LOGICAL                                :: GEXISTED !True if variable was already defined
REAL                                   :: ZDELTATIME !Distance in seconds since reference date and time
TYPE(DATE_TIME)                        :: TZREF
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': writing '//TRIM(TPFIELD%CMNHNAME))
!
IRESP = 0
!
TZFIELD = TPFIELD
!
! Get the Netcdf file ID
INCID = TPFILE%NNCID
!
GEXISTED = .FALSE.
!
CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)
!
TZFIELD%CMNHNAME = TRIM(YVARNAME)
!
! Model beginning date (TDTMOD%TDATE) is used as the reference date
! Reference time is set to 0.
TZREF = TDTMOD
TZREF%TIME = 0.
WRITE(YUNITS,'( "seconds since ",I4.4,"-",I2.2,"-",I2.2," 00:00:00 +0:00" )') &
      TDTMOD%TDATE%YEAR, TDTMOD%TDATE%MONTH, TDTMOD%TDATE%DAY
TZFIELD%CUNITS = TRIM(YUNITS)
!
IF (TPFIELD%LTIMEDEP) &
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)// &
                 ': time dependent variable not (yet) possible for 0D variable '//TRIM(TPFIELD%CMNHNAME))
!
! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
#if (MNH_REAL == 8)
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_DOUBLE, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, YVARNAME, NF90_FLOAT,  IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' already defined')
END IF

! Write metadata
CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TZFIELD,IVARID,GEXISTED,HCALENDAR='standard')
!
! Compute the temporal distance from reference
CALL DATETIME_DISTANCE(TZREF,TPDATA,ZDELTATIME)

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, ZDELTATIME)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_X0[NF90_PUT_VAR] '//TRIM(TPFIELD%CMNHNAME),IRESP)

IF (IRESP/=0) THEN
  KRESP = IRESP
  RETURN
END IF

#if 0
!This part is to keep backward compatibility with MesoNH files
!but date/time is not conform to CF convention
!
! Write date
!
TZFIELD%CMNHNAME  = TRIM(YVARNAME)//'__TDATE'
TZFIELD%CLONGNAME = TRIM(TPFIELD%CLONGNAME)//'%TDATE'
TZFIELD%CUNITS    = ''
TZFIELD%CCOMMENT  = 'YYYYMMDD'

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, TZFIELD%CMNHNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Get the netcdf dimensions
   CALL FILLVDIMS(TPFILE, TPFIELD, INT(SHAPE(ITDATE),KIND=IDCDF_KIND), IVDIMS)

   ! Define the variable 
   STATUS = NF90_DEF_VAR(INCID, TZFIELD%CMNHNAME, NF90_INT, IVDIMS, IVARID)
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TZFIELD,IVARID,GEXISTED)
ELSE
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(TZFIELD%CMNHNAME)//' already defined')
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, ITDATE)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_PUT_VAR] '//TRIM(TZFIELD%CMNHNAME),IRESP)
 
IF (IRESP/=0) THEN
  KRESP = IRESP
  RETURN
END IF
!
! Write time
!
TZFIELD%CMNHNAME  = TRIM(YVARNAME)//'__TIME'
TZFIELD%CLONGNAME = TRIM(TPFIELD%CLONGNAME)//'%TIME'
TZFIELD%CUNITS    = 's'
TZFIELD%CCOMMENT  = 'SECONDS'

! The variable should not already exist but who knows ?
STATUS = NF90_INQ_VARID(INCID, TZFIELD%CMNHNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   ! Define the scalar variable 
#if (MNH_REAL == 8)
   STATUS = NF90_DEF_VAR(INCID, TZFIELD%CMNHNAME, NF90_DOUBLE, IVARID)
#else
   STATUS = NF90_DEF_VAR(INCID, TZFIELD%CMNHNAME, NF90_FLOAT,  IVARID)
#endif
   IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_DEF_VAR]')
   CALL IO_WRITE_FIELD_ATTR_NC4(TPFILE,TZFIELD,IVARID,GEXISTED)
ELSE
   GEXISTED = .TRUE.
   CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(TZFIELD%CMNHNAME)//' already defined')
END IF

! Write the data
STATUS = NF90_PUT_VAR(INCID, IVARID, TPDATA%TIME)
IF (status /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_WRITE_FIELD_NC4_T0[NF90_PUT_VAR] '//TRIM(TZFIELD%CMNHNAME),IRESP)
#endif

KRESP = IRESP
END SUBROUTINE IO_WRITE_FIELD_NC4_T0
!
!
! Here come the NetCDF READ routines
!
!
SUBROUTINE IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,KVARID,KRESP,HCALENDAR)
!
USE MODD_PARAMETERS, ONLY: NGRIDUNKNOWN
!
TYPE(TFILEDATA),          INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),         INTENT(INOUT) :: TPFIELD
INTEGER(KIND=IDCDF_KIND), INTENT(IN)    :: KVARID
INTEGER,                  INTENT(OUT)   :: KRESP  ! return-code
CHARACTER(LEN=*),OPTIONAL,INTENT(IN)    :: HCALENDAR
!
INTEGER                      :: ILEN
INTEGER                      :: IGRID
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: STATUS
CHARACTER(LEN=12)            :: YVAL_FILE, YVAL_MEM
CHARACTER(LEN=:),ALLOCATABLE :: YVALUE
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)//': called for field '//TRIM(TPFIELD%CMNHNAME))
!
KRESP = 0
INCID = TPFILE%NNCID
!
! GRID
!
STATUS = NF90_GET_ATT(INCID,KVARID,'grid',IGRID)
IF (STATUS /= NF90_NOERR) STATUS = NF90_GET_ATT(INCID,KVARID,'GRID',IGRID)
IF (STATUS == NF90_NOERR) THEN
  IF (IGRID/=TPFIELD%NGRID) THEN
    WRITE(YVAL_FILE,'(I12)') IGRID
    WRITE(YVAL_MEM, '(I12)') TPFIELD%NGRID
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected GRID     value ('//TRIM(ADJUSTL(YVAL_MEM))//             &
                   ') is different than found in file ('//TRIM(ADJUSTL(YVAL_FILE))//') for variable '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%NGRID = IGRID
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected GRID found in file for field '//TRIM(TPFIELD%CMNHNAME))
  ENDIF
ELSE !no GRID
  IF (TPFIELD%NGRID==0 .OR. TPFIELD%NGRID==NGRIDUNKNOWN) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': no GRID (as expected) in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected GRID but not found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
ENDIF
!
! COMMENT
!
STATUS = NF90_INQUIRE_ATTRIBUTE(INCID, KVARID, 'comment', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(INCID, KVARID, 'comment', YVALUE)
  IF (LEN_TRIM(TPFIELD%CCOMMENT)==0 .AND. LEN_TRIM(YVALUE)>0) THEN
    !Expected comment is empty, read comment is not
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': COMMENT  found (unexpected) in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CCOMMENT=TRIM(YVALUE)
  ELSE IF (TRIM(YVALUE)/=TRIM(TPFIELD%CCOMMENT)) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected COMMENT ('//TRIM(TPFIELD%CCOMMENT)//                    &
                   ') is different than found ('//TRIM(YVALUE)//') in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CCOMMENT=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected COMMENT  found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no COMMENT
  IF (LEN_TRIM(TPFIELD%CCOMMENT)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': no COMMENT (as expected) in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected COMMENT but not found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! STDNAME
!
STATUS = NF90_INQUIRE_ATTRIBUTE(INCID, KVARID, 'standard_name', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(INCID, KVARID, 'standard_name', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CSTDNAME)) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected STDNAME  ('//TRIM(TPFIELD%CSTDNAME)//                      &
                   ') is different than found ('//TRIM(YVALUE)//') in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CSTDNAME=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected STDNAME  found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no STDNAME
  IF (LEN_TRIM(TPFIELD%CSTDNAME)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': no STDNAME (as expected) in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected STDNAME but not found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! LONGNAME
!
STATUS = NF90_INQUIRE_ATTRIBUTE(INCID, KVARID, 'long_name', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(INCID, KVARID, 'long_name', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CLONGNAME)) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected LONGNAME ('//TRIM(TPFIELD%CLONGNAME)//                  &
                   ') is different than found ('//TRIM(YVALUE)//') in file for field '//TRIM(TPFIELD%CMNHNAME))
    TPFIELD%CLONGNAME=TRIM(YVALUE)
    KRESP = -111 !Used later to broadcast modified metadata
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected LONGNAME found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no LONGNAME
  IF (LEN_TRIM(TPFIELD%CLONGNAME)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': no LONGNAME (as expected) in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected LONGNAME but not found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
! UNITS
!
STATUS = NF90_INQUIRE_ATTRIBUTE(INCID, KVARID, 'units', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(INCID, KVARID, 'units', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(TPFIELD%CUNITS)) THEN
    IF(.NOT.PRESENT(HCALENDAR)) THEN
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                     ': expected UNITS ('//TRIM(TPFIELD%CUNITS)//                           &
                     ') is different than found ('//TRIM(YVALUE)//') in file for field '//TRIM(TPFIELD%CMNHNAME))
      KRESP = -111 !Used later to broadcast modified metadata
    ELSE
      CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                     ': UNITS found in file for field '//TRIM(TPFIELD%CMNHNAME)//' (will be analysed later)')
    END IF
    TPFIELD%CUNITS=TRIM(YVALUE)
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected UNITS    found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no UNITS
  IF (LEN_TRIM(TPFIELD%CUNITS)==0) THEN
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': no UNITS (as expected) in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    IF(.NOT.PRESENT(HCALENDAR)) THEN
      CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                     ': expected UNITS but not found in file for field '//TRIM(TPFIELD%CMNHNAME))
    ELSE
      CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                     ': expected UNITS but not found in file for field '//TRIM(TPFIELD%CMNHNAME))
      KRESP = -3
    END IF
  END IF
END IF
!
! CALENDAR
!
IF(PRESENT(HCALENDAR)) THEN
STATUS = NF90_INQUIRE_ATTRIBUTE(INCID, KVARID, 'calendar', LEN=ILEN)
IF (STATUS == NF90_NOERR) THEN
  ALLOCATE(CHARACTER(LEN=ILEN) :: YVALUE)
  STATUS = NF90_GET_ATT(INCID, KVARID, 'calendar', YVALUE)
  IF (TRIM(YVALUE)/=TRIM(HCALENDAR)) THEN
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected CALENDAR ('//TRIM(HCALENDAR)//                             &
                   ') is different than found ('//TRIM(YVALUE)//') in file for field '//TRIM(TPFIELD%CMNHNAME))
  ELSE
    CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                   ': expected CALENDAR found in file for field '//TRIM(TPFIELD%CMNHNAME))
  END IF
  DEALLOCATE(YVALUE)
ELSE !no CALENDAR
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_ATTR_NC4',TRIM(TPFILE%CNAME)// &
                 ': expected CALENDAR but not found in file for field '//TRIM(TPFIELD%CMNHNAME))
END IF
ENDIF
!
END SUBROUTINE IO_READ_CHECK_FIELD_ATTR_NC4


SUBROUTINE IO_READ_FIELD_NC4_X0(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,             INTENT(OUT)   :: PFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

IF (IDIMS == 0 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Read variable
  STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF
  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong size or type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X0


SUBROUTINE IO_READ_FIELD_NC4_X1(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:),INTENT(OUT)   :: PFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

IF (IDIMS == 1 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(PFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X1


SUBROUTINE IO_READ_FIELD_NC4_X2(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),    INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),   INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:),INTENT(OUT)   :: PFIELD
INTEGER,            INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND),DIMENSION(3) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

!Treat special case of a degenerated 3D array (3rd dimension size is 1)
IF (IDIMS==3) THEN
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  IF (IDIMLEN(3)==1) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)// &
                   ': reading 3D array with degenerated third dimension in 2D array for '//TRIM(YVARNAME))
    IDIMS = 2
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': wrong number of dimensions for '//TRIM(YVARNAME))
  END IF
END IF

IF (IDIMS == 2 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X2


SUBROUTINE IO_READ_FIELD_NC4_X3(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),      INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),     INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,              INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(3)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

IF (IDIMS == 3 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. IDIMLEN(3) == SIZE(PFIELD,3)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X3[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X3',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X3


SUBROUTINE IO_READ_FIELD_NC4_X4(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),        INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),       INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(4)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

IF (IDIMS == 4 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X4[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X4',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X4


SUBROUTINE IO_READ_FIELD_NC4_X5(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),          INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),         INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                  INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(5)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

IF (IDIMS == 5 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(5), LEN=IDIMLEN(5))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4) .AND. &
       IDIMLEN(5) == SIZE(PFIELD,5) ) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X5[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X5',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X5


SUBROUTINE IO_READ_FIELD_NC4_X6(TPFILE, TPFIELD, PFIELD, KRESP)
TYPE(TFILEDATA),            INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),           INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:,:),INTENT(OUT)   :: PFIELD
INTEGER,                    INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)                              :: STATUS
INTEGER(KIND=IDCDF_KIND)                              :: INCID
INTEGER(KIND=IDCDF_KIND)                              :: IVARID
INTEGER(KIND=IDCDF_KIND)                              :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)                              :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND),DIMENSION(6)                 :: IDIMLEN
CHARACTER(LEN=30)                                     :: YVARNAME
INTEGER                                               :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

IF (IDIMS == 6 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(4), LEN=IDIMLEN(4))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(5), LEN=IDIMLEN(5))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(6), LEN=IDIMLEN(6))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF ( IDIMLEN(1) == SIZE(PFIELD,1) .AND. IDIMLEN(2) == SIZE(PFIELD,2) .AND. &
       IDIMLEN(3) == SIZE(PFIELD,3) .AND. IDIMLEN(4) == SIZE(PFIELD,4) .AND. &
       IDIMLEN(5) == SIZE(PFIELD,5) .AND. IDIMLEN(6) == SIZE(PFIELD,6) ) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, PFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X6[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_X6',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_X6


SUBROUTINE IO_READ_FIELD_NC4_N0(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
INTEGER,          INTENT(OUT)   :: KFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

!Can read either 4 or 8 byte integers
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT .OR. ITYPE == NF90_INT64) ) THEN
   ! Read variable
   STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
   IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
   END IF
   ! Read and check attributes of variable
   CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N0


SUBROUTINE IO_READ_FIELD_NC4_N1(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),         INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),        INTENT(INOUT) :: TPFIELD
INTEGER, DIMENSION(:),   INTENT(OUT)   :: KFIELD
INTEGER,                 INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

!NF90_INT1 is for the case a boolean was written
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT .OR. ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT1) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(KFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N1


SUBROUTINE IO_READ_FIELD_NC4_N2(TPFILE, TPFIELD, KFIELD, KRESP)
TYPE(TFILEDATA),         INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),        INTENT(INOUT) :: TPFIELD
INTEGER, DIMENSION(:,:), INTENT(OUT)   :: KFIELD
INTEGER,                 INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)        :: YVARNAME
INTEGER(KIND=IDCDF_KIND),DIMENSION(3) :: IDIMLEN
INTEGER                  :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

!Treat special case of a degenerated 3D array (3rd dimension size is 1)
IF (IDIMS==3) THEN
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(3), LEN=IDIMLEN(3))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  IF (IDIMLEN(3)==1) THEN
    CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)// &
                   ': reading 3D array with degenerated third dimension in 2D array for '//TRIM(YVARNAME))
    IDIMS = 2
  ELSE
    CALL PRINT_MSG(NVERB_FATAL,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': wrong number of dimensions for '//TRIM(YVARNAME))
  END IF
END IF

!NF90_INT1 is for the case a boolean was written
IF (IDIMS == SIZE(SHAPE(KFIELD)) .AND. (ITYPE == NF90_INT .OR. ITYPE == NF90_INT64 .OR. ITYPE == NF90_INT1) ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN(1))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(2), LEN=IDIMLEN(2))
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN(1) == SIZE(KFIELD,1) .AND. IDIMLEN(2) == SIZE(KFIELD,2)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, KFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_N2[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF
    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_N2',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_N2

SUBROUTINE IO_READ_FIELD_NC4_L0(TPFILE, TPFIELD, OFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
LOGICAL,          INTENT(OUT)   :: OFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP
INTEGER                  :: IFIELD

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

!NF90_INT1 is for the case a boolean was written
!Accept also INT and INT64 (for backward compatibility)
IF (IDIMS == 0 .AND. (ITYPE == NF90_INT1 .OR. ITYPE == NF90_INT .OR. ITYPE == NF90_INT64)  ) THEN
  ! Read variable
  STATUS = NF90_GET_VAR(INCID, IVARID, IFIELD)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF

  IF (IFIELD==0) THEN
    OFIELD = .FALSE.
  ELSE IF (IFIELD==1) THEN
    OFIELD = .TRUE.
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L0',TRIM(TPFILE%CNAME)//': invalid value in file for ' &
                                                           //TRIM(TPFIELD%CMNHNAME))
    OFIELD = .TRUE.
    IRESP = -112
  END IF

  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong size or type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_L0


SUBROUTINE IO_READ_FIELD_NC4_L1(TPFILE, TPFIELD, OFIELD, KRESP)
TYPE(TFILEDATA),     INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),    INTENT(INOUT) :: TPFIELD
LOGICAL,DIMENSION(:),INTENT(OUT)   :: OFIELD
INTEGER,             INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND) :: STATUS
INTEGER(KIND=IDCDF_KIND) :: INCID
INTEGER(KIND=IDCDF_KIND) :: IVARID
INTEGER(KIND=IDCDF_KIND) :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND) :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
INTEGER(KIND=IDCDF_KIND) :: IDIMLEN
CHARACTER(LEN=30)        :: YVARNAME
INTEGER                  :: IRESP
INTEGER                  :: JI
INTEGER,DIMENSION(SIZE(OFIELD)) :: IFIELD

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
  CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
  GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

!Neglect the time dimension (of size 1)
IF (TPFIELD%LTIMEDEP) IDIMS=IDIMS-1

!NF90_INT1 is for the case a boolean was written
!Accept also INT and INT64 (for backward compatibility)
IF (IDIMS == 1 .AND. (ITYPE == NF90_INT1 .OR. ITYPE == NF90_INT .OR. ITYPE == NF90_INT64)  ) THEN
  ! Check size of variable before reading
  STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
  IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))

  IF (IDIMLEN == SIZE(OFIELD)) THEN
    ! Read variable
    STATUS = NF90_GET_VAR(INCID, IVARID, IFIELD)
    IF (STATUS /= NF90_NOERR) THEN
      CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_L1[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
      GOTO 1000
    END IF

    DO JI=1,IDIMLEN
      IF (IFIELD(JI)==0) THEN
        OFIELD(JI) = .FALSE.
      ELSE IF (IFIELD(JI)==1) THEN
        OFIELD(JI) = .TRUE.
      ELSE
        OFIELD(JI) = .TRUE.
        IRESP = -112
      END IF
    END DO
    IF (IRESP==-112) THEN
      CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L1',TRIM(TPFILE%CNAME)//': invalid value(s) in file for ' &
                                                             //TRIM(TPFIELD%CMNHNAME))
    END IF

    ! Read and check attributes of variable
    CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' not read (wrong size)')
    IRESP = -3
  END IF
ELSE
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_L1',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                         ' not read (wrong number of dimensions or wrong type)')
  IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_L1


SUBROUTINE IO_READ_FIELD_NC4_C0(TPFILE, TPFIELD, HFIELD, KRESP)
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
CHARACTER(LEN=*), INTENT(OUT)   :: HFIELD
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)     :: STATUS
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: IVARID
INTEGER(KIND=IDCDF_KIND)     :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)     :: IDIMS   ! number of dimensions
INTEGER(KIND=IDCDF_KIND),DIMENSION(NF90_MAX_VAR_DIMS) :: IVDIMS
CHARACTER(LEN=30)            :: YVARNAME
CHARACTER(LEN=:),ALLOCATABLE :: YSTR
INTEGER(KIND=IDCDF_KIND)     :: IDIMLEN
INTEGER                      :: IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS, DIMIDS=IVDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 1 .AND. (ITYPE == NF90_CHAR) ) THEN
   ! Check size of variable before reading
   STATUS = NF90_INQUIRE_DIMENSION(INCID, IVDIMS(1), LEN=IDIMLEN)
   IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_INQUIRE_DIMENSION] '//TRIM(YVARNAME))
   !
   ALLOCATE(CHARACTER(LEN=IDIMLEN)::YSTR)
   ! Read variable
   STATUS = NF90_GET_VAR(INCID, IVARID, YSTR)
   IF (STATUS /= NF90_NOERR) THEN
     CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_C0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
     GOTO 1000
   END IF
   IF (LEN_TRIM(YSTR) > LEN(HFIELD)) &
     CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)//' truncated')
   HFIELD = TRIM(YSTR)
   DEALLOCATE(YSTR)

   ! Read and check attributes of variable
   CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP)
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_C0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_C0

SUBROUTINE IO_READ_FIELD_NC4_T0(TPFILE, TPFIELD, TPDATA, KRESP)
!
USE MODD_TYPE_DATE
!
USE MODE_DATETIME
!
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
TYPE (DATE_TIME), INTENT(OUT)   :: TPDATA
INTEGER,          INTENT(OUT)   :: KRESP  ! return-code

INTEGER(KIND=IDCDF_KIND)     :: STATUS
INTEGER(KIND=IDCDF_KIND)     :: INCID
INTEGER(KIND=IDCDF_KIND)     :: IVARID
INTEGER(KIND=IDCDF_KIND)     :: ITYPE   ! variable type
INTEGER(KIND=IDCDF_KIND)     :: IDIMS   ! number of dimensions
CHARACTER(LEN=30)            :: YVARNAME
CHARACTER(LEN=:),ALLOCATABLE :: YSTR
INTEGER(KIND=IDCDF_KIND)     :: IDIMLEN
INTEGER                      :: IDX,IRESP

CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))

IRESP = 0
! Get the Netcdf file ID
INCID = TPFILE%NNCID

CALL CLEANMNHNAME(TPFIELD%CMNHNAME,YVARNAME)

! Get variable ID, NDIMS and TYPE
STATUS = NF90_INQ_VARID(INCID, YVARNAME, IVARID)
IF (STATUS /= NF90_NOERR) THEN
   CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_T0[NF90_INQ_VARID] '//TRIM(YVARNAME),IRESP)
   GOTO 1000
END IF
STATUS = NF90_INQUIRE_VARIABLE(INCID, IVARID, XTYPE=ITYPE, NDIMS=IDIMS)
IF (STATUS /= NF90_NOERR) CALL HANDLE_ERR(STATUS,__LINE__,'IO_READ_FIELD_NC4_T0[NF90_INQUIRE_VARIABLE] '//TRIM(YVARNAME))

IF (IDIMS == 0 .AND. (ITYPE == NF90_FLOAT .OR. ITYPE == NF90_DOUBLE) ) THEN
  ! Read time
  STATUS = NF90_GET_VAR(INCID, IVARID, TPDATA%TIME)
  IF (STATUS /= NF90_NOERR) THEN
    CALL HANDLE_ERR(status,__LINE__,'IO_READ_FIELD_NC4_X0[NF90_GET_VAR] '//TRIM(YVARNAME),IRESP)
    GOTO 1000
  END IF
  ! Read and check attributes of variable
  CALL IO_READ_CHECK_FIELD_ATTR_NC4(TPFILE,TPFIELD,IVARID,IRESP,HCALENDAR='standard')
  ! Extract date from UNITS
  IDX =  INDEX(TPFIELD%CUNITS,'since ')
  READ(TPFIELD%CUNITS(IDX+6 :IDX+9), '( I4.4 )') TPDATA%TDATE%YEAR
  READ(TPFIELD%CUNITS(IDX+11:IDX+12),'( I2.2 )') TPDATA%TDATE%MONTH
  READ(TPFIELD%CUNITS(IDX+14:IDX+15),'( I2.2 )') TPDATA%TDATE%DAY
  ! Simple check (should catch most errors)
  IF ( TPDATA%TDATE%DAY<1 .OR. TPDATA%TDATE%DAY>31 .OR. TPDATA%TDATE%MONTH<1 .OR. TPDATA%TDATE%MONTH>12 ) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                           ' read date is invalid')
    IRESP = -3
  END IF
  ! Correct date and time (necessary for example if time is bigger than 86400 s)
  CALL DATETIME_CORRECTDATE(TPDATA)
ELSE
   CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_NC4_T0',TRIM(TPFILE%CNAME)//': '//TRIM(YVARNAME)// &
                                                          ' not read (wrong size or type)')
   IRESP = -3
END IF

1000 CONTINUE
KRESP = IRESP

END SUBROUTINE IO_READ_FIELD_NC4_T0

END MODULE MODE_NETCDF

#else
!
! External dummy subroutines
!
SUBROUTINE IO_WRITE_FIELD_NC4(A,B,C,D)
INTEGER :: A,B,C,D
PRINT *, 'IO_WRITE_FIELD_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_FIELD_NC4

SUBROUTINE IO_READ_FIELD_NC4(A,B,C,D)
INTEGER :: A,B,C,D
PRINT *, 'IO_READ_FIELD_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_READ_FIELD_NC4

SUBROUTINE IO_WRITE_HEADER_NC4(A,B)
INTEGER :: A,B
PRINT *, 'IO_WRITE_HEADER_NC4 empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE IO_WRITE_HEADER_NC4

SUBROUTINE CLEANIOCDF(A)
INTEGER :: A
PRINT *, 'CLEANIOCDF empty call. Compile with -DMNH_IOCDF4 flag to enable NetCDF4 I/Os.'
END SUBROUTINE CLEANIOCDF

#endif
