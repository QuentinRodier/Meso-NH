!MNH_LIC Copyright 1994-2018 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
MODULE MODE_READWRITE_LFI
! Modifications:
!  Philippe Wautelet: 05/2016-04/2018: new data structures and calls for I/O
!
USE MODD_IO_ll
USE MODD_PARAMETERS, ONLY: NLFIMAXCOMMENTLENGTH
!
USE MODE_FIELD, ONLY : TFIELDDATA
USE MODE_MSG
!
IMPLICIT NONE
!
PRIVATE
!
INTEGER, PARAMETER :: JPXKRK = NLFIMAXCOMMENTLENGTH
INTEGER, PARAMETER :: JPXFIE = 1.5E8
!
INTERFACE IO_READ_FIELD_LFI
   MODULE PROCEDURE IO_READ_FIELD_LFI_X0, IO_READ_FIELD_LFI_X1, &
                    IO_READ_FIELD_LFI_X2, IO_READ_FIELD_LFI_X3, &
                    IO_READ_FIELD_LFI_X4, IO_READ_FIELD_LFI_X5, &
                    IO_READ_FIELD_LFI_X6,                       &
                    IO_READ_FIELD_LFI_N0, IO_READ_FIELD_LFI_N1, &
                    IO_READ_FIELD_LFI_N2,                       &
                    IO_READ_FIELD_LFI_L0, IO_READ_FIELD_LFI_L1, &
                    IO_READ_FIELD_LFI_C0,                       &
                    IO_READ_FIELD_LFI_T0
END INTERFACE IO_READ_FIELD_LFI
!
INTERFACE IO_WRITE_FIELD_LFI
   MODULE PROCEDURE IO_WRITE_FIELD_LFI_X0,IO_WRITE_FIELD_LFI_X1, &
                    IO_WRITE_FIELD_LFI_X2,IO_WRITE_FIELD_LFI_X3, &
                    IO_WRITE_FIELD_LFI_X4,IO_WRITE_FIELD_LFI_X5, &
                    IO_WRITE_FIELD_LFI_X6,                       &
                    IO_WRITE_FIELD_LFI_N0,IO_WRITE_FIELD_LFI_N1, &
                    IO_WRITE_FIELD_LFI_N2,IO_WRITE_FIELD_LFI_N3, &
                    IO_WRITE_FIELD_LFI_L0,IO_WRITE_FIELD_LFI_L1, &
                    IO_WRITE_FIELD_LFI_C0,                       &
                    IO_WRITE_FIELD_LFI_T0
END INTERFACE IO_WRITE_FIELD_LFI
!
PUBLIC IO_READ_FIELD_LFI,IO_WRITE_FIELD_LFI
!
CONTAINS
!
SUBROUTINE IO_READ_FIELD_LFI_X0(TPFILE,TPFIELD,PFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,             INTENT(OUT)   :: PFIELD  ! array containing the data field
INTEGER,          INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_X0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = 1
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) PFIELD = TRANSFER(IWORK(IWORK(2)+3),PFIELD)
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_X0
!
!
SUBROUTINE IO_READ_FIELD_LFI_X1(TPFILE,TPFIELD,PFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),  INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA), INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:),INTENT(OUT)   :: PFIELD  ! array containing the data field
INTEGER,          INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_X1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) PFIELD = TRANSFER(IWORK(IWORK(2)+3:),PFIELD,SIZE(PFIELD))
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_X1
!
!
SUBROUTINE IO_READ_FIELD_LFI_X2(TPFILE,TPFIELD,PFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),    INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),   INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:),INTENT(OUT)   :: PFIELD  ! array containing the data field
INTEGER,            INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_X2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) PFIELD = RESHAPE( TRANSFER(IWORK(IWORK(2)+3:),PFIELD,SIZE(PFIELD)) , SHAPE(PFIELD) )
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_X2
!
!
SUBROUTINE IO_READ_FIELD_LFI_X3(TPFILE,TPFIELD,PFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),      INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),     INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:),INTENT(OUT)   :: PFIELD  ! array containing the data field
INTEGER,              INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_X3',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) PFIELD = RESHAPE( TRANSFER(IWORK(IWORK(2)+3:),PFIELD,SIZE(PFIELD)) , SHAPE(PFIELD) )
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_X3
!
!
SUBROUTINE IO_READ_FIELD_LFI_X4(TPFILE,TPFIELD,PFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),        INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),       INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:),INTENT(OUT)   :: PFIELD  ! array containing the data field
INTEGER,                INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_X4',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) PFIELD = RESHAPE( TRANSFER(IWORK(IWORK(2)+3:),PFIELD,SIZE(PFIELD)) , SHAPE(PFIELD) )
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_X4
!
!
SUBROUTINE IO_READ_FIELD_LFI_X5(TPFILE,TPFIELD,PFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),          INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),         INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:),INTENT(OUT)   :: PFIELD  ! array containing the data field
INTEGER,                  INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_X5',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) PFIELD = RESHAPE( TRANSFER(IWORK(IWORK(2)+3:),PFIELD,SIZE(PFIELD)) , SHAPE(PFIELD) )
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_X5
!
!
SUBROUTINE IO_READ_FIELD_LFI_X6(TPFILE,TPFIELD,PFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),            INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),           INTENT(INOUT) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:,:),INTENT(OUT)   :: PFIELD  ! array containing the data field
INTEGER,                    INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_X6',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) PFIELD = RESHAPE( TRANSFER(IWORK(IWORK(2)+3:),PFIELD,SIZE(PFIELD)) , SHAPE(PFIELD) )
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_X6
!
!
SUBROUTINE IO_READ_FIELD_LFI_N0(TPFILE,TPFIELD,KFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA), INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),INTENT(INOUT) :: TPFIELD
INTEGER,         INTENT(OUT)   :: KFIELD  ! array containing the data field
INTEGER,         INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_N0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = 1
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) KFIELD = IWORK(IWORK(2)+3)
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_N0
!
!
SUBROUTINE IO_READ_FIELD_LFI_N1(TPFILE,TPFIELD,KFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),     INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),    INTENT(INOUT) :: TPFIELD
INTEGER,DIMENSION(:),INTENT(OUT)   :: KFIELD  ! array containing the data field
INTEGER,             INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_N1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(KFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) KFIELD(:) = IWORK(IWORK(2)+3:)
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_N1
!
!
SUBROUTINE IO_READ_FIELD_LFI_N2(TPFILE,TPFIELD,KFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),       INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),      INTENT(INOUT) :: TPFIELD
INTEGER,DIMENSION(:,:),INTENT(OUT)   :: KFIELD  ! array containing the data field
INTEGER,               INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_N2',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(KFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) KFIELD(:,:) = RESHAPE(IWORK(IWORK(2)+3:),SHAPE(KFIELD))
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_N2
!
!
SUBROUTINE IO_READ_FIELD_LFI_L0(TPFILE,TPFIELD,OFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA), INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),INTENT(INOUT) :: TPFIELD
LOGICAL,         INTENT(OUT)   :: OFIELD  ! array containing the data field
INTEGER,         INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER                                  :: IFIELD
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_L0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = 1
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) THEN
  IFIELD = IWORK(IWORK(2)+3)
  IF (IFIELD==0) THEN
    OFIELD = .FALSE.
  ELSE IF (IFIELD==1) THEN
    OFIELD = .TRUE.
  ELSE
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L0',TRIM(TPFILE%CNAME)//': invalid value in file for ' &
                                                           //TRIM(TPFIELD%CMNHNAME))
    OFIELD = .TRUE.
    IRESP = -112
  END IF
END IF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_L0
!
!
SUBROUTINE IO_READ_FIELD_LFI_L1(TPFILE,TPFIELD,OFIELD,KRESP)
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),     INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),    INTENT(INOUT) :: TPFIELD
LOGICAL,DIMENSION(:),INTENT(OUT)   :: OFIELD  ! array containing the data field
INTEGER,             INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG
INTEGER                                  :: JI
INTEGER, DIMENSION(SIZE(OFIELD))         :: IFIELD
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_L1',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(OFIELD)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) THEN
  IFIELD(:) = IWORK(IWORK(2)+3:)
  DO JI=1,ILENG
    IF (IFIELD(JI)==0) THEN
      OFIELD(JI) = .FALSE.
    ELSE IF (IFIELD(JI)==1) THEN
      OFIELD(JI) = .TRUE.
    ELSE
      OFIELD(JI) = .TRUE.
      IRESP = -112
    END IF
  END DO
  IF (IRESP==-112) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_FIELD_LFI_L1',TRIM(TPFILE%CNAME)//': invalid value(s) in file for ' &
                                                           //TRIM(TPFIELD%CMNHNAME))
  END IF
END IF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_L1
!
!
SUBROUTINE IO_READ_FIELD_LFI_C0(TPFILE,TPFIELD,HFIELD,KRESP)
!
USE MODD_PARAMETERS, ONLY: NFILENAMELGTMAXLFI
!
USE MODE_MSG
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA), INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),INTENT(INOUT) :: TPFIELD
CHARACTER(LEN=*),INTENT(OUT)   :: HFIELD  ! array containing the data field
INTEGER,         INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP,ITOTAL
INTEGER                                  :: ILENG, ILENGMAX, JLOOP
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_C0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = LEN(HFIELD)
ILENGMAX = ILENG
!
!Special treatment for MY_NAME and DAD_NAME fields (for backward compatibility)
IF (TPFIELD%CMNHNAME=='MY_NAME' .OR. TPFIELD%CMNHNAME=='DAD_NAME') THEN
  ILENG = MIN(LEN(HFIELD),NFILENAMELGTMAXLFI)
  ILENGMAX = NFILENAMELGTMAXLFI
  IF (LEN(HFIELD)<NFILENAMELGTMAXLFI) &
        CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_FIELD_LFI_C0',TRIM(TPFILE%CNAME)// &
                      ': LEN(HFIELD)<NFILENAMELGTMAXLFI')
END IF
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,ILENGMAX,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) THEN
  DO JLOOP=1,ILENG
    HFIELD(JLOOP:JLOOP)=ACHAR(IWORK(IWORK(2)+2+JLOOP))
  END DO
END IF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_READ_FIELD_LFI_C0
!
!
SUBROUTINE IO_READ_FIELD_LFI_T0(TPFILE,TPFIELD,TPDATA,KRESP)
!
USE MODE_MSG
USE MODD_TYPE_DATE
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA), INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),INTENT(INOUT) :: TPFIELD
TYPE (DATE_TIME),INTENT(INOUT) :: TPDATA  ! array containing the data field
INTEGER,         INTENT(OUT)   :: KRESP   ! return-code if problems occured
!
!*      0.2   Declarations of local variables
!
INTEGER(KIND=LFI_INT)                    :: IRESP, ITOTAL
INTEGER                                  :: ILENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
LOGICAL                                  :: GGOOD
TYPE(TFIELDDATA)                         :: TZFIELD
INTEGER, DIMENSION(3)                    :: ITDATE    ! date array
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_FIELD_LFI_T0',TRIM(TPFILE%CNAME)//': reading '//TRIM(TPFIELD%CMNHNAME))
!
TZFIELD = TPFIELD
!
! Read date
!
TZFIELD%CMNHNAME = TRIM(TPFIELD%CMNHNAME)//'%TDATE'
TZFIELD%CCOMMENT = 'YYYYMMDD'
!
ILENG=SIZE(ITDATE)
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TZFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) THEN
  TPDATA%TDATE%YEAR  = IWORK(IWORK(2)+2+1)
  TPDATA%TDATE%MONTH = IWORK(IWORK(2)+2+2)
  TPDATA%TDATE%DAY   = IWORK(IWORK(2)+2+3)
END IF
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
IF (.NOT.GGOOD) THEN
  KRESP = IRESP
  RETURN
END IF
!
! Read time
!
TZFIELD%CMNHNAME = TRIM(TPFIELD%CMNHNAME)//'%TIME'
TZFIELD%CCOMMENT = 'SECONDS'
!
ILENG=1
!
CALL IO_READ_CHECK_FIELD_LFI(TPFILE,TZFIELD,ILENG,IWORK,ITOTAL,IRESP,GGOOD)
!
IF (GGOOD) TPDATA%TIME = TRANSFER(IWORK(IWORK(2)+3),TPDATA%TIME)
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
KRESP = IRESP
!
END SUBROUTINE IO_READ_FIELD_LFI_T0
!
!
SUBROUTINE IO_READ_CHECK_FIELD_LFI(TPFILE,TPFIELD,KLENG,KWORK,KTOTAL,KRESP,OGOOD)
!
TYPE(TFILEDATA),                         INTENT(IN)    :: TPFILE
TYPE(TFIELDDATA),                        INTENT(INOUT) :: TPFIELD
INTEGER,                                 INTENT(IN)    :: KLENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE,INTENT(OUT)   :: KWORK
INTEGER(KIND=LFI_INT),                   INTENT(OUT)   :: KTOTAL
INTEGER(KIND=LFI_INT),                   INTENT(OUT)   :: KRESP
LOGICAL,                                 INTENT(OUT)   :: OGOOD
!
INTEGER                      :: IERRLEVEL,IROW,J
INTEGER,DIMENSION(JPXKRK)    :: ICOMMENT
INTEGER(KIND=LFI_INT)        :: ICOMLEN,INUMBR,IPOSEX
CHARACTER(LEN=:),ALLOCATABLE :: YMSG
CHARACTER(LEN=12)            :: YRECLENGTH_FILE, YRECLENGTH_MEM
CHARACTER(LEN=12)            :: YVAL_FILE, YVAL_MEM
CHARACTER(LEN=JPXKRK)        :: YCOMMENT
CHARACTER(LEN=12)            :: YRESP
CHARACTER(LEN=LEN_HREC)      :: YRECFM
!
OGOOD = .TRUE.
!
YRECFM=TRIM(TPFIELD%CMNHNAME)
IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_LFI','field name was truncated to '&
                 //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
!
!*      2.a   LET'S GET SOME INFORMATION ON THE DESIRED ARTICLE
!
INUMBR = TPFILE%NLFIFLU
CALL LFINFO(KRESP,INUMBR,YRECFM,KTOTAL,IPOSEX)
!
IF (KRESP.NE.0) THEN
  WRITE(YRESP, '( I12 )') KRESP
  YMSG = 'RESP='//TRIM(ADJUSTL(YRESP))//' in call to LFINFO when reading '//TRIM(TPFIELD%CMNHNAME)//' in '//TRIM(TPFILE%CNAME)
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_LFI',YMSG)
  OGOOD = .FALSE.
  RETURN
ELSEIF (KTOTAL.EQ.0) THEN
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_LFI',TRIM(TPFILE%CNAME)//': record length is zero for ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  KRESP=-47
  OGOOD = .FALSE.
  RETURN
ELSEIF (KTOTAL.GT.JPXFIE) THEN
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_LFI',TRIM(TPFILE%CNAME)// &
                               ': record length exceeds the maximum value in FM for '//TRIM(TPFIELD%CMNHNAME))
  KRESP=-48
  OGOOD = .FALSE.
  RETURN
ENDIF
!
!*      2.b   UNFORMATTED DIRECT ACCESS READ OPERATION
!
ALLOCATE(KWORK(KTOTAL))
!
CALL LFILEC(KRESP,INUMBR,YRECFM,KWORK,KTOTAL)
IF (KRESP.NE.0) THEN
  WRITE(YRESP, '( I12 )') KRESP
  YMSG = 'RESP='//TRIM(ADJUSTL(YRESP))//' in call to LFILEC when reading '//TRIM(TPFIELD%CMNHNAME)//' in '//TRIM(TPFILE%CNAME)
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_LFI',YMSG)
  OGOOD = .FALSE.
  RETURN
ENDIF
!
!*      2.c   THE GRID INDICATOR AND THE COMMENT STRING
!*            ARE SEPARATED FROM THE DATA
!
ICOMLEN = KWORK(2)
IROW=KLENG+ICOMLEN+2
IF (KTOTAL.NE.IROW) THEN
  WRITE(YRECLENGTH_FILE,'(I12)') KTOTAL-2-ICOMLEN
  WRITE(YRECLENGTH_MEM, '(I12)') KLENG
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_LFI','wrong field size for '//TRIM(TPFIELD%CMNHNAME) &
                                     //' (expected: '//TRIM(ADJUSTL(YRECLENGTH_MEM))//                            &
                                     ', in file: '   //TRIM(ADJUSTL(YRECLENGTH_FILE))//')')
  KRESP=-63
  OGOOD = .FALSE.
  RETURN
ENDIF
!
IF (KWORK(1)/=TPFIELD%NGRID) THEN
  WRITE(YVAL_FILE,'(I12)') KWORK(1)
  WRITE(YVAL_MEM, '(I12)') TPFIELD%NGRID
  IF (TPFIELD%NDIMS==0) THEN
    IERRLEVEL = NVERB_WARNING
  ELSE
    IERRLEVEL = NVERB_ERROR
  END IF
  CALL PRINT_MSG(IERRLEVEL,'IO','IO_READ_CHECK_FIELD_LFI','expected GRID value ('//TRIM(ADJUSTL(YVAL_MEM))// &
                 ') is different than found in file ('//TRIM(ADJUSTL(YVAL_FILE))//') for variable '//TRIM(TPFIELD%CMNHNAME))
  TPFIELD%NGRID = KWORK(1)
  KRESP = -111 !Used later to broadcast modified metadata
ELSE
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_LFI','expected GRID    found in file for field ' &
                                                            //TRIM(TPFIELD%CMNHNAME))
ENDIF
!
YCOMMENT=''
SELECT CASE (ICOMLEN)
CASE(:-1)
  CALL PRINT_MSG(NVERB_ERROR,'IO','IO_READ_CHECK_FIELD_LFI',TRIM(TPFILE%CNAME)//': comment length is negative for ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  KRESP=-58
  OGOOD = .FALSE.
  RETURN
CASE(0)
  KRESP = 0
CASE(1:JPXKRK)
  ICOMMENT(1:ICOMLEN)=KWORK(3:ICOMLEN+2)
  DO J=1,ICOMLEN
    YCOMMENT(J:J)=CHAR(ICOMMENT(J))
  ENDDO
CASE(JPXKRK+1:)
  CALL PRINT_MSG(NVERB_WARNING,'IO','IO_READ_CHECK_FIELD_LFI',TRIM(TPFILE%CNAME)//': comment is too long in file for ' &
                                                                  //TRIM(TPFIELD%CMNHNAME))
  KRESP=-56
  RETURN
END SELECT
!
IF (TRIM(YCOMMENT)/=TRIM(TPFIELD%CCOMMENT)) THEN
  CALL PRINT_MSG(NVERB_INFO,'IO','IO_READ_CHECK_FIELD_LFI','expected COMMENT ('//TRIM(TPFIELD%CCOMMENT)// &
                 ') is different than found ('//TRIM(YCOMMENT)//') in file for field '//TRIM(TPFIELD%CMNHNAME))
  TPFIELD%CCOMMENT=TRIM(YCOMMENT)
  KRESP = -111 !Used later to broadcast modified metadata
ELSE
  CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_READ_CHECK_FIELD_LFI','expected COMMENT found in file for field ' &
                                                            //TRIM(TPFIELD%CMNHNAME))
END IF
!
END SUBROUTINE IO_READ_CHECK_FIELD_LFI
!
!
SUBROUTINE IO_WRITE_FIELD_LFI_X0(TPFILE,TPFIELD,PFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,                  INTENT(IN) :: PFIELD ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(KIND=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_X0','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = 1
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3) = TRANSFER(PFIELD,IWORK(1))
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_X0','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,TRIM(TPFIELD%CMNHNAME),IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_X0
!
SUBROUTINE IO_WRITE_FIELD_LFI_X1(TPFILE,TPFIELD,PFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:),     INTENT(IN) :: PFIELD ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_X1','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = TRANSFER(PFIELD,IWORK(1),SIZE(PFIELD))
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_X1','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_X1
!
SUBROUTINE IO_WRITE_FIELD_LFI_X2(TPFILE,TPFIELD,PFIELD,KRESP,KVERTLEVEL,KZFILE)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),TARGET,INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:),   INTENT(IN) :: PFIELD ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP  ! return-code if problems araised
INTEGER,OPTIONAL,      INTENT(IN) :: KVERTLEVEL ! Number of the vertical level (needed for Z-level splitted files)
INTEGER,OPTIONAL,      INTENT(IN) :: KZFILE     ! Number of the Z-level splitted file
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=4)                         :: YSUFFIX
CHARACTER(LEN=LEN(TPFIELD%CMNHNAME)+4)   :: YVARNAME
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
TYPE(TFILEDATA),POINTER                  :: TZFILE
!
IRESP=0
!
ILENG = SIZE(PFIELD)
IF (PRESENT(KVERTLEVEL)) THEN
  IF (.NOT.PRESENT(KZFILE)) THEN
    CALL PRINT_MSG(NVERB_ERROR,'IO','IO_WRITE_FIELD_LFI_X2','KZFILE argument not provided')
    RETURN
  END IF
  WRITE(YSUFFIX,'(I4.4)') KVERTLEVEL
  YVARNAME = TRIM(TPFIELD%CMNHNAME)//YSUFFIX
  IF (KZFILE>TPFILE%NSUBFILES_IOZ) CALL PRINT_MSG(NVERB_FATAL,'IO','IO_WRITE_FIELD_LFI_X2','KZFILE value too high')
  TZFILE => TPFILE%TFILES_IOZ(KZFILE)%TFILE
ELSE
  YVARNAME = TRIM(TPFIELD%CMNHNAME)
  TZFILE => TPFILE
ENDIF
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_X2','writing '//TRIM(YVARNAME))
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = TRANSFER(PFIELD,IWORK(1),SIZE(PFIELD))
  YRECFM=TRIM(YVARNAME)
  IF( LEN_TRIM(YVARNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_X2','field name was truncated to '&
                   //YRECFM//' for '//TRIM(YVARNAME))
  CALL LFIECR(IRESP,TZFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_X2
!
SUBROUTINE IO_WRITE_FIELD_LFI_X3(TPFILE,TPFIELD,PFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:),   INTENT(IN) :: PFIELD ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_X3','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = TRANSFER(PFIELD,IWORK(1),SIZE(PFIELD))
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_X3','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_X3
!
SUBROUTINE IO_WRITE_FIELD_LFI_X4(TPFILE,TPFIELD,PFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),          INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),         INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:),  INTENT(IN) :: PFIELD ! array containing the data field
INTEGER,                  INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_X4','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = TRANSFER(PFIELD,IWORK(1),SIZE(PFIELD))
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_X4','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_X4
!
SUBROUTINE IO_WRITE_FIELD_LFI_X5(TPFILE,TPFIELD,PFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),          INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),         INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:),INTENT(IN) :: PFIELD ! array containing the data field
INTEGER,                  INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_X5','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = TRANSFER(PFIELD,IWORK(1),SIZE(PFIELD))
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_X5','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_X5
!
SUBROUTINE IO_WRITE_FIELD_LFI_X6(TPFILE,TPFIELD,PFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),            INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),           INTENT(IN) :: TPFIELD
REAL,DIMENSION(:,:,:,:,:,:),INTENT(IN) :: PFIELD ! array containing the data field
INTEGER,                    INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_X6','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(PFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = TRANSFER(PFIELD,IWORK(1),SIZE(PFIELD))
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_X6','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_X6
!
SUBROUTINE IO_WRITE_FIELD_LFI_N0(TPFILE,TPFIELD,KFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
INTEGER,                 INTENT(IN) :: KFIELD ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_N0','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = 1
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3)=KFIELD
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_N0','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_N0
!
SUBROUTINE IO_WRITE_FIELD_LFI_N1(TPFILE,TPFIELD,KFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
INTEGER,DIMENSION(:),    INTENT(IN) :: KFIELD ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_N1','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(KFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = KFIELD(:)
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_N1','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_N1
!
SUBROUTINE IO_WRITE_FIELD_LFI_N2(TPFILE,TPFIELD,KFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),       INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),      INTENT(IN) :: TPFIELD
INTEGER,DIMENSION(:,:),INTENT(IN) :: KFIELD ! array containing the data field
INTEGER,               INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_N2','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(KFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = RESHAPE( KFIELD(:,:) , (/ SIZE(KFIELD) /) )
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_N2','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_N2
!
SUBROUTINE IO_WRITE_FIELD_LFI_N3(TPFILE,TPFIELD,KFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
INTEGER,DIMENSION(:,:,:),INTENT(IN) :: KFIELD ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_N3','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(KFIELD)
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = RESHAPE( KFIELD(:,:,:) , (/ SIZE(KFIELD) /) )
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_N3','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_N3
!
SUBROUTINE IO_WRITE_FIELD_LFI_L0(TPFILE,TPFIELD,OFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
LOGICAL,                 INTENT(IN) :: OFIELD ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: IFIELD
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_L0','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = 1
!
!Convert LOGICAL to INTEGER (LOGICAL format not supported by LFI files)
IF (OFIELD) THEN
  IFIELD = 1
ELSE
  IFIELD = 0
END IF
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3)=IFIELD
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_L0','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_L0
!
SUBROUTINE IO_WRITE_FIELD_LFI_L1(TPFILE,TPFIELD,OFIELD,KRESP)
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
LOGICAL,DIMENSION(:),    INTENT(IN) :: OFIELD ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER, DIMENSION(SIZE(OFIELD))         :: IFIELD
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_L1','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG = SIZE(OFIELD)
!
!Convert LOGICAL to INTEGER (LOGICAL format not supported by LFI files)
WHERE (OFIELD)
  IFIELD = 1
ELSEWHERE
  IFIELD = 0
END WHERE
!
CALL WRITE_PREPARE(TPFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TPFIELD%CCOMMENT)+3:) = IFIELD(:)
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_L1','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_L1
!
SUBROUTINE IO_WRITE_FIELD_LFI_C0(TPFILE,TPFIELD,HFIELD,KRESP)
!
USE MODD_PARAMETERS, ONLY: NFILENAMELGTMAXLFI
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
CHARACTER(LEN=*),        INTENT(IN) :: HFIELD ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG, ILENGMAX, JLOOP
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_C0','writing '//TRIM(TPFIELD%CMNHNAME))
!
ILENG=LEN(HFIELD)
ILENGMAX = ILENG
IF (ILENG==0) ILENGMAX=1
!
!Special treatment for MY_NAME and DAD_NAME fields (for backward compatibility)
IF (TPFIELD%CMNHNAME=='MY_NAME' .OR. TPFIELD%CMNHNAME=='DAD_NAME') THEN
  ILENG = MIN(LEN(HFIELD),NFILENAMELGTMAXLFI)
  ILENGMAX = NFILENAMELGTMAXLFI
  IF (LEN_TRIM(HFIELD)>ILENGMAX) &
        CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_C0',TRIM(TPFILE%CNAME)// &
                      ': MY_NAME was truncated from '//TRIM(HFIELD)//' to '//HFIELD(1:NFILENAMELGTMAXLFI))
END IF
!
CALL WRITE_PREPARE(TPFIELD,ILENGMAX,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  DO JLOOP=1,ILENG
    IWORK(LEN(TPFIELD%CCOMMENT)+2+JLOOP)=IACHAR(HFIELD(JLOOP:JLOOP))
  END DO
  !Pad with blank characters
  DO JLOOP=ILENG+1,ILENGMAX
      IWORK(LEN(TPFIELD%CCOMMENT)+2+JLOOP)=IACHAR(' ')
  END DO
  YRECFM=TRIM(TPFIELD%CMNHNAME)
  IF( LEN_TRIM(TPFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_C0','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TPFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_C0
!
SUBROUTINE IO_WRITE_FIELD_LFI_T0(TPFILE,TPFIELD,TPDATA,KRESP)
!
USE MODD_TYPE_DATE
!
IMPLICIT NONE
!
!*      0.1   Declarations of arguments
!
TYPE(TFILEDATA),         INTENT(IN) :: TPFILE
TYPE(TFIELDDATA),        INTENT(IN) :: TPFIELD
TYPE (DATE_TIME),        INTENT(IN) :: TPDATA ! array containing the data field
INTEGER,                 INTENT(OUT):: KRESP  ! return-code if problems araised
!
!*      0.2   Declarations of local variables
!
INTEGER                                  :: ILENG
INTEGER(kind=LFI_INT)                    :: IRESP, ITOTAL
TYPE(TFIELDDATA)                         :: TZFIELD
INTEGER, DIMENSION(3)                    :: ITDATE    ! date array
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE :: IWORK
CHARACTER(LEN=LEN_HREC)                  :: YRECFM
!
CALL PRINT_MSG(NVERB_DEBUG,'IO','IO_WRITE_FIELD_LFI_T0','writing '//TRIM(TPFIELD%CMNHNAME))
!
TZFIELD = TPFIELD
!
! Write date
!
TZFIELD%CMNHNAME = TRIM(TPFIELD%CMNHNAME)//'%TDATE'
TZFIELD%CCOMMENT = 'YYYYMMDD'
ITDATE(1)=TPDATA%TDATE%YEAR
ITDATE(2)=TPDATA%TDATE%MONTH
ITDATE(3)=TPDATA%TDATE%DAY
ILENG=SIZE(ITDATE)
!
CALL WRITE_PREPARE(TZFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TZFIELD%CCOMMENT)+3:)=ITDATE(:)
  YRECFM=TRIM(TZFIELD%CMNHNAME)
  IF( LEN_TRIM(TZFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_T0','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TZFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
IF (IRESP/=0) THEN
  KRESP = IRESP
  RETURN
END IF
!
! Write time
!
TZFIELD%CMNHNAME = TRIM(TPFIELD%CMNHNAME)//'%TIME'
TZFIELD%CCOMMENT = 'SECONDS'
ILENG=1
!
CALL WRITE_PREPARE(TZFIELD,ILENG,IWORK,ITOTAL,IRESP)
!
IF (IRESP==0) THEN
  IWORK(LEN(TZFIELD%CCOMMENT)+3) = TRANSFER(TPDATA%TIME,IWORK(1))
  YRECFM=TRIM(TZFIELD%CMNHNAME)
  IF( LEN_TRIM(TZFIELD%CMNHNAME) > LEN(YRECFM) ) &
    CALL PRINT_MSG(NVERB_WARNING,'IO','IO_WRITE_FIELD_LFI_T0','field name was truncated to '&
                   //YRECFM//' for '//TRIM(TZFIELD%CMNHNAME))
  CALL LFIECR(IRESP,TPFILE%NLFIFLU,YRECFM,IWORK,ITOTAL)
ENDIF
!
KRESP=IRESP
!
IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
!
END SUBROUTINE IO_WRITE_FIELD_LFI_T0
!
SUBROUTINE WRITE_PREPARE(TPFIELD,KLENG,KWORK,KTOTAL,KRESP)
!
TYPE(TFIELDDATA),                        INTENT(IN)    :: TPFIELD
INTEGER,                                 INTENT(IN)    :: KLENG
INTEGER(KIND=8),DIMENSION(:),ALLOCATABLE,INTENT(INOUT) :: KWORK
INTEGER(kind=LFI_INT),                   INTENT(OUT)   :: KTOTAL
INTEGER(kind=LFI_INT),                   INTENT(OUT)   :: KRESP
!
INTEGER                   :: ICOMLEN
INTEGER                   :: J
INTEGER,DIMENSION(JPXKRK) :: ICOMMENT
!
ICOMLEN = LEN(TPFIELD%CCOMMENT)
KRESP = 0
!
IF (KLENG.LE.0) THEN
  KRESP=-40
  RETURN
ELSEIF (KLENG.GT.JPXFIE) THEN
  KRESP=-43
  RETURN
ELSEIF ((TPFIELD%NGRID.LT.0).OR.(TPFIELD%NGRID.GT.8)) THEN
  KRESP=-46
  RETURN
ENDIF
!
KTOTAL=KLENG+1+ICOMLEN+1
ALLOCATE(KWORK(KTOTAL))
!
KWORK(1)=TPFIELD%NGRID
!
SELECT CASE (ICOMLEN)
CASE(0)
  KWORK(2)=ICOMLEN
CASE(1:JPXKRK)
  DO J=1,ICOMLEN
    ICOMMENT(J)=ICHAR(TPFIELD%CCOMMENT(J:J))
  ENDDO
  KWORK(2)=ICOMLEN
  KWORK(3:ICOMLEN+2)=ICOMMENT(1:ICOMLEN)
CASE(JPXKRK+1:)
  CALL PRINT_MSG(NVERB_WARNING,'IO','WRITE_PREPARE','comment is too long')
  KRESP = -57
END SELECT
!
END SUBROUTINE WRITE_PREPARE
!
END MODULE MODE_READWRITE_LFI
