!MNH_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------
!--------------- special set of characters for CVS information
!-----------------------------------------------------------------
! $Source$
! $Name$ 
! $Revision$ 
! $Date$
!-----------------------------------------------------------------
!-----------------------------------------------------------------

!
! This file contains all the user IO routines. All these external routines have
! an interface in the modi_allio.f90 file.
!

!
! Routines found in the MODE_IO_ll module : INITIO_ll, OPEN_ll, CLOSE_ll, FLUSH_ll
!
SUBROUTINE INITIO_ll()
USE MODE_IO_ll, ONLY : E_INITIO_ll=>INITIO_ll
IMPLICIT NONE 

CALL E_INITIO_ll()

END SUBROUTINE INITIO_ll

SUBROUTINE OPEN_ll(UNIT,FILE,MODE,LFIPAR,COMM,STATUS,ACCESS,  &
     IOSTAT,FORM,RECL,BLANK,POSITION,ACTION,DELIM,PAD,OPARALLELIO)
USE MODE_IO_ll, ONLY : E_OPEN_ll=>OPEN_ll
USE MODD_IO_ll, ONLY : LFIPARAM
IMPLICIT NONE 

INTEGER,         INTENT(OUT)           :: UNIT  !! Different from fortran OPEN
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: FILE
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: MODE
TYPE(LFIPARAM),  POINTER,     OPTIONAL :: LFIPAR
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: STATUS
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: ACCESS
INTEGER,         INTENT(OUT)           :: IOSTAT
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: FORM
INTEGER,         INTENT(IN),  OPTIONAL :: RECL
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: BLANK
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: POSITION
CHARACTER(len=*),INTENT(IN)            :: ACTION
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: DELIM
CHARACTER(len=*),INTENT(IN),  OPTIONAL :: PAD
INTEGER,         INTENT(IN),  OPTIONAL :: COMM
LOGICAL,         INTENT(IN),  OPTIONAL :: OPARALLELIO

IF ( PRESENT(OPARALLELIO) ) THEN
  CALL E_OPEN_ll(UNIT,FILE,MODE,LFIPAR,COMM,STATUS,ACCESS,  &
      IOSTAT,FORM,RECL,BLANK,POSITION,ACTION,DELIM,PAD,OPARALLELIO=OPARALLELIO)
ELSE
  CALL E_OPEN_ll(UNIT,FILE,MODE,LFIPAR,COMM,STATUS,ACCESS,  &
      IOSTAT,FORM,RECL,BLANK,POSITION,ACTION,DELIM,PAD)
ENDIF

END SUBROUTINE OPEN_ll

SUBROUTINE CLOSE_ll(HFILE,IOSTAT,STATUS,OPARALLELIO)
USE MODE_IO_ll, ONLY : E_CLOSE_ll=>CLOSE_ll
IMPLICIT NONE 

CHARACTER(LEN=*), INTENT(IN)            :: HFILE
INTEGER,          INTENT(OUT), OPTIONAL :: IOSTAT
CHARACTER(LEN=*), INTENT(IN),  OPTIONAL :: STATUS
LOGICAL,          INTENT(IN),  OPTIONAL :: OPARALLELIO

IF( PRESENT(OPARALLELIO) ) THEN
  CALL E_CLOSE_ll(HFILE,IOSTAT,STATUS,OPARALLELIO=OPARALLELIO)
ELSE
  CALL E_CLOSE_ll(HFILE,IOSTAT,STATUS)
ENDIF

END SUBROUTINE CLOSE_ll

SUBROUTINE FLUSH_ll(HFILE,IRESP)
USE MODE_IO_ll, ONLY : E_FLUSH_ll=>FLUSH_ll
IMPLICIT NONE 

CHARACTER(LEN=*), INTENT(IN)            :: HFILE
INTEGER,          INTENT(OUT), OPTIONAL :: IRESP

CALL E_FLUSH_ll(HFILE,IRESP)

END SUBROUTINE FLUSH_ll


!
! Routines found in the MODE_FM module : FMATTR_ll, FMLOOK_ll, FMOPEN_ll, FMCLOS_ll
!
SUBROUTINE SET_FMPACK_ll(O1D,O2D,OPACK)
USE MODE_FM, ONLY : E_SET_FMPACK_ll=>SET_FMPACK_ll
LOGICAL, INTENT(IN) :: O1D,O2D,OPACK

CALL E_SET_FMPACK_ll(O1D,O2D,OPACK)

END SUBROUTINE SET_FMPACK_ll

SUBROUTINE FMATTR_ll(HFILEM,HFIPRI,KNUMBR,KRESP)
USE MODE_FM, ONLY : E_FMATTR_ll=>FMATTR_ll
IMPLICIT NONE 
CHARACTER(LEN=*), INTENT(IN)  :: HFILEM
CHARACTER(LEN=*), INTENT(IN)  :: HFIPRI
INTEGER,          INTENT(OUT) :: KNUMBR
INTEGER,          INTENT(OUT) :: KRESP

CALL E_FMATTR_ll(HFILEM,HFIPRI,KNUMBR,KRESP)

END SUBROUTINE FMATTR_ll

SUBROUTINE FMLOOK_ll(HFILEM,HFIPRI,KNUMBR,KRESP)
USE MODE_FM, ONLY : E_FMLOOK_ll=>FMLOOK_ll
IMPLICIT NONE 
CHARACTER(LEN=*), INTENT(IN)  :: HFILEM
CHARACTER(LEN=*), INTENT(IN)  :: HFIPRI
INTEGER,          INTENT(OUT) :: KNUMBR
INTEGER,          INTENT(OUT) :: KRESP

CALL E_FMLOOK_ll(HFILEM,HFIPRI,KNUMBR,KRESP)

END SUBROUTINE FMLOOK_ll

SUBROUTINE FMOPEN_ll(HFILEM,HACTION,HFIPRI,KNPRAR,KFTYPE,KVERB,KNINAR&
     & ,KRESP,OPARALLELIO)
USE MODE_FM, ONLY : E_FMOPEN_ll=>FMOPEN_ll
IMPLICIT NONE 
CHARACTER(LEN=*),INTENT(IN) ::HFILEM  ! name of the file.
CHARACTER(LEN=*),INTENT(IN) ::HACTION ! Action upon the file
                                      ! 'READ' or 'WRITE'
CHARACTER(LEN=*),INTENT(IN) ::HFIPRI  ! file for prints in FM.
INTEGER,         INTENT(IN) ::KNPRAR  ! number of predicted
                                      ! articles  (not vital).
INTEGER,         INTENT(IN) ::KFTYPE  ! type of FM-file.
INTEGER,         INTENT(IN) ::KVERB   ! level of verbose.
INTEGER,         INTENT(OUT)::KNINAR  ! number of articles initially present in the file.
INTEGER,         INTENT(OUT)::KRESP   ! return-code if a problem araised.
LOGICAL,         INTENT(IN),  OPTIONAL :: OPARALLELIO

IF( PRESENT(OPARALLELIO) ) THEN
  CALL E_FMOPEN_ll(HFILEM,HACTION,HFIPRI,KNPRAR,KFTYPE,KVERB,KNINAR,KRESP,OPARALLELIO=OPARALLELIO)
ELSE
  CALL E_FMOPEN_ll(HFILEM,HACTION,HFIPRI,KNPRAR,KFTYPE,KVERB,KNINAR,KRESP)
ENDIF

END SUBROUTINE FMOPEN_ll

SUBROUTINE FMCLOS_ll(HFILEM,HSTATU,HFIPRI,KRESP,OPARALLELIO)
USE MODE_FM, ONLY : E_FMCLOS_ll=>FMCLOS_ll
IMPLICIT NONE
CHARACTER(LEN=*),     INTENT(IN) ::HFILEM  ! file name
CHARACTER(LEN=*),     INTENT(IN) ::HSTATU  ! status for the closed file
CHARACTER(LEN=*),     INTENT(IN) ::HFIPRI  ! file for prints in FM
INTEGER,              INTENT(OUT)::KRESP   ! return-code if problems araised
LOGICAL,         INTENT(IN),  OPTIONAL :: OPARALLELIO

IF( PRESENT(OPARALLELIO) ) THEN
  CALL E_FMCLOS_ll(HFILEM,HSTATU,HFIPRI,KRESP,OPARALLELIO=OPARALLELIO)
ELSE
  CALL E_FMCLOS_ll(HFILEM,HSTATU,HFIPRI,KRESP)
ENDIF

END SUBROUTINE FMCLOS_ll
!
! Routines found in the MODE_GATHER_ll module : GATHERALL_xx
!
SUBROUTINE GATHERALL_X1(HDIR,PSEND,PRECV,KRESP)
USE MODE_GATHER_ll, ONLY : E_GATHERALL_X1=>GATHERALL_X1
IMPLICIT NONE 
CHARACTER(LEN=*),  INTENT(IN) :: HDIR
REAL,DIMENSION(:), INTENT(IN) :: PSEND
REAL,DIMENSION(:), INTENT(INOUT):: PRECV
INTEGER,           INTENT(INOUT):: KRESP

CALL E_GATHERALL_X1(HDIR,PSEND,PRECV,KRESP)

END SUBROUTINE GATHERALL_X1
  
SUBROUTINE GATHERALL_X2(HDIR,PSEND,PRECV,KRESP)
USE MODE_GATHER_ll, ONLY : E_GATHERALL_X2=>GATHERALL_X2
IMPLICIT NONE 
CHARACTER(LEN=*),    INTENT(IN) :: HDIR
REAL,DIMENSION(:,:), INTENT(IN) :: PSEND
REAL,DIMENSION(:,:), INTENT(INOUT):: PRECV
INTEGER,             INTENT(INOUT):: KRESP

CALL E_GATHERALL_X2(HDIR,PSEND,PRECV,KRESP)

END SUBROUTINE GATHERALL_X2
  
SUBROUTINE GATHERALL_X3(HDIR,PSEND,PRECV,KRESP)
USE MODE_GATHER_ll, ONLY : E_GATHERALL_X3=>GATHERALL_X3
IMPLICIT NONE
CHARACTER(LEN=*),      INTENT(IN) :: HDIR
REAL,DIMENSION(:,:,:), INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:), INTENT(INOUT):: PRECV
INTEGER,               INTENT(INOUT):: KRESP

CALL E_GATHERALL_X3(HDIR,PSEND,PRECV,KRESP)

END SUBROUTINE GATHERALL_X3
  
SUBROUTINE GATHERALL_N1(HDIR,KSEND,KRECV,KRESP)
USE MODE_GATHER_ll, ONLY : E_GATHERALL_N1=>GATHERALL_N1
IMPLICIT NONE
CHARACTER(LEN=*),     INTENT(IN) :: HDIR
INTEGER,DIMENSION(:), INTENT(IN) :: KSEND
INTEGER,DIMENSION(:), INTENT(INOUT):: KRECV
INTEGER,              INTENT(INOUT):: KRESP

CALL E_GATHERALL_N1(HDIR,KSEND,KRECV,KRESP)

END SUBROUTINE GATHERALL_N1

SUBROUTINE GATHERALL_N2(HDIR,KSEND,KRECV,KRESP)
USE MODE_GATHER_ll, ONLY : E_GATHERALL_N2=>GATHERALL_N2
IMPLICIT NONE
CHARACTER(LEN=*),       INTENT(IN) :: HDIR
INTEGER,DIMENSION(:,:), INTENT(IN) :: KSEND
INTEGER,DIMENSION(:,:), INTENT(INOUT):: KRECV
INTEGER,                INTENT(INOUT):: KRESP

CALL E_GATHERALL_N2(HDIR,KSEND,KRECV,KRESP)

END SUBROUTINE GATHERALL_N2
