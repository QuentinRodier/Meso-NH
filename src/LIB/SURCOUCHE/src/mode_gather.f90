!MNH_LIC Copyright 1994-2018 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!-----------------------------------------------------------------

#ifdef MNH_MPI_DOUBLE_PRECISION
#define MPI_FLOAT MPI_DOUBLE_PRECISION
#else
#define MPI_FLOAT MPI_REAL
#endif

MODULE MODE_GATHER_ll

! Modifications:
!   J.Escobar 10/02/2012 : Bug , in MPI_RECV replace MPI_STATUSES_IGNORE
!                          with MPI_STATUS_IGNORE
!   J.Escobar 22/05/2012 : Bug in ISEND with non-contiguous buffer , reintroduce intermediate buffer
!  Philippe Wautelet: 05/2016-04/2018: new data structures and calls for I/O
!
USE MODD_MPIF
!JUANZ
USE MODD_VAR_ll, ONLY : NMNH_COMM_WORLD
!JUANZ

IMPLICIT NONE 

PRIVATE

!INCLUDE 'mpif.h'

INTERFACE GATHERALL_FIELD_ll
  MODULE PROCEDURE GATHERALL_X1, GATHERALL_X2, GATHERALL_X3,&
       & GATHERALL_N1, GATHERALL_N2
END INTERFACE

INTERFACE GATHER_XXFIELD
  MODULE PROCEDURE GATHERXX_X1,GATHERXX_X2,GATHERXX_X3,GATHERXX_X4,GATHERXX_X5,&
       & GATHERXX_X6,GATHERXX_N1,GATHERXX_N2,GATHERXX_N3,GATHERXX_L1
END INTERFACE

INTERFACE GATHER_XYFIELD
  MODULE PROCEDURE GATHERXY_X2,GATHERXY_X3,GATHERXY_X4,GATHERXY_X5,GATHERXY_X6,&
       & GATHERXY_N2,GATHERXY_N3
END INTERFACE

PUBLIC GATHER_XXFIELD,GATHER_XYFIELD,GATHERALL_FIELD_ll,GATHERALL_X1,&
     & GATHERALL_X2,GATHERALL_X3,GATHERALL_N1,GATHERALL_N2

PUBLIC GET_DOMWRITE_ll ! for testing only

CONTAINS 
!
! Gatherall des champs
!
SUBROUTINE GATHERALL_X1(HDIR,PSEND,PRECV,KRESP)
CHARACTER(LEN=*),  INTENT(IN) :: HDIR
REAL,DIMENSION(:), INTENT(IN) :: PSEND
REAL,DIMENSION(:), INTENT(INOUT):: PRECV
INTEGER,           INTENT(INOUT):: KRESP

INTEGER :: IROOT

!INCLUDE 'mpif.h'

KRESP = 0
IROOT = 1

IF (HDIR == 'XX' .OR. HDIR == 'YY') THEN
  CALL GATHER_XXFIELD(HDIR,PSEND,PRECV,IROOT,NMNH_COMM_WORLD)
ELSE 
  KRESP =-1
  PRINT *,'Error GATHERALL_X1'
END IF
! PRECV variable of IROOT processor contains the global field
CALL MPI_BCAST(PRECV,SIZE(PRECV),MPI_FLOAT,IROOT-1,NMNH_COMM_WORLD,KRESP)

END SUBROUTINE GATHERALL_X1

SUBROUTINE GATHERALL_X2(HDIR,PSEND,PRECV,KRESP)
CHARACTER(LEN=*),    INTENT(IN) :: HDIR
REAL,DIMENSION(:,:), INTENT(IN) :: PSEND
REAL,DIMENSION(:,:), INTENT(INOUT):: PRECV
INTEGER,             INTENT(INOUT):: KRESP

INTEGER :: IROOT

!INCLUDE 'mpif.h'

KRESP = 0
IROOT = 1

IF (HDIR == 'XX' .OR. HDIR == 'YY') THEN
  CALL GATHER_XXFIELD(HDIR,PSEND,PRECV,IROOT,NMNH_COMM_WORLD)
ELSE IF (HDIR == 'XY') THEN
  CALL GATHER_XYFIELD(PSEND,PRECV,IROOT,NMNH_COMM_WORLD)
ELSE
  PRINT *,'Error GATHERALL_X2'
END IF
! PRECV variable of IROOT processor contains the global field
CALL MPI_BCAST(PRECV,SIZE(PRECV),MPI_FLOAT,IROOT-1,NMNH_COMM_WORLD,KRESP)

END SUBROUTINE GATHERALL_X2

SUBROUTINE GATHERALL_X3(HDIR,PSEND,PRECV,KRESP)
CHARACTER(LEN=*),      INTENT(IN) :: HDIR
REAL,DIMENSION(:,:,:), INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:), INTENT(INOUT):: PRECV
INTEGER,               INTENT(INOUT):: KRESP

INTEGER :: IROOT

!INCLUDE 'mpif.h'

KRESP = 0
IROOT = 1

IF (HDIR == 'XX' .OR. HDIR == 'YY') THEN
  CALL GATHER_XXFIELD(HDIR,PSEND,PRECV,IROOT,NMNH_COMM_WORLD)
ELSE IF (HDIR == 'XY') THEN
  CALL GATHER_XYFIELD(PSEND,PRECV,IROOT,NMNH_COMM_WORLD)
ELSE
  PRINT *,'Error GATHERALL_X3'
  KRESP = -1
END IF
! PRECV variable of IROOT processor contains the global field
CALL MPI_BCAST(PRECV,SIZE(PRECV),MPI_FLOAT,IROOT-1,NMNH_COMM_WORLD,KRESP)

END SUBROUTINE GATHERALL_X3


SUBROUTINE GATHERALL_N1(HDIR,KSEND,KRECV,KRESP)
CHARACTER(LEN=*),     INTENT(IN) :: HDIR
INTEGER,DIMENSION(:), INTENT(IN) :: KSEND
INTEGER,DIMENSION(:), INTENT(INOUT):: KRECV
INTEGER,              INTENT(INOUT):: KRESP

INTEGER :: IROOT

!INCLUDE 'mpif.h'

KRESP = 0
IROOT = 1

IF (HDIR == 'XX' .OR. HDIR == 'YY') THEN
  CALL GATHER_XXFIELD(HDIR,KSEND,KRECV,IROOT,NMNH_COMM_WORLD)
ELSE 
  PRINT *,'Error GATHERALL_N1'
END IF
! KRECV variable of IROOT processor contains the global field
CALL MPI_BCAST(KRECV,SIZE(KRECV),MPI_INTEGER,IROOT-1,NMNH_COMM_WORLD,KRESP)

END SUBROUTINE GATHERALL_N1

SUBROUTINE GATHERALL_N2(HDIR,KSEND,KRECV,KRESP)
CHARACTER(LEN=*),       INTENT(IN) :: HDIR
INTEGER,DIMENSION(:,:), INTENT(IN) :: KSEND
INTEGER,DIMENSION(:,:), INTENT(INOUT):: KRECV
INTEGER,                INTENT(INOUT):: KRESP

INTEGER :: IROOT

!INCLUDE 'mpif.h'

KRESP = 0
IROOT = 1

IF (HDIR == 'XX' .OR. HDIR == 'YY') THEN
  CALL GATHER_XXFIELD(HDIR,KSEND,KRECV,IROOT,NMNH_COMM_WORLD)
ELSE IF (HDIR == 'XY') THEN
  CALL GATHER_XYFIELD(KSEND,KRECV,IROOT,NMNH_COMM_WORLD)
ELSE
  PRINT *,'Error GATHERALL_N2'
END IF
! KRECV variable of IROOT processor contains the global field
CALL MPI_BCAST(KRECV,SIZE(KRECV),MPI_INTEGER,IROOT-1,NMNH_COMM_WORLD,KRESP)

END SUBROUTINE GATHERALL_N2


!
! Gather des champs XX (ou YY)
!
SUBROUTINE GATHERXX_X1(HDIR,PSEND,PRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC
USE MODD_VAR_ll, ONLY : MNH_STATUSES_IGNORE

CHARACTER(LEN=*),        INTENT(IN) :: HDIR
REAL,DIMENSION(:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                 INTENT(IN) :: KROOT
INTEGER,                 INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                     :: JI
INTEGER                     :: IXO,IXE,IYO,IYE
INTEGER                     :: IGXO,IGXE,IGYO,IGYE
REAL, DIMENSION(:), POINTER :: XP
INTEGER                     :: IERR
INTEGER                     :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

INTEGER                     :: REQ(1)
INTEGER                     :: NB_REQ

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)
IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      XP=>PRECV(IGXO:IGXE)
      IF (JI == KROOT) THEN 
        XP = PSEND(IXO:IXE)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      XP=>PRECV(IGYO:IGYE)
      IF (JI==KROOT) THEN 
        XP = PSEND(IYO:IYE)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    XP=>PSEND(IXO:IXE)
    NB_REQ = 1
    CALL MPI_ISEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,REQ(NB_REQ),IERR)
    CALL MPI_WAITALL(NB_REQ,REQ,MNH_STATUSES_IGNORE,IERR)
    !CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    XP=>PSEND(IYO:IYE)
    NB_REQ = 1
    CALL MPI_ISEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,REQ(NB_REQ),IERR)
    CALL MPI_WAITALL(NB_REQ,REQ,MNH_STATUSES_IGNORE,IERR)
    !CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_X1


SUBROUTINE GATHERXX_X2(HDIR,PSEND,PRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),          INTENT(IN) :: HDIR
REAL,DIMENSION(:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                   INTENT(IN) :: KROOT
INTEGER,                   INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                     :: JI
INTEGER                     :: IXO,IXE,IYO,IYE
INTEGER                     :: IGXO,IGXE,IGYO,IGYE
REAL, DIMENSION(:,:), POINTER :: XP
INTEGER                     :: IERR
INTEGER                     :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)
IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      XP=>PRECV(IGXO:IGXE,:)
      IF (JI == KROOT) THEN 
        XP = PSEND(IXO:IXE,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      XP=>PRECV(IGYO:IGYE,:)
      IF (JI==KROOT) THEN 
        XP = PSEND(IYO:IYE,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    XP=>PSEND(IXO:IXE,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    XP=>PSEND(IYO:IYE,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_X2

SUBROUTINE GATHERXX_X3(HDIR,PSEND,PRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),            INTENT(IN) :: HDIR
REAL,DIMENSION(:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                     INTENT(IN) :: KROOT
INTEGER,                     INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                     :: JI
INTEGER                     :: IXO,IXE,IYO,IYE
INTEGER                     :: IGXO,IGXE,IGYO,IGYE
REAL, DIMENSION(:,:,:), POINTER :: XP
INTEGER                     :: IERR
INTEGER                     :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)
IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      XP=>PRECV(IGXO:IGXE,:,:)
      IF (JI == KROOT) THEN 
        XP = PSEND(IXO:IXE,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      XP=>PRECV(IGYO:IGYE,:,:)
      IF (JI==KROOT) THEN 
        XP = PSEND(IYO:IYE,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    XP=>PSEND(IXO:IXE,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    XP=>PSEND(IYO:IYE,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_X3

SUBROUTINE GATHERXX_X4(HDIR,PSEND,PRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),              INTENT(IN) :: HDIR
REAL,DIMENSION(:,:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                       INTENT(IN) :: KROOT
INTEGER,                       INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                     :: JI
INTEGER                     :: IXO,IXE,IYO,IYE
INTEGER                     :: IGXO,IGXE,IGYO,IGYE
REAL, DIMENSION(:,:,:,:), POINTER :: XP
INTEGER                     :: IERR
INTEGER                     :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)
IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      XP=>PRECV(IGXO:IGXE,:,:,:)
      IF (JI == KROOT) THEN 
        XP = PSEND(IXO:IXE,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      XP=>PRECV(IGYO:IGYE,:,:,:)
      IF (JI==KROOT) THEN 
        XP = PSEND(IYO:IYE,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    XP=>PSEND(IXO:IXE,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    XP=>PSEND(IYO:IYE,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_X4

SUBROUTINE GATHERXX_X5(HDIR,PSEND,PRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),                INTENT(IN) :: HDIR
REAL,DIMENSION(:,:,:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                         INTENT(IN) :: KROOT
INTEGER,                         INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                     :: JI
INTEGER                     :: IXO,IXE,IYO,IYE
INTEGER                     :: IGXO,IGXE,IGYO,IGYE
REAL, DIMENSION(:,:,:,:,:), POINTER :: XP
INTEGER                     :: IERR
INTEGER                     :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)
IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      XP=>PRECV(IGXO:IGXE,:,:,:,:)
      IF (JI == KROOT) THEN 
        XP = PSEND(IXO:IXE,:,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      XP=>PRECV(IGYO:IGYE,:,:,:,:)
      IF (JI==KROOT) THEN 
        XP = PSEND(IYO:IYE,:,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    XP=>PSEND(IXO:IXE,:,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    XP=>PSEND(IYO:IYE,:,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_X5

SUBROUTINE GATHERXX_X6(HDIR,PSEND,PRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),                  INTENT(IN) :: HDIR
REAL,DIMENSION(:,:,:,:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:,:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                           INTENT(IN) :: KROOT
INTEGER,                           INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                     :: JI
INTEGER                     :: IXO,IXE,IYO,IYE
INTEGER                     :: IGXO,IGXE,IGYO,IGYE
REAL, DIMENSION(:,:,:,:,:,:), POINTER :: XP
INTEGER                     :: IERR
INTEGER                     :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)
IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      XP=>PRECV(IGXO:IGXE,:,:,:,:,:)
      IF (JI == KROOT) THEN 
        XP = PSEND(IXO:IXE,:,:,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      XP=>PRECV(IGYO:IGYE,:,:,:,:,:)
      IF (JI==KROOT) THEN 
        XP = PSEND(IYO:IYE,:,:,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    XP=>PSEND(IXO:IXE,:,:,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    XP=>PSEND(IYO:IYE,:,:,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_X6

SUBROUTINE GATHERXX_N1(HDIR,KSEND,KRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),           INTENT(IN) :: HDIR
INTEGER,DIMENSION(:),TARGET,INTENT(IN) :: KSEND
INTEGER,DIMENSION(:),TARGET,INTENT(INOUT):: KRECV
INTEGER,                    INTENT(IN) :: KROOT
INTEGER,                    INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                         :: JI
INTEGER                         :: IXO,IXE,IYO,IYE
INTEGER                         :: IGXO,IGXE,IGYO,IGYE
INTEGER, DIMENSION(:), POINTER  :: ITP
INTEGER                         :: IERR
INTEGER                         :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE):: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)

IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      ITP=>KRECV(IGXO:IGXE)
      IF (JI == KROOT) THEN 
        ITP = KSEND(IXO:IXE)
      ELSE 
        CALL MPI_RECV(ITP,SIZE(ITP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      ITP=>KRECV(IGYO:IGYE)
      IF (JI==KROOT) THEN 
        ITP = KSEND(IYO:IYE)
      ELSE 
        CALL MPI_RECV(ITP,SIZE(ITP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    ITP=>KSEND(IXO:IXE)
    CALL MPI_BSEND(ITP,SIZE(ITP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    ITP=>KSEND(IYO:IYE)
    CALL MPI_BSEND(ITP,SIZE(ITP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_N1


SUBROUTINE GATHERXX_N2(HDIR,KSEND,KRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),             INTENT(IN) :: HDIR
INTEGER,DIMENSION(:,:),TARGET,INTENT(IN) :: KSEND
INTEGER,DIMENSION(:,:),TARGET,INTENT(INOUT):: KRECV
INTEGER,                      INTENT(IN) :: KROOT
INTEGER,                      INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                         :: JI
INTEGER                         :: IXO,IXE,IYO,IYE
INTEGER                         :: IGXO,IGXE,IGYO,IGYE
INTEGER, DIMENSION(:,:),POINTER :: ITP
INTEGER                         :: IERR
INTEGER                         :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE):: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)

IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
    
    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      ITP=>KRECV(IGXO:IGXE,:)
      IF (JI == KROOT) THEN 
        ITP = KSEND(IXO:IXE,:)
      ELSE 
        CALL MPI_RECV(ITP,SIZE(ITP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN 
      ITP=>KRECV(IGYO:IGYE,:)
      IF (JI==KROOT) THEN 
        ITP = KSEND(IYO:IYE,:)
      ELSE 
        CALL MPI_RECV(ITP,SIZE(ITP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  
  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    ITP=>KSEND(IXO:IXE,:)
    CALL MPI_BSEND(ITP,SIZE(ITP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    ITP=>KSEND(IYO:IYE,:)
    CALL MPI_BSEND(ITP,SIZE(ITP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_N2

SUBROUTINE GATHERXX_N3(HDIR,KSEND,KRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),               INTENT(IN)   :: HDIR
INTEGER,DIMENSION(:,:,:),TARGET,INTENT(IN)   :: KSEND
INTEGER,DIMENSION(:,:,:),TARGET,INTENT(INOUT):: KRECV
INTEGER,                        INTENT(IN)   :: KROOT
INTEGER,                        INTENT(IN)   :: KCOMM

INTEGER                     :: JI
INTEGER                     :: IXO,IXE,IYO,IYE
INTEGER                     :: IGXO,IGXE,IGYO,IGYE
INTEGER, DIMENSION(:,:,:), POINTER :: IP
INTEGER                     :: IERR
INTEGER                     :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)
IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)

    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      IP=>KRECV(IGXO:IGXE,:,:)
      IF (JI == KROOT) THEN
        IP = KSEND(IXO:IXE,:,:)
      ELSE
        CALL MPI_RECV(IP,SIZE(IP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
      IP=>KRECV(IGYO:IGYE,:,:)
      IF (JI==KROOT) THEN
        IP = KSEND(IYO:IYE,:,:)
      ELSE
        CALL MPI_RECV(IP,SIZE(IP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)

  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    IP=>KSEND(IXO:IXE,:,:)
    CALL MPI_BSEND(IP,SIZE(IP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    IP=>KSEND(IYO:IYE,:,:)
    CALL MPI_BSEND(IP,SIZE(IP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_N3

SUBROUTINE GATHERXX_L1(HDIR,OSEND,ORECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

CHARACTER(LEN=*),           INTENT(IN)    :: HDIR
LOGICAL,DIMENSION(:),TARGET,INTENT(IN)    :: OSEND
LOGICAL,DIMENSION(:),TARGET,INTENT(INOUT) :: ORECV
INTEGER,                    INTENT(IN)    :: KROOT
INTEGER,                    INTENT(IN)    :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                         :: JI
INTEGER                         :: IXO,IXE,IYO,IYE
INTEGER                         :: IGXO,IGXE,IGYO,IGYE
LOGICAL, DIMENSION(:), POINTER  :: GTP
INTEGER                         :: IERR
INTEGER                         :: IXM, IYM
!INTEGER, DIMENSION(MPI_STATUS_SIZE):: STATUS

CALL GET_DOMWRITE_ll(KROOT,'global',IGXO,IGXE,IGYO,IGYE)

IXM = (IGXE+IGXO)/2
IYM = (IGYE+IGYO)/2

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IGXO,IGXE,IGYO,IGYE)
    CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)

    IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
      GTP=>ORECV(IGXO:IGXE)
      IF (JI == KROOT) THEN
        GTP = OSEND(IXO:IXE)
      ELSE
        CALL MPI_RECV(GTP,SIZE(GTP),MPI_LOGICAL,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF

    ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
      GTP=>ORECV(IGYO:IGYE)
      IF (JI==KROOT) THEN
        GTP = OSEND(IYO:IYE)
      ELSE
        CALL MPI_RECV(GTP,SIZE(GTP),MPI_LOGICAL,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO

ELSE
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'global',IGXO,IGXE,IGYO,IGYE)
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)

  IF (HDIR == 'XX' .AND. IYM <= IGYE .AND. IYM >= IGYO) THEN
    GTP=>OSEND(IXO:IXE)
    CALL MPI_BSEND(GTP,SIZE(GTP),MPI_LOGICAL,KROOT-1,99+KROOT,KCOMM,IERR)
  ELSE IF (HDIR == 'YY' .AND. IXM <= IGXE .AND. IXM >= IGXO) THEN
    GTP=>OSEND(IYO:IYE)
    CALL MPI_BSEND(GTP,SIZE(GTP),MPI_LOGICAL,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXX_L1

!
! Gather des champs XY
!
SUBROUTINE GATHERXY_X2(PSEND,PRECV,KROOT,KCOMM,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
USE MODD_IO_ll, ONLY : ISP, ISNPROC
USE MODD_VAR_ll, ONLY : MNH_STATUSES_IGNORE

REAL,DIMENSION(:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                   INTENT(IN) :: KROOT
INTEGER,                   INTENT(IN) :: KCOMM
INTEGER,          OPTIONAL,INTENT(IN) :: KXOBOX,KXEBOX,KYOBOX,KYEBOX
CHARACTER(LEN=*), OPTIONAL,INTENT(IN) :: HINTER

!INCLUDE 'mpif.h'

INTEGER                       :: JI
INTEGER                       :: IXO,IXE,IYO,IYE
REAL, DIMENSION(:,:), POINTER :: XP
INTEGER                       :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS
!JUANZIO
INTEGER,SAVE                       :: REQ(1)
INTEGER,SAVE                       :: NB_REQ = 0
REAL,SAVE,DIMENSION(:,:), POINTER  :: X_2DP => NULL()
!JUANZIO

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
    IF (IXO /= 0) THEN ! intersection is not empty
      XP=>PRECV(IXO:IXE,IYO:IYE)
      IF (ISP == JI) THEN 
        CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
        XP = PSEND(IXO:IXE,IYO:IYE)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO
ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
  IF (IXO /= 0) THEN ! intersection is not empty
    XP=>PSEND(IXO:IXE,IYO:IYE)
    NB_REQ = 1
    ALLOCATE(X_2DP(IXO:IXE,IYO:IYE))
    X_2DP=XP
    CALL MPI_ISEND(X_2DP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,REQ(NB_REQ),IERR)   
    CALL MPI_WAITALL(NB_REQ,REQ,MNH_STATUSES_IGNORE,IERR)
    DEALLOCATE(X_2DP)
    !CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXY_X2

SUBROUTINE GATHERXY_X3(PSEND,PRECV,KROOT,KCOMM,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

REAL,DIMENSION(:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                     INTENT(IN) :: KROOT
INTEGER,                     INTENT(IN) :: KCOMM
INTEGER,            OPTIONAL,INTENT(IN) :: KXOBOX,KXEBOX,KYOBOX,KYEBOX
CHARACTER(LEN=*),   OPTIONAL,INTENT(IN) :: HINTER

!INCLUDE 'mpif.h'

INTEGER                       :: JI
INTEGER                       :: IXO,IXE,IYO,IYE
REAL, DIMENSION(:,:,:),POINTER:: XP
INTEGER                       :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
    IF (IXO /= 0) THEN ! intersection is not empty
      XP=>PRECV(IXO:IXE,IYO:IYE,:)
      IF (ISP == JI) THEN 
        CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
        XP = PSEND(IXO:IXE,IYO:IYE,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO
ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
  IF (IXO /= 0) THEN ! intersection is not empty
    XP=>PSEND(IXO:IXE,IYO:IYE,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXY_X3

SUBROUTINE GATHERXY_X4(PSEND,PRECV,KROOT,KCOMM,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

REAL,DIMENSION(:,:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                       INTENT(IN) :: KROOT
INTEGER,                       INTENT(IN) :: KCOMM
INTEGER,              OPTIONAL,INTENT(IN) :: KXOBOX,KXEBOX,KYOBOX,KYEBOX
CHARACTER(LEN=*),     OPTIONAL,INTENT(IN) :: HINTER

!INCLUDE 'mpif.h'

INTEGER                         :: JI
INTEGER                         :: IXO,IXE,IYO,IYE
REAL, DIMENSION(:,:,:,:),POINTER:: XP
INTEGER                         :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
    IF (IXO /= 0) THEN ! intersection is not empty
      XP=>PRECV(IXO:IXE,IYO:IYE,:,:)
      IF (ISP == JI) THEN 
        CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
        XP = PSEND(IXO:IXE,IYO:IYE,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO
ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
  IF (IXO /= 0) THEN ! intersection is not empty
    XP=>PSEND(IXO:IXE,IYO:IYE,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXY_X4

SUBROUTINE GATHERXY_X5(PSEND,PRECV,KROOT,KCOMM,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

REAL,DIMENSION(:,:,:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                         INTENT(IN) :: KROOT
INTEGER,                         INTENT(IN) :: KCOMM
INTEGER,                OPTIONAL,INTENT(IN) :: KXOBOX,KXEBOX,KYOBOX,KYEBOX
CHARACTER(LEN=*),       OPTIONAL,INTENT(IN) :: HINTER

!INCLUDE 'mpif.h'

INTEGER                           :: JI
INTEGER                           :: IXO,IXE,IYO,IYE
REAL, DIMENSION(:,:,:,:,:),POINTER:: XP
INTEGER                           :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE):: STATUS

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
    IF (IXO /= 0) THEN ! intersection is not empty
      XP=>PRECV(IXO:IXE,IYO:IYE,:,:,:)
      IF (ISP == JI) THEN 
        CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
        XP = PSEND(IXO:IXE,IYO:IYE,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO
ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
  IF (IXO /= 0) THEN ! intersection is not empty
    XP=>PSEND(IXO:IXE,IYO:IYE,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXY_X5

SUBROUTINE GATHERXY_X6(PSEND,PRECV,KROOT,KCOMM,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

REAL,DIMENSION(:,:,:,:,:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:,:,:,:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                           INTENT(IN) :: KROOT
INTEGER,                           INTENT(IN) :: KCOMM
INTEGER,                  OPTIONAL,INTENT(IN) :: KXOBOX,KXEBOX,KYOBOX,KYEBOX
CHARACTER(LEN=*),         OPTIONAL,INTENT(IN) :: HINTER

!INCLUDE 'mpif.h'

INTEGER                             :: JI
INTEGER                             :: IXO,IXE,IYO,IYE
REAL, DIMENSION(:,:,:,:,:,:),POINTER:: XP
INTEGER                             :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE) :: STATUS

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
    IF (IXO /= 0) THEN ! intersection is not empty
      XP=>PRECV(IXO:IXE,IYO:IYE,:,:,:,:)
      IF (ISP == JI) THEN 
        CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
        XP = PSEND(IXO:IXE,IYO:IYE,:,:,:,:)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO
ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
  IF (IXO /= 0) THEN ! intersection is not empty
    XP=>PSEND(IXO:IXE,IYO:IYE,:,:,:,:)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXY_X6

SUBROUTINE GATHERXY_N2(KSEND,KRECV,KROOT,KCOMM)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

INTEGER,DIMENSION(:,:),TARGET,INTENT(IN) :: KSEND
INTEGER,DIMENSION(:,:),TARGET,INTENT(INOUT):: KRECV
INTEGER,                      INTENT(IN) :: KROOT
INTEGER,                      INTENT(IN) :: KCOMM

!INCLUDE 'mpif.h'

INTEGER                        :: JI
INTEGER                        :: IXO,IXE,IYO,IYE
INTEGER,DIMENSION(:,:),POINTER :: ITP
INTEGER                        :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE):: STATUS

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE)
    ITP=>KRECV(IXO:IXE,IYO:IYE)
    IF (ISP == JI) THEN 
      CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE)
      ITP = KSEND(IXO:IXE,IYO:IYE)
    ELSE 
      CALL MPI_RECV(ITP,SIZE(ITP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
    END IF
  END DO
ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE)
  ITP=>KSEND(IXO:IXE,IYO:IYE)
  CALL MPI_BSEND(ITP,SIZE(ITP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
END IF

END SUBROUTINE GATHERXY_N2

SUBROUTINE GATHERXY_N3(KSEND,KRECV,KROOT,KCOMM,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

INTEGER,DIMENSION(:,:,:),TARGET,INTENT(IN) :: KSEND
INTEGER,DIMENSION(:,:,:),TARGET,INTENT(INOUT):: KRECV
INTEGER,                     INTENT(IN) :: KROOT
INTEGER,                     INTENT(IN) :: KCOMM
INTEGER,            OPTIONAL,INTENT(IN) :: KXOBOX,KXEBOX,KYOBOX,KYEBOX
CHARACTER(LEN=*),   OPTIONAL,INTENT(IN) :: HINTER

INTEGER                       :: JI
INTEGER                       :: IXO,IXE,IYO,IYE
INTEGER, DIMENSION(:,:,:),POINTER:: IP
INTEGER                       :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
    IF (IXO /= 0) THEN ! intersection is not empty
      IP=>KRECV(IXO:IXE,IYO:IYE,:)
      IF (ISP == JI) THEN
        CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
        IP = KSEND(IXO:IXE,IYO:IYE,:)
      ELSE
        CALL MPI_RECV(IP,SIZE(IP),MPI_INTEGER,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO
ELSE
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX,HINTER)
  IF (IXO /= 0) THEN ! intersection is not empty
    IP=>KSEND(IXO:IXE,IYO:IYE,:)
    CALL MPI_BSEND(IP,SIZE(IP),MPI_INTEGER,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERXY_N3

SUBROUTINE GATHERBOX_X2(PSEND,PRECV,KROOT,KCOMM,KXOBOX,KXEBOX,KYOBOX,KYEBOX)
USE MODD_IO_ll, ONLY : ISP, ISNPROC

REAL,DIMENSION(:,:),TARGET,INTENT(IN) :: PSEND
REAL,DIMENSION(:,:),TARGET,INTENT(INOUT):: PRECV
INTEGER,                   INTENT(IN) :: KROOT
INTEGER,                   INTENT(IN) :: KCOMM
INTEGER,                   INTENT(IN) :: KXOBOX,KXEBOX,KYOBOX,KYEBOX                    
!INCLUDE 'mpif.h'

INTEGER                       :: JI
INTEGER                       :: IXO,IXE,IYO,IYE
REAL, DIMENSION(:,:), POINTER :: XP
INTEGER                       :: IERR
!INTEGER, DIMENSION(MPI_STATUS_SIZE)   :: STATUS

IF (ISP == KROOT)  THEN
  ! I/O proc case
  DO JI=1,ISNPROC
    CALL GET_DOMWRITE_ll(JI,'global',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX)
    IF (IXO /= 0) THEN ! intersection is not empty
      XP=>PRECV(IXO:IXE,IYO:IYE)
      IF (ISP == JI) THEN 
        CALL GET_DOMWRITE_ll(JI,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX)
        XP = PSEND(IXO:IXE,IYO:IYE)
      ELSE 
        CALL MPI_RECV(XP,SIZE(XP),MPI_FLOAT,JI-1,99+KROOT,KCOMM,MPI_STATUS_IGNORE,IERR)
      END IF
    END IF
  END DO
ELSE 
  ! Other processors
  CALL GET_DOMWRITE_ll(ISP,'local',IXO,IXE,IYO,IYE,KXOBOX,KXEBOX,KYOBOX,KYEBOX)
  IF (IXO /= 0) THEN ! intersection is not empty
    XP=>PSEND(IXO:IXE,IYO:IYE)
    CALL MPI_BSEND(XP,SIZE(XP),MPI_FLOAT,KROOT-1,99+KROOT,KCOMM,IERR)
  END IF
END IF

END SUBROUTINE GATHERBOX_X2

SUBROUTINE GET_DOMWRITE_ll(KIP,HTYPE,KXOR,KXEND,KYOR,KYEND,&
                         & KXORBOX,KXENDBOX,KYORBOX,KYENDBOX,HINTER)

USE MODD_VAR_ll,       ONLY : TCRRT_PROCONF
USE MODD_STRUCTURE_ll,  ONLY : MODELSPLITTING_ll 
USE MODE_TOOLS_ll,     ONLY : LWEST_ll,LEAST_ll,LSOUTH_ll,LNORTH_ll
IMPLICIT NONE 

INTEGER,                  INTENT(IN)  :: KIP
CHARACTER(LEN=*),         INTENT(IN)  :: HTYPE
INTEGER,                  INTENT(OUT) :: KXOR
INTEGER,                  INTENT(OUT) :: KXEND
INTEGER,                  INTENT(OUT) :: KYOR
INTEGER,                  INTENT(OUT) :: KYEND
INTEGER,         OPTIONAL,INTENT(IN)  :: KXORBOX
INTEGER,         OPTIONAL,INTENT(IN)  :: KXENDBOX
INTEGER,         OPTIONAL,INTENT(IN)  :: KYORBOX
INTEGER,         OPTIONAL,INTENT(IN)  :: KYENDBOX
CHARACTER(LEN=*),OPTIONAL,INTENT(IN)  :: HINTER

TYPE(MODELSPLITTING_ll), POINTER :: TB
INTEGER :: IXO,IYO,IXE,IYE
INTEGER :: IXOBOX,IXEBOX,IYOBOX,IYEBOX
CHARACTER(LEN=10) :: YINTER

!
! get the global coordinates of the subdomain KIP
TB => TCRRT_PROCONF%TSPLITS_B(KIP)
!
! definition of the maximum subdomain to write (internal halos are discarded)
IXO = TB%NXORP
IXE = TB%NXENDP
IYO = TB%NYORP
IYE = TB%NYENDP
IF (LWEST_ll(KIP))  IXO = TB%NXORE
IF (LEAST_ll(KIP))  IXE = TB%NXENDE
IF (LSOUTH_ll(KIP)) IYO = TB%NYORE
IF (LNORTH_ll(KIP)) IYE = TB%NYENDE

IF (.NOT. PRESENT(KXORBOX)  .AND. &
    .NOT. PRESENT(KXENDBOX) .AND. &
    .NOT. PRESENT(KYORBOX)  .AND. &
    .NOT. PRESENT(KYENDBOX)) THEN
  ! No box is given : the maximum subdomain to write is returned
  ! This is the default behaviour for all standard MesoNH fields
  IF (HTYPE == 'local' .OR. HTYPE == 'LOCAL') THEN
    IXO = IXO - TB%NXORE + 1
    IXE = IXE - TB%NXORE + 1
    IYO = IYO - TB%NYORE + 1
    IYE = IYE - TB%NYORE + 1
  END IF
  KXOR  = IXO
  KXEND = IXE
  KYOR  = IYO
  KYEND = IYE
ELSE
  ! a Box is supplied (Budget or sub-array defined with a box)
  !
  ! Initialise the Box coordinate
  IXOBOX = KXORBOX
  IXEBOX = KXENDBOX
  IYOBOX = KYORBOX
  IYEBOX = KYENDBOX
  !
  ! compute Intersection with the Box and the subdomain to write 
  ! (in global domain coordinates)
  IXO = MAX(IXO,IXOBOX)
  IXE = MIN(IXE,IXEBOX)
  IYO = MAX(IYO,IYOBOX)
  IYE = MIN(IYE,IYEBOX)
  IF ((IXO > IXE) .OR. (IYO > IYE)) THEN
    !
    ! empty intersection
    KXOR  = 0
    KXEND = 0
    KYOR  = 0
    KYEND = 0
  ELSE
    IF (HTYPE == 'local' .OR. HTYPE == 'LOCAL') THEN
      IF (.NOT. PRESENT(HINTER)) THEN
        YINTER = 'OTHER'
      ELSE
        YINTER = HINTER
      END IF
      IF (YINTER == 'BUDGET') THEN 
        KXOR  = 1
        KXEND = IXE - IXO + 1 
        KYOR  = 1
        KYEND = IYE - IYO + 1
      ELSE !(YINTER == 'OTHER')
        KXOR  = IXO - TB%NXORE + 1
        KXEND = IXE - TB%NXORE + 1
        KYOR  = IYO - TB%NYORE + 1
        KYEND = IYE - TB%NYORE + 1
      END IF
    ELSE !(HTYPE == 'global')
      ! Conversion to Box global coordinates
      KXOR  = IXO - IXOBOX + 1
      KXEND = IXE - IXOBOX + 1
      KYOR  = IYO - IYOBOX + 1
      KYEND = IYE - IYOBOX + 1
    END IF
  END IF
END IF
END SUBROUTINE GET_DOMWRITE_ll
    
END MODULE MODE_GATHER_ll
