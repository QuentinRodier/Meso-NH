!MNH_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!MNH_LIC This is part of the Meso-NH software governed by the CeCILL-C licence
!MNH_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!MNH_LIC for details. version 1.
!############################## 
MODULE MODI_COUPLING_FOREFIRE_n
!############################## 

    INTERFACE

        SUBROUTINE COUPLING_FOREFIRE_n (DT, PSFTH, PSFTQ, PSFSV)
            IMPLICIT NONE
            REAL, INTENT(IN)  :: DT    ! time step of mesonh (s)
            REAL, DIMENSION(:,:),   INTENT(INOUT)  :: PSFTH, PSFTQ ! heat surface flux
            REAL, DIMENSION(:,:,:), INTENT(INOUT)  :: PSFSV ! surface flux of scalars
        END SUBROUTINE COUPLING_FOREFIRE_n

        SUBROUTINE SEND_GROUND_WIND_n (U, V, KG, IINFO)
            IMPLICIT NONE
            REAL, DIMENSION(:,:,:), INTENT(IN)  :: U, V ! wind components
            INTEGER, INTENT(IN) :: KG ! vertical indice of the ground
            INTEGER, INTENT(IN) :: IINFO ! integer for parallel communications
        END SUBROUTINE SEND_GROUND_WIND_n
      
        SUBROUTINE FOREFIRE_SEND_PARAL_n (IINFO)
            IMPLICIT NONE
            INTEGER, INTENT(IN) :: IINFO ! integer for parallel communications
        END SUBROUTINE FOREFIRE_SEND_PARAL_n
      
        SUBROUTINE FOREFIRE_RECEIVE_PARAL_n ()
            IMPLICIT NONE
        END SUBROUTINE FOREFIRE_RECEIVE_PARAL_n

        SUBROUTINE FOREFIRE_DUMP_FIELDS_n(U, V, W, MNHSV, TH &
                                         , R, PABS, TKE, NX, NY, NZ)
            IMPLICIT NONE
            REAL, DIMENSION(:,:,:), INTENT(IN)  :: U, V, W ! wind components (m/s)
            REAL, DIMENSION(:,:,:), INTENT(IN)  :: TH, R, PABS, TKE ! physical fields
            REAL, DIMENSION(:,:,:,:), INTENT(IN)  :: MNHSV ! other MNH variables (/m3)
            INTEGER, INTENT(IN) :: NX, NY, NZ ! size of the matrices
        END SUBROUTINE FOREFIRE_DUMP_FIELDS_n
      
    END INTERFACE

      
END MODULE MODI_COUPLING_FOREFIRE_n


!#######################################################
SUBROUTINE COUPLING_FOREFIRE_n (DT, PSFTH, PSFTQ, PSFSV)
!#######################################################

!!****  *COUPLING_FOREFIRE_n* -
!!      P. Tulet CNRM
!!      X. Pialat SPE

USE MODD_FOREFIRE_n
USE MODD_FOREFIRE
USE MODD_FOREFIRE_FORTRAN_API
USE MODD_NSV

IMPLICIT NONE

REAL, INTENT(IN)  							:: DT     			! time step
REAL, DIMENSION(:,:), INTENT(INOUT)   	:: PSFTH, PSFTQ 	! heat surface flux
REAL, DIMENSION(:,:,:), INTENT(INOUT)  :: PSFSV 			! surface flux of scalars

! bound indices for the scalar variables

INTEGER											:: JSV

!* Advancing the fire simulation for a MNH step
!
   CALL MNH_TO_FF_STEP(DT)
!
!* Injecting fluxes from the fire simulation into MNH
!
	CALL MNH_GET_DOUBLEARRAY(sHeatFlux, FF_HEATFLUX, FF_MATRIXSIZE, 1)
	PSFTH(:, :) = PSFTH(:, :) + FF_HEATFLUX(:, :)

	CALL MNH_GET_DOUBLEARRAY(sVaporFlux, FF_VAPORFLUX, FF_MATRIXSIZE, 1)
	PSFTQ(:, :) = PSFTQ(:, :) + FF_VAPORFLUX(:, :)

	DO JSV = 1, NSV_FF
		CALL MNH_GET_DOUBLEARRAY(sScalarVariables(JSV), FF_SVFLUXES(:, :, JSV), FF_MATRIXSIZE, 1) 
		PSFSV(:, :, NSV_FFBEG-1+JSV) = PSFSV(:, :, NSV_FFBEG-1+JSV) + FF_SVFLUXES(:, :, JSV)
	END DO
	
	IF ( LFFCHEM ) THEN
		DO JSV = 1, NFFCHEMVAR
			CALL MNH_GET_DOUBLEARRAY(sChemicalVariables(JSV), FF_CVFLUXES(:, :, JSV), FF_MATRIXSIZE, 1) 
			PSFSV(:, :, FF_CHEMINDICES(JSV)) = PSFSV(:, :, FF_CHEMINDICES(JSV)) + FF_CVFLUXES(:, :, JSV)
		END DO
	ENDIF

END SUBROUTINE COUPLING_FOREFIRE_n

      	
!##############################################
SUBROUTINE SEND_GROUND_WIND_n (U, V, KG, IINFO)
!##############################################

!!****  *SEND_GROUND_WIND_n* -
!!      X. Pialat SPE

USE MODD_FOREFIRE_n
USE MODD_FOREFIRE
USE MODD_FOREFIRE_FORTRAN_API

USE MODE_ll
USE MODD_ARGSLIST_ll, ONLY : LIST_ll

IMPLICIT NONE

REAL, DIMENSION(:,:,:), INTENT(IN)  :: U, V 		! wind components
INTEGER, INTENT(IN)						:: KG			! vertical indice of the ground
INTEGER, INTENT(IN)						:: IINFO		! integer for parallel communications

INTEGER 										:: IFF, JFF, VAL1, VAL2, VAL3
TYPE(LIST_ll), POINTER           	:: FOREFIREFIELD_ll    ! list of fields to exchange for ForeFire

!
!* Communicating the surface wind to the forefire simulation
!
	CALL MNH_PUT_DOUBLEARRAY(sWindU, FF_TIME, U(:,:,KG:KG), FF_MATRIXSIZE, 1)
	CALL MNH_PUT_DOUBLEARRAY(swindV, FF_TIME, V(:,:,KG:KG), FF_MATRIXSIZE, 1)

!* Then some non-conventional manipulations to communicate the outer velocities
	DO IFF = 2, FF_NX-1
		FFOUTERWINDU(IFF,2) = U(IFF,3,KG)
		FFOUTERWINDU(IFF,FF_NY-1) = U(IFF,FF_NY-2,KG)
		FFOUTERWINDV(IFF,2) = V(IFF,3,KG)
		FFOUTERWINDV(IFF,FF_NY-1) = V(IFF,FF_NY-2,KG)
	END DO
	DO JFF = 2, FF_NY-1
		FFOUTERWINDU(2,JFF) = U(3,JFF,KG)
		FFOUTERWINDU(FF_NX-1,JFF) = U(FF_NX-2,JFF,KG)
		FFOUTERWINDV(2,JFF) = V(3,JFF,KG)
		FFOUTERWINDV(FF_NX-1,JFF) = V(FF_NX-2,JFF,KG)
	END DO
	  
	VAL1 = INT(U(2,3,KG)*FFMULT+0.5)
	VAL2 = INT(U(3,3,KG)*FFMULT+0.5)
	VAL3 = INT(U(3,2,KG)*FFMULT+0.5)
	FFOUTERWINDU(2,2) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3
	VAL1 = INT(V(2,3,KG)*FFMULT+0.5)
	VAL2 = INT(V(3,3,KG)*FFMULT+0.5)
	VAL3 = INT(V(3,2,KG)*FFMULT+0.5)
	FFOUTERWINDV(2,2) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3

	VAL1 = INT(U(FF_NX-2,2,KG)*FFMULT+0.5)
	VAL2 = INT(U(FF_NX-2,3,KG)*FFMULT+0.5)
	VAL3 = INT(U(FF_NX-1,3,KG)*FFMULT+0.5)
	FFOUTERWINDU(FF_NX-1,2) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3
	VAL1 = INT(V(FF_NX-2,2,KG)*FFMULT+0.5)
	VAL2 = INT(V(FF_NX-2,3,KG)*FFMULT+0.5)
	VAL3 = INT(V(FF_NX-1,3,KG)*FFMULT+0.5)
	FFOUTERWINDV(FF_NX-1,2) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3

	VAL1 = INT(U(3,FF_NY-1,KG)*FFMULT+0.5)
	VAL2 = INT(U(3,FF_NY-2,KG)*FFMULT+0.5)
	VAL3 = INT(U(2,FF_NY-2,KG)*FFMULT+0.5)
	FFOUTERWINDU(2,FF_NY-1) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3
	VAL1 = INT(V(3,FF_NY-1,KG)*FFMULT+0.5)
	VAL2 = INT(V(3,FF_NY-2,KG)*FFMULT+0.5)
	VAL3 = INT(V(2,FF_NY-2,KG)*FFMULT+0.5)
	FFOUTERWINDV(2,FF_NY-1) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3

	VAL1 = INT(U(FF_NX-1,FF_NY-2,KG)*FFMULT+0.5)
	VAL2 = INT(U(FF_NX-2,FF_NY-2,KG)*FFMULT+0.5)
	VAL3 = INT(U(FF_NX-2,FF_NY-1,KG)*FFMULT+0.5)
	FFOUTERWINDU(FF_NX-1,FF_NY-1) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3
	VAL1 = INT(V(FF_NX-1,FF_NY-2,KG)*FFMULT+0.5)
	VAL2 = INT(V(FF_NX-2,FF_NY-2,KG)*FFMULT+0.5)
	VAL3 = INT(V(FF_NX-2,FF_NY-1,KG)*FFMULT+0.5)
	FFOUTERWINDV(FF_NX-1,FF_NY-1) = VAL1*FFMULT*FFMULT*100 + VAL2*FFMULT*10 + VAL3

	NULLIFY(FOREFIREFIELD_ll)
	CALL ADD2DFIELD_ll(FOREFIREFIELD_ll,FFOUTERWINDU)
	CALL ADD2DFIELD_ll(FOREFIREFIELD_ll,FFOUTERWINDV)
	CALL UPDATE_HALO_ll(FOREFIREFIELD_ll,IINFO)
	CALL CLEANLIST_ll(FOREFIREFIELD_ll)
	CALL MNH_PUT_DOUBLEARRAY(sOutWindU, FF_TIME, FFOUTERWINDU, FF_MATRIXSIZE, 1)
	CALL MNH_PUT_DOUBLEARRAY(sOutWindV, FF_TIME, FFOUTERWINDV, FF_MATRIXSIZE, 1)
   
END SUBROUTINE SEND_GROUND_WIND_n

      	
!#####################################
SUBROUTINE FOREFIRE_RECEIVE_PARAL_n ()
!#####################################

!!****  *FOREFIRE_RECEIVE_PARAL_n* -
!!      X. Pialat SPE

USE MODD_FOREFIRE_n
USE MODD_FOREFIRE
USE MODD_FOREFIRE_FORTRAN_API

IMPLICIT NONE

	CALL MNH_PUT_DOUBLEARRAY(sPosX, FF_TIME, FFNODES_POSX, FF_PARALMATRIXSIZE, 1)
	CALL MNH_PUT_DOUBLEARRAY(sPosY, FF_TIME, FFNODES_POSY, FF_PARALMATRIXSIZE, 1)
	CALL MNH_PUT_DOUBLEARRAY(sVelX, FF_TIME, FFNODES_VELX, FF_PARALMATRIXSIZE, 1)
	CALL MNH_PUT_DOUBLEARRAY(sVelY, FF_TIME, FFNODES_VELY, FF_PARALMATRIXSIZE, 1)
	CALL MNH_PUT_DOUBLEARRAY(sTime, FF_TIME, FFNODES_TIME, FF_PARALMATRIXSIZE, 1)
	CALL MNH_PUT_DOUBLEARRAY(sId, FF_TIME, FFNODES_ID, FF_PARALMATRIXSIZE, 1)
   
END SUBROUTINE FOREFIRE_RECEIVE_PARAL_n

      	
!#######################################
SUBROUTINE FOREFIRE_SEND_PARAL_n (IINFO)
!#######################################

!!****  *FOREFIRE_SEND_PARAL_n* -
!!      X. Pialat (SPE)

USE MODD_FOREFIRE_n
USE MODD_FOREFIRE
USE MODD_FOREFIRE_FORTRAN_API

USE MODE_ll
USE MODD_ARGSLIST_ll, ONLY : LIST_ll

IMPLICIT NONE

INTEGER, INTENT(IN)					:: IINFO
TYPE(LIST_ll), POINTER           :: FOREFIREFIELD_ll    ! list of fields to exchange for ForeFire

	CALL MNH_GET_DOUBLEARRAY(sPosX, FFNODES_POSX, FF_PARALMATRIXSIZE, 1)
	CALL MNH_GET_DOUBLEARRAY(sPosY, FFNODES_POSY, FF_PARALMATRIXSIZE, 1)
	CALL MNH_GET_DOUBLEARRAY(sVelX, FFNODES_VELX, FF_PARALMATRIXSIZE, 1)
	CALL MNH_GET_DOUBLEARRAY(sVelY, FFNODES_VELY, FF_PARALMATRIXSIZE, 1)
	CALL MNH_GET_DOUBLEARRAY(sTime, FFNODES_TIME, FF_PARALMATRIXSIZE, 1)
	CALL MNH_GET_DOUBLEARRAY(sId, FFNODES_ID, FF_PARALMATRIXSIZE, 1)
!
!* Calling the MNH parallel routines for the forefire-related variables
!
	NULLIFY(FOREFIREFIELD_ll)
	CALL ADD3DFIELD_ll(FOREFIREFIELD_ll, FFNODES_POSX)
	CALL ADD3DFIELD_ll(FOREFIREFIELD_ll, FFNODES_POSY)
	CALL ADD3DFIELD_ll(FOREFIREFIELD_ll, FFNODES_VELX)
	CALL ADD3DFIELD_ll(FOREFIREFIELD_ll, FFNODES_VELY)
	CALL ADD3DFIELD_ll(FOREFIREFIELD_ll, FFNODES_TIME)
	CALL ADD3DFIELD_ll(FOREFIREFIELD_ll, FFNODES_ID)
	CALL UPDATE_HALO_ll(FOREFIREFIELD_ll, IINFO)
	CALL CLEANLIST_ll(FOREFIREFIELD_ll)
   
END SUBROUTINE FOREFIRE_SEND_PARAL_n
      	
      	
!#####################################################
SUBROUTINE FOREFIRE_DUMP_FIELDS_n(U, V, W, MNHSV, TH &
									, R, PABS, TKE, NX, NY, NZ)
!#####################################################

!!****  *FOREFIRE_DUMP_FIELDS_n* -
!!      X. Pialat (SPE)

USE MODD_NSV
USE MODD_FOREFIRE_n
USE MODD_FOREFIRE
USE MODD_FOREFIRE_FORTRAN_API
USE MODD_CH_M9_n,   	ONLY: CNAMES

IMPLICIT NONE

REAL, DIMENSION(:,:,:), INTENT(IN)  	:: U, V, W 					! wind components (m/s)
REAL, DIMENSION(:,:,:), INTENT(IN)  	:: TH, R, PABS, TKE 		! physical fields
REAL, DIMENSION(:,:,:,:), INTENT(IN)  	:: MNHSV 					! other MNH variables (/m3)
INTEGER, INTENT(IN)							:: NX, NY, NZ				! size of the matrices

INTEGER :: JSV

!
!* sending the arrays to binary unformatted fortran files for visualization
!
	IF ( ((FF_TIME/FFOUTPUTSUPDATE).GE.FFNUMOUT) ) THEN
		FF3DOUT = 1
		FFNUMOUT = FFNUMOUT + 1
	END IF
	
	IF ( FF3DOUTPUTSFLOW .AND. FF3DOUT.EQ.1 ) THEN
		CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, sU, FF_TIME, U, NX*NY*NZ, NX, NY, NZ, 1)
		CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, sV, FF_TIME, V, NX*NY*NZ, NX, NY, NZ, 1)
		CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, sW, FF_TIME, W, NX*NY*NZ, NX, NY, NZ, 1)
		DO JSV = 1, NSV_FF
			CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, cast_char_to_c(CSV(NSV_FFBEG-1+JSV)) &
				, FF_TIME, MNHSV(:, :, :, NSV_FFBEG-1+JSV), NX*NY*NZ, NX, NY, NZ, 1)
		END DO
	END IF
	
	IF ( FF3DOUTPUTSPHYS .AND. FF3DOUT.EQ.1 ) THEN
		CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, sT, FF_TIME, TH, NX*NY*NZ, NX, NY, NZ, 1)
		CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, sMoist, FF_TIME, R, NX*NY*NZ, NX, NY, NZ, 1)
		CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, sP, FF_TIME, PABS, NX*NY*NZ, NX, NY, NZ, 1)
		CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, sTKE, FF_TIME, TKE, NX*NY*NZ, NX, NY, NZ, 1)
	END IF
	
	IF ( LFFCHEM .AND. FF3DOUTPUTSCHEM .AND. FF3DOUT.EQ.1 ) THEN
		DO JSV = 1, NFFCHEMVAR
			CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, cast_char_to_c(CNAMES(FF_CHEMINDICES(JSV))) &
						, FF_TIME, MNHSV(:, :, :, FF_CHEMINDICES(JSV)), NX*NY*NZ, NX, NY, NZ, 1)
		END DO
		DO JSV = 1, NFFCHEMVAROUT
			CALL MNH_DUMP_DOUBLEARRAY(FFNMODEL, PROCID, cast_char_to_c(CNAMES(FF_CHEMINDOUT(JSV))) &
						, FF_TIME, MNHSV(:, :, :, FF_CHEMINDOUT(JSV)), NX*NY*NZ, NX, NY, NZ, 1)
		END DO
	END IF
	
	FF3DOUT = 0

END SUBROUTINE FOREFIRE_DUMP_FIELDS_n
