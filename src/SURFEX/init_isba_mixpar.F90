!SURFEX_LIC Copyright 1994-2014 Meteo-France 
!SURFEX_LIC This is part of the SURFEX software governed by the CeCILL-C  licence
!SURFEX_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt
!SURFEX_LIC for details. version 1.
!     #########
      SUBROUTINE INIT_ISBA_MIXPAR(HISBA,KDECADE,KDECADE2,PCOVER,HPHOTO,HSFTYPE)
!     ##############################################################
!
!!**** *INIT_ISBA_MIXPAR* 
!!
!!    PURPOSE
!!    -------
!!   This routine makes pre-calculations relative to dependances between
!!    parameters. 
!! 
!!    METHOD
!!    ------
!!   First are treated parameters varying in time. Then, other ones. 
!!   * XPAR_VEGTYPE is needed as soon as 1 LDATA_ is true to use av_pgd_param. 
!!   * XPAR_LAI is needed as soon as av_pgd_param is called with YLAI
!!   * XPAR_VEG is needed as soon as av_pgd_param is called with YVEG
!!   * XPAR_H_TREE is needed as soon as Z0 is calculated by ini_data_param by point
!!
!!    EXTERNAL
!!    --------
!!
!!    IMPLICIT ARGUMENTS
!!    ------------------
!!
!!    REFERENCE
!!    ---------
!!
!!    AUTHOR
!!    ------
!!
!!    S. Faroux        Meteo-France
!!
!!    MODIFICATION
!!    ------------
!!
!!    Original    16/11/10
!!
!----------------------------------------------------------------------------
!
!*    0.     DECLARATION
!            -----------
!
USE MODD_SURF_PAR,       ONLY : XUNDEF
USE MODD_DATA_COVER_PAR, ONLY : NVEGTYPE
!
USE MODD_ISBA_GRID_n,    ONLY : NDIM
USE MODD_ISBA_n,         ONLY : NGROUND_LAYER
USE MODD_DATA_ISBA_n,    ONLY : NTIME, XPAR_VEGTYPE,  XPAR_LAI, XPAR_H_TREE,               &
                                XPAR_VEG, XPAR_Z0, XPAR_EMIS, XPAR_DICE,                   &
                                XPAR_RSMIN, XPAR_GAMMA, XPAR_WRMAX_CF, XPAR_RGL,           &
                                XPAR_CV, XPAR_Z0_O_Z0H,                                    &
                                XPAR_ALBNIR_VEG, XPAR_ALBVIS_VEG, XPAR_ALBUV_VEG,          &
                                XPAR_ALBNIR_SOIL, XPAR_ALBVIS_SOIL, XPAR_ALBUV_SOIL,       &
                                XPAR_GMES, XPAR_BSLAI, XPAR_SEFOLD, XPAR_GC, XPAR_DMAX,    &
                                XPAR_RE25, XPAR_LAIMIN, XPAR_F2I,                          &
                                XPAR_CE_NITRO,XPAR_CF_NITRO,XPAR_CNA_NITRO,                &
                                LPAR_STRESS, XPAR_IRRIG, XPAR_WATSUP,                      &
                                XPAR_DG, XPAR_ROOT_EXTINCTION, XPAR_ROOT_LIN, LDATA_DG,    &
                                LDATA_ROOTFRAC, LDATA_ROOT_EXTINCTION, LDATA_ROOT_LIN,     &
                                LDATA_VEGTYPE, LDATA_LAI, LDATA_H_TREE,                    &  
                                LDATA_VEG, LDATA_Z0, LDATA_EMIS, LDATA_DICE,               &
                                LDATA_RSMIN, LDATA_GAMMA, LDATA_WRMAX_CF, LDATA_RGL,       &
                                LDATA_CV, LDATA_Z0_O_Z0H, LDATA_ROOT_DEPTH,                &
                                LDATA_ALBNIR_VEG, LDATA_ALBVIS_VEG, LDATA_ALBUV_VEG,       &
                                LDATA_ALBVIS_SOIL, LDATA_ALBNIR_SOIL, LDATA_ALBUV_SOIL,    &
                                LDATA_GMES, LDATA_BSLAI, LDATA_SEFOLD, LDATA_GC, LDATA_DMAX, &
                                LDATA_RE25, LDATA_LAIMIN, LDATA_F2I,                       &
                                LDATA_CE_NITRO,LDATA_CF_NITRO, LDATA_CNA_NITRO,            &
                                LDATA_STRESS, LDATA_IRRIG, LDATA_WATSUP, LDATA_MIXPAR 
!
USE MODD_DATA_COVER_n,   ONLY : XDATA_VEGTYPE
USE MODD_DATA_COVER,     ONLY : XDATA_LAI, XDATA_H_TREE, XDATA_VEG,         &
                                XDATA_IRRIG, XDATA_WATSUP
!     
USE MODI_INI_DATA_PARAM
USE MODI_AV_PGD
!
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
USE PARKIND1  ,ONLY : JPRB
!
IMPLICIT NONE
!
!*    0.1    Declaration of arguments
!            ------------------------
!
 CHARACTER(LEN=*), INTENT(IN)          :: HISBA 
INTEGER,                INTENT(IN)    :: KDECADE
INTEGER,                INTENT(OUT)   :: KDECADE2
REAL, DIMENSION(:,:),   INTENT(IN)    :: PCOVER
 CHARACTER(LEN=*),       INTENT(IN)    :: HPHOTO  ! type of photosynthesis
 CHARACTER(LEN=*),       INTENT(IN)    :: HSFTYPE ! nature / garden
!
!
!*    0.2    Declaration of local variables
!            ------------------------------
!
REAL, DIMENSION(12)   :: XSTRESS   ! 1. if defensive /0. if offensive
!
 CHARACTER(LEN=3)  :: YTREE, YNAT, YVEG
!
INTEGER               :: JVEGTYPE
!
!*    0.3    Declaration of namelists
!            ------------------------
!
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
DATA XSTRESS /1.,1.,1.,0.,1.,0.,1.,0.,1.,0.,0.,0./
!-------------------------------------------------------------------------------
!
!*    1.      Initializations
!             ---------------
!
IF (LHOOK) CALL DR_HOOK('INIT_ISBA_MIXPAR',0,ZHOOK_HANDLE)
!
IF (.NOT.LDATA_MIXPAR) THEN
  IF (LHOOK) CALL DR_HOOK('INIT_ISBA_MIXPAR',1,ZHOOK_HANDLE)
  RETURN
ENDIF
!
IF (HSFTYPE=='NAT') THEN
  YNAT='NAT'
  YTREE='TRE'
  YVEG='VEG'
ELSEIF (HSFTYPE=='GRD') THEN
  YNAT='GRD'
  YTREE='GRT'
  YVEG='GRV'
ENDIF
!
KDECADE2 = KDECADE
IF (NTIME==2) KDECADE2 = KDECADE2 + 10 
KDECADE2 = (KDECADE2-1) * NTIME / 36 + 1
IF (NTIME==2 .AND. KDECADE2==3) KDECADE2 = 1
!
!          1. Arrays needed further
!          ------------------------
!
!XPAR_VEGTYPE will be needed to use ini_data_param by point
IF (.NOT.LDATA_VEGTYPE) THEN
  ALLOCATE(XPAR_VEGTYPE   (NDIM,NVEGTYPE))
  DO JVEGTYPE=1,NVEGTYPE
    CALL AV_PGD (XPAR_VEGTYPE(:,JVEGTYPE),PCOVER ,XDATA_VEGTYPE(:,JVEGTYPE),YNAT,'ARI')
  END DO
ENDIF
!xpar_lai: needed for av_pgd_param with YLAI
IF (.NOT.LDATA_LAI) THEN
  ALLOCATE(XPAR_LAI(NDIM,NTIME,NVEGTYPE))
  CALL AV_PGD(XPAR_LAI(:,KDECADE2,:),PCOVER,XDATA_LAI(:,KDECADE,:),YVEG,'ARI',KDECADE=KDECADE2)
ENDIF
!veg
IF (.NOT.LDATA_VEG) THEN
  ALLOCATE(XPAR_VEG(NDIM,NTIME,NVEGTYPE))
  IF (LDATA_LAI) THEN
    CALL INI_DATA_PARAM(XPAR_VEGTYPE,PLAI=XPAR_LAI,PVEG_OUT=XPAR_VEG)
    LDATA_VEG=.TRUE.
  ELSE
    CALL AV_PGD(XPAR_VEG(:,KDECADE2,:),PCOVER,XDATA_VEG(:,KDECADE,:),YNAT,'ARI')
  ENDIF
ENDIF
!ht: needed to calculate z0, if not calculated yet during extrapolation 
IF (.NOT.LDATA_H_TREE .AND. .NOT.LDATA_Z0 .AND. LDATA_LAI) THEN
  ALLOCATE(XPAR_H_TREE(NDIM,NVEGTYPE))
  CALL AV_PGD(XPAR_H_TREE,PCOVER,XDATA_H_TREE,YTREE,'ARI')
ENDIF
!
!dg: initialization for ROOTFRAC
!ROOTFRAC depends on ROOT_DEPTH, DG, ROOT_EXT, ROOT_LIN
IF (.NOT.LDATA_ROOTFRAC .AND. HISBA=='DIF' .AND. LDATA_ROOT_DEPTH) THEN
  !
  IF (.NOT.LDATA_ROOT_EXTINCTION) THEN
    ALLOCATE(XPAR_ROOT_EXTINCTION(NDIM,NVEGTYPE))
    CALL INI_DATA_PARAM(XPAR_VEGTYPE,PROOT_EXTINCTION=XPAR_ROOT_EXTINCTION)
    LDATA_ROOT_EXTINCTION = .TRUE.
  ENDIF
  !
  IF (.NOT.LDATA_ROOT_LIN) THEN
    ALLOCATE(XPAR_ROOT_LIN(NDIM,NVEGTYPE))
    CALL INI_DATA_PARAM(XPAR_VEGTYPE,PROOT_LIN=XPAR_ROOT_LIN)
    LDATA_ROOT_LIN = .TRUE.
  ENDIF
  !
ENDIF
!
!dice: depth of the soil column for the calculation of the frozen soil fraction (m)
IF (LDATA_DG .AND. .NOT.LDATA_DICE) THEN
  !
  ALLOCATE(XPAR_DICE(NDIM,NVEGTYPE))
  !
  IF(HISBA/='DIF')THEN
    XPAR_DICE(:,:)=MAX(0.2,0.8*XPAR_DG(:,2,:))
    LDATA_DICE=.TRUE.
  ENDIF
!
ENDIF
!
!          2. Calculations of parameters dependant on others
!          -------------------------------------------------
!
!emis
IF (.NOT.LDATA_EMIS .AND. LDATA_VEG) THEN
  ALLOCATE(XPAR_EMIS(NDIM,NTIME,NVEGTYPE))
  CALL INI_DATA_PARAM(XPAR_VEGTYPE,PVEG_IN=XPAR_VEG,PEMIS_ECO=XPAR_EMIS)
  LDATA_EMIS=.TRUE.
ENDIF
!z0
IF (.NOT.LDATA_Z0 .AND. (LDATA_LAI .OR.LDATA_H_TREE)) THEN
  ALLOCATE(XPAR_Z0(NDIM,NTIME,NVEGTYPE))
  CALL INI_DATA_PARAM(XPAR_VEGTYPE,PLAI=XPAR_LAI,PH_TREE=XPAR_H_TREE,PZ0=XPAR_Z0)
  LDATA_Z0=.TRUE.
ENDIF

!RSMIN
IF (LDATA_LAI) THEN
  IF (.NOT.LDATA_RSMIN) THEN
    ALLOCATE(XPAR_RSMIN(NDIM,NVEGTYPE))
    CALL INI_DATA_PARAM(XPAR_VEGTYPE,PRSMIN=XPAR_RSMIN)
  ENDIF
  LDATA_RSMIN=.TRUE.
ENDIF

!parameters calculated on veg fraction
IF (LDATA_VEG) THEN
  !
  IF (.NOT.LDATA_GAMMA) ALLOCATE(XPAR_GAMMA     (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_WRMAX_CF) ALLOCATE(XPAR_WRMAX_CF  (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_RGL) ALLOCATE(XPAR_RGL       (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_CV) ALLOCATE(XPAR_CV        (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_ALBNIR_VEG) ALLOCATE(XPAR_ALBNIR_VEG(NDIM,NVEGTYPE))
  IF (.NOT.LDATA_ALBVIS_VEG) ALLOCATE(XPAR_ALBVIS_VEG(NDIM,NVEGTYPE))
  IF (.NOT.LDATA_ALBUV_VEG) ALLOCATE(XPAR_ALBUV_VEG (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_GMES) ALLOCATE(XPAR_GMES      (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_BSLAI) ALLOCATE(XPAR_BSLAI     (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_SEFOLD) ALLOCATE(XPAR_SEFOLD    (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_GC) ALLOCATE(XPAR_GC        (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_LAIMIN) ALLOCATE(XPAR_LAIMIN    (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_F2I) ALLOCATE(XPAR_F2I       (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_CE_NITRO) ALLOCATE(XPAR_CE_NITRO  (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_CF_NITRO) ALLOCATE(XPAR_CF_NITRO  (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_CNA_NITRO) ALLOCATE(XPAR_CNA_NITRO (NDIM,NVEGTYPE))
  !
  IF (.NOT.LDATA_GAMMA) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PGAMMA=XPAR_GAMMA)
  IF (.NOT.LDATA_WRMAX_CF) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PWRMAX_CF=XPAR_WRMAX_CF)
  IF (.NOT.LDATA_RGL) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PRGL=XPAR_RGL)
  IF (.NOT.LDATA_CV) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PCV=XPAR_CV)
  IF (.NOT.LDATA_ALBNIR_VEG) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PALBNIR_VEG=XPAR_ALBNIR_VEG)
  IF (.NOT.LDATA_ALBVIS_VEG) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PALBVIS_VEG=XPAR_ALBVIS_VEG)
  IF (.NOT.LDATA_ALBUV_VEG) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PALBUV_VEG=XPAR_ALBUV_VEG)
  IF (HPHOTO == 'AST' .OR. HPHOTO == 'LST' .OR. HPHOTO == 'NIT' .OR. HPHOTO=='NCB')  THEN
    IF (.NOT.LDATA_GMES) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PGMES_ST=XPAR_GMES)
    IF (.NOT.LDATA_BSLAI) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PBSLAI_ST=XPAR_BSLAI)
    IF (.NOT.LDATA_SEFOLD) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PSEFOLD_ST=XPAR_SEFOLD)
    IF (.NOT.LDATA_GC) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PGC_ST=XPAR_GC)
  ELSE
    IF (.NOT.LDATA_GMES) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PGMES=XPAR_GMES)
    IF (.NOT.LDATA_BSLAI) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PBSLAI=XPAR_BSLAI)
    IF (.NOT.LDATA_SEFOLD) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PSEFOLD=XPAR_SEFOLD)
    IF (.NOT.LDATA_GC) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PGC=XPAR_GC)
  ENDIF
  IF (.NOT.LDATA_LAIMIN) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PLAIMIN=XPAR_LAIMIN)
  IF (.NOT.LDATA_F2I) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PF2I=XPAR_F2I)
  IF (.NOT.LDATA_CE_NITRO) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PCE_NITRO=XPAR_CE_NITRO)
  IF (.NOT.LDATA_CF_NITRO) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PCF_NITRO=XPAR_CF_NITRO)
  IF (.NOT.LDATA_CNA_NITRO) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PCNA_NITRO=XPAR_CNA_NITRO)
  !
  LDATA_GAMMA=.TRUE.
  LDATA_WRMAX_CF=.TRUE.
  LDATA_RGL=.TRUE.
  LDATA_CV=.TRUE.
  LDATA_ALBNIR_VEG=.TRUE.
  LDATA_ALBVIS_VEG=.TRUE.
  LDATA_ALBUV_VEG=.TRUE.
  LDATA_GMES=.TRUE.
  LDATA_BSLAI=.TRUE.
  LDATA_SEFOLD=.TRUE.
  LDATA_GC=.TRUE.
  LDATA_LAIMIN=.TRUE.
  LDATA_F2I=.TRUE.
  LDATA_CE_NITRO=.TRUE.
  LDATA_CF_NITRO=.TRUE.
  LDATA_CNA_NITRO=.TRUE.
  !
  LDATA_STRESS=.TRUE.
  !
  ALLOCATE(LPAR_STRESS   (NDIM,NVEGTYPE))  
  LPAR_STRESS(:,:) = .TRUE.
  DO JVEGTYPE=1,NVEGTYPE
    IF(XSTRESS(JVEGTYPE)<1.) LPAR_STRESS(:,JVEGTYPE) = .FALSE.
  ENDDO
  !
  IF (.NOT.LDATA_IRRIG) THEN
    ALLOCATE(XPAR_IRRIG     (NDIM,NTIME,NVEGTYPE))
    CALL AV_PGD(XPAR_IRRIG(:,KDECADE2,:),PCOVER,XDATA_IRRIG(:,:),YVEG,'ARI',KDECADE=KDECADE2)
    LDATA_IRRIG=.TRUE.
  ENDIF
  !
  IF (.NOT.LDATA_WATSUP) THEN
    ALLOCATE(XPAR_WATSUP     (NDIM,NTIME,NVEGTYPE))
    CALL AV_PGD(XPAR_WATSUP(:,KDECADE2,:),PCOVER,XDATA_WATSUP(:,:),YVEG,'ARI',KDECADE=KDECADE2)
    LDATA_WATSUP=.TRUE.
  ENDIF
  !
ENDIF
!
!
IF (LDATA_VEGTYPE) THEN
  IF (.NOT.LDATA_Z0_O_Z0H) ALLOCATE(XPAR_Z0_O_Z0H  (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_DMAX) ALLOCATE(XPAR_DMAX      (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_RE25) ALLOCATE(XPAR_RE25      (NDIM,NVEGTYPE))
  IF (.NOT.LDATA_Z0_O_Z0H) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PZ0_O_Z0H=XPAR_Z0_O_Z0H)
  IF (HPHOTO == 'AST' .OR. HPHOTO == 'LST' .OR. HPHOTO == 'NIT' .OR. HPHOTO=='NCB')  THEN
    IF (.NOT.LDATA_DMAX) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PDMAX_ST=XPAR_DMAX)
  ELSE
    IF (.NOT.LDATA_DMAX) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PDMAX=XPAR_DMAX)
  ENDIF
  IF (.NOT.LDATA_RE25) CALL INI_DATA_PARAM(XPAR_VEGTYPE,PRE25=XPAR_RE25)
  !
  LDATA_Z0_O_Z0H=.TRUE.
  LDATA_DMAX=.TRUE.
  LDATA_RE25=.TRUE.
ENDIF
!
IF (LHOOK) CALL DR_HOOK('INIT_ISBA_MIXPAR',1,ZHOOK_HANDLE)
!
!-------------------------------------------------------------------------------
!
END SUBROUTINE INIT_ISBA_MIXPAR
